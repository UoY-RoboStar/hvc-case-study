	module ctrl3
		shared_variable_events = {|
		|}
		
	exports
		transparent diamond
		transparent sbisim
		transparent dbisim
		transparent chase

		-- declaring controller events
		channel int_ActualHV: InOut.core_real
		channel ActualHV_1: InOut.core_real
		channel ActualHV_2: InOut.core_real
		
		
		
		-- declaring call and ret events for undefined operations
		
		-- declaring controller termination channel		
		channel terminate
		
		-- set of visible memory events
		visibleMemoryEvents = {||}

		-- defined operations
	
		-- declaring machines
		module stm0
		exports
			transparent diamond
			transparent sbisim
			transparent dbisim
			transparent chase
		
			-- flow channels
			channel internal__ : TIDS
			
			-- The following are now declared per state (using modules)
			--channel enter, entered: NIDS
			channel exit
			channel exited
			channel terminate
			
			-- variable channels
			channel get_ActualHV, set_ActualHV, setL_ActualHV, setR_ActualHV: core_real
			
			-- shared variable channels
			
			-- local variable channels for defined operations that are required by the state machine
			
			-- declaring state machine events
			channel int_ActualHV__: TIDS.InOut.core_real
			channel int_ActualHV: InOut.core_real
			channel ActualHV_1__: TIDS.InOut.core_real
			channel ActualHV_1: InOut.core_real
			channel ActualHV_2__: TIDS.InOut.core_real
			channel ActualHV_2: InOut.core_real
			
			-- declaring call and ret events for undefined operations
			
			enterCSet = {|
			i0::enter,
			s0::enter
			|}
			
			enteredCSet = 	{|
			s0::entered
			|}
			
			internal_events = union(enteredCSet,union(enterCSet,{|exit,exited|}))
			
			shared_variable_events = {|
			|}
			
			
			channel clockReset, clockResetL, clockResetR 
			
			localClockResets = {||}
			
			
			channel get_CLID_s0 : CLID_s0_clock_type
			
			channel increment__
			
			CLID_s0_clock_type = {0..(clock_type_max(Union({
			}))+1)}
			
		
				Timed(OneStep) {
					-- Only the undefined operations are declared here.
					-- If the state machine is in isolation, all required operations will be undefined.
					-- If it is in the context of a controller, the required operations not provided by the
					-- controller will be declared here, and the defined operations will be defined in the
					-- context of the Controller module, and therefore within scope of the state machien module.
					
					
					-- declaring identifiers of transitions
					datatype TIDS = NULLTRANSITION__
					              | TID_stm0_t0
					              | TID_stm0_t1
					
					}
					-- declaring all nodes
					
					----------------------------------------------------------------------
					-- Initial: i0
					module i0
					exports
					
						channel enter, exit
						
						Timed(OneStep) {
							D__(id__) = dbisim(let
										Inactive = (MStop /\ enter -> SKIP) ; (MStop /\ exit -> Inactive)
									within
										Inactive)
										
							VS_O__(id__) = D__(id__)
						}
					
					endmodule
					----------------------------------------------------------------------
					
					
					----------------------------------------------------------------------
					-- State: s0
					module s0
					
					enterCSet = {}
					
					enteredCSet = {}
					
					exports
					
						--  Declarations
						-- declaring identifiers of transitions
						datatype TIDS = NULLTRANSITION__
						
						channel internal__ : TIDS
						channel enter, entered, exit, exited
						channel enteredL, enteredR
						channel end__
						
										
						
						
						channel increment__
						
						
						--	Nodes
						-- declaring all nodes
						
						TransitionSync = {||}
						
						Timed(OneStep) {
							--	Rule: behaviours(Node)
							--  Note that FDR has problems with efficiently compiling the process below
							-- 	if using a different recursion pattern.
							D__(id__) = 
							dbisim(let
								Inactive = (MStop /\ enter -> SKIP) ; true&(int_ActualHV.in?ActualHV -> set_ActualHV!ActualHV -> SKIP)
								 ; 
											Behaviour ; 
											SKIP ; 
											exited -> SKIP ; Inactive
							
								Behaviour = entered -> ((SKIP ; MStop) /\ exit -> SKIP)
							within
								Inactive)
								
							VS_O__(id__) = 
								dbisim(let
									Inactive = (MStop /\ enter -> SKIP) ; true&(int_ActualHV.in?ActualHV -> set_ActualHV!ActualHV -> SKIP)
									 ; 
												Behaviour ; 
												SKIP ; 
												exited -> SKIP ; Inactive
							
									Behaviour = entered -> ((SKIP ; MStop) /\ exit -> SKIP)
								within
									Inactive)
							
						}
					
					endmodule
					----------------------------------------------------------------------
					
					Timed(OneStep) {
					
					TransitionSync = {|internal__.TID_stm0_t0,
					internal__.TID_stm0_t1|}
					
					-- The following is obviously not efficient for FDR to compile.
					-- For efficiency reasons a stepwise composition should be implemented instead.
					ComposeNodes_aux(id__) = [| { up__ } |] proc__ : {i0::D__(id__),s0::D__(id__)} @ proc__
					
					ComposeNodes_VS_O_aux(id__) = [| { up__ } |] proc__ : {i0::VS_O__(id__),s0::VS_O__(id__)} @ proc__
					
					ComposeNodes(id__) = ComposeNodes_aux(id__) [| union(TDeadlinesSync,{up__}) |] TDeadlines(id__)
					
					ComposeNodes_VS_O(id__) = ComposeNodes_VS_O_aux(id__) [| union(TDeadlinesSync,{up__}) |] TDeadlines(id__)
					
					-- transition deadlines
					
					
					TDeadlines(id__) = MStop
					
					TDeadlinesSync = {||}
					
					Transitions_aux(id__) = ((up__ -> SKIP
					[] dbisim((true)&(internal__!TID_stm0_t0 -> SKIP ;  ((SKIP
					 ; s0::enter -> SKIP))))
					[] dbisim((true)&(internal__!TID_stm0_t1 -> SKIP ;  ((MStop /\ exited -> SKIP) ; get_ActualHV?ActualHV -> true&(ActualHV_1.out!ActualHV -> SKIP);get_ActualHV?ActualHV -> true&(ActualHV_2.out!ActualHV -> SKIP)
					 ; s0::enter -> SKIP)))
					)
					) ; Transitions_aux(id__)
					
					Transitions(id__) = dbisim((dbisim(Transitions_aux(id__))[[up__ <- up__, up__ <- timed_up__]]
										  [| union(TransitionSync,{|timed_up__|}) |] 
										  Transitons_Time_Sync)\{|timed_up__|})
					
					Transitons_Time_Sync = TimedInterrupt(RUN(union(TransitionSync,{tock})),1);
											timed_up__ -> Transitons_Time_Sync
					
					Behaviours(id__) = dbisim((
					 ((ComposeNodes(id__)[[s0::exit <- x__ | x__ <- {|exit,internal__.TID_stm0_t1|}]]
					 [[i0::exit <- x__ | x__ <- {|internal__.TID_stm0_t0|}]]
					 [[  
					 s0::exited <- exited
					 ]]
					 )
					  [[ up__ <- x__ | x__ <- {| up__ |} ]] 
					 )
					 [| union(union(union(enterCSet,TransitionSync),{| exited |}),{|up__
					|}) |]
					 ((i0::enter -> Transitions(id__))
					  [[ up__ <- x__ | x__ <- {| up__ |} ]]
					 )
					)
					\ union(enterCSet,{| exited, internal__ |})
					 [| {exit} |] STOP)
					
					Behaviours_VS_O(id__) = dbisim((
					 ((ComposeNodes_VS_O(id__)[[s0::exit <- x__ | x__ <- {|exit,internal__.TID_stm0_t1|}]]
					 [[i0::exit <- x__ | x__ <- {|internal__.TID_stm0_t0|}]]
					 [[  
					 s0::exited <- exited
					 ]]
					 )
					  [[ up__ <- x__ | x__ <- {| up__ |} ]] 
					 )
					 [| union(union(union(enterCSet,TransitionSync),{| exited |}),{|up__
					|}) |]
					 ((i0::enter -> Transitions(id__))
					  [[ up__ <- x__ | x__ <- {| up__ |} ]]
					 )
					)
					\ union(enterCSet,{| exited, internal__ |})
					 [| {exit} |] STOP)
					
					-- memory process
					Memory_ActualHV(x__) =
						get_ActualHV!x__ -> Memory_ActualHV(x__)
						[]
						set_ActualHV?x__ -> Memory_ActualHV(x__)
					
					Memory_CLID_s0(x__) =
						s0::entered -> Memory_CLID_s0(0)
						[]
						increment__ -> Memory_CLID_s0(Plus(x__,1,CLID_s0_clock_type))
						[]
						get_CLID_s0!x__ -> Memory_CLID_s0(x__)
						
					Clock_CLID_s0 = 
						(Memory_CLID_s0(0)
						 [| {| get_CLID_s0,s0::entered, increment__ |} |] 
						 Clock_Control_CLID_s0) \{| increment__ |}
						 
					Clock_Control_CLID_s0 = TimedInterrupt(RUN({|get_CLID_s0,s0::entered,tock|}),1); increment__ -> Clock_Control_CLID_s0 
					
					
					Memory(id__) =
						dbisim(Memory_ActualHV(0))
					
					Clocks = 
					dbisim(Clock_CLID_s0)
					
					SharedVariableMemory(id__) =
						STOP
					
					SharedVariablesSyncSet = {||}
					
					SharedVariableHidingSet = {||}
					
					MachineMemorySyncSet = 
						union({|get_ActualHV,set_ActualHV|}
						,
							  {|
							  get_CLID_s0,s0::entered
							  |}
							  )
					
					MachineMemoryHidingSet = 
						union({|get_ActualHV,set_ActualHV|}
						,
							  {|
							  get_CLID_s0
							  |}
							  )
					
					MachineInternalEvents = {|
						internal__
					|}
					
									
					-- main process
					
					STM(id__) = timed_priority(
						(
							(AUX(id__)[[ up__ <- x__ | x__ <- {||} ]]
						 	[| { up__ } |]
						 	SKIP)
						 /+ SharedVariablesSyncSet +\
						 SharedVariableMemory(id__))
						 \SharedVariableHidingSet
					)
					
					AUX(id__) = prioritise(
						(
							dbisim(
									(Behaviours(id__)
									 [|MachineMemorySyncSet|]
									 (Memory(id__) ||| Clocks)
									)[[
										int_ActualHV__.x____ <- int_ActualHV,
										ActualHV_1__.x____ <- ActualHV_1,
										ActualHV_2__.x____ <- ActualHV_2
										| x____ <- TIDS
									]]
									\MachineMemoryHidingSet
								)
						)
					[|{|terminate|}|>SKIP\MachineInternalEvents,<Union({internal_events, {|clockReset|}, {|terminate|}}),{tock}>)
					
					STM_VS_O(id__) = timed_priority(
						(
							(AUX_VS_O(id__)[[ up__ <- x__ | x__ <- {||} ]]
						 	[| { up__ } |]
						 	SKIP)
						 /+ SharedVariablesSyncSet +\
						 SharedVariableMemory(id__))
						 \SharedVariableHidingSet
					)
					
					AUX_VS_O(id__) = prioritise(
						(
							dbisim(
									(Behaviours_VS_O(id__)
									 [|MachineMemorySyncSet|]
									 (Memory(id__) ||| Clocks)
									)[[
										int_ActualHV__.x____ <- int_ActualHV,
										ActualHV_1__.x____ <- ActualHV_1,
										ActualHV_2__.x____ <- ActualHV_2
										| x____ <- TIDS
									]]
									\MachineMemoryHidingSet
								)
						)
					[|{|terminate|}|>SKIP\MachineInternalEvents,<Union({internal_events, {|clockReset|}, {|terminate|}}),{tock}>)
					
					-- definition of the behaviour of state machines (default, optimised, visible, visible and optimised)
			
					FVS__(id__) = STM_VS_O(id__) \ localClockResets
					
					D__(id__) = timed_priority(STM(id__) \ union(internal_events,localClockResets))
					O__(id__) = dbisim(D__(id__))
					VS__(id__) = FVS__(id__)
					VS_O__(id__) = dbisim(FVS__(id__))
					HEXT__(id__) = O__(id__) [|shared_variable_events|] SKIP
					FVS_C__(id__) = dbisim(timed_priority(STM(id__) \ internal_events))
					HUP__(id__) = timed_priority(O__(id__) [|{up__}|] SKIP)
				}
		endmodule
		
		Timed(OneStep) {
				-- undefined operations
				
				-- declaring controller memory
				Memory(id__) = SKIP
				
				D__(id__) = prioritise(	((
						stm0::D__(id__)[[
							stm0::terminate <- terminate,
							stm0::int_ActualHV <- int_ActualHV,
							stm0::ActualHV_1 <- ActualHV_1,
							stm0::ActualHV_2 <- ActualHV_2
						]]
					)
						[|
							union(
								{|
								|},
								{|
								|}
							)
						|]
					Memory(id__)
				)
				\ union(
					{|
					|},
					{|
					|}
				)
				[|{|terminate|}|>SKIP
				,<union(visibleMemoryEvents,{terminate}),{tock}>)
				
				-- VS version
				VS__(id__) = prioritise(	((
						stm0::VS__(id__)[[
							stm0::terminate <- terminate,
							stm0::int_ActualHV <- int_ActualHV,
							stm0::ActualHV_1 <- ActualHV_1,
							stm0::ActualHV_2 <- ActualHV_2
						]]
					)
						[|
							union(
								{|
								|},
								{|
								|}
							)
						|]
					Memory(id__)
				)
				\ union(
					{|
					|},
					{|
					|}
				)
				[|{|terminate|}|>SKIP
				,<union(visibleMemoryEvents,{terminate}),{tock}>)
			
				-- O version (optimised) THESE TWO PROCESSES SHOULD BE KEPT IN SYNC WITH THE ABOVE TWO
				O__(id__) = dbisim(prioritise(	((
						stm0::O__(id__)[[
							stm0::terminate <- terminate,
							stm0::int_ActualHV <- int_ActualHV,
							stm0::ActualHV_1 <- ActualHV_1,
							stm0::ActualHV_2 <- ActualHV_2
						]]
					)
						[|
							union(
								{|
								|},
								{|
								|}
							)
						|]
					Memory(id__)
				)
				\ union(
					{|
					|},
					{|
					|}
				)
				[|{|terminate|}|>SKIP
				,<union(visibleMemoryEvents,{terminate}),{tock}>))
								
				-- VS_O version
				VS_O__(id__) = dbisim(prioritise(	((
						stm0::VS_O__(id__)[[
							stm0::terminate <- terminate,
							stm0::int_ActualHV <- int_ActualHV,
							stm0::ActualHV_1 <- ActualHV_1,
							stm0::ActualHV_2 <- ActualHV_2
						]]
					)
						[|
							union(
								{|
								|},
								{|
								|}
							)
						|]
					Memory(id__)
				)
				\ union(
					{|
					|},
					{|
					|}
				)
				[|{|terminate|}|>SKIP
				,<union(visibleMemoryEvents,{terminate}),{tock}>))
			
				HEXT(id__) = O__(id__) [|shared_variable_events|] SKIP			
		}

	endmodule
