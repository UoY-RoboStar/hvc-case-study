	module ctrl1
		shared_variable_events = {|
		|}
		
	exports
		transparent diamond
		transparent sbisim
		transparent dbisim
		transparent chase

		-- declaring controller events
		channel ext_pow24VStatus: InOut.Power
		channel int_overLimit: InOut.core_real
		channel int_underLimit: InOut.core_real
		channel int_DisableHV: InOut
		channel int_ActualHV: InOut.core_real
		
		
		
		-- declaring call and ret events for undefined operations
		
		-- declaring controller termination channel		
		channel terminate

		-- defined operations
	
		-- declaring machines
		module stm_ref0
		exports
			transparent diamond
			transparent sbisim
			transparent dbisim
			transparent chase
		
			-- flow channels
			channel internal__ : TIDS
			
			-- The following are now declared per state (using modules)
			--channel enter, entered: NIDS
			channel exit
			channel exited
			channel terminate
			
			-- variable channels
			channel get_overLimit, set_overLimit, setL_overLimit, setR_overLimit: core_real
			channel get_underLimit, set_underLimit, setL_underLimit, setR_underLimit: core_real
			channel get_ActualHV, set_ActualHV, setL_ActualHV, setR_ActualHV: core_real
			channel get_power, set_power, setL_power, setR_power: Power
			
			-- shared variable channels
			
			-- local variable channels for defined operations that are required by the state machine
			
			-- declaring state machine events
			channel int_overLimit__: TIDS.InOut.core_real
			channel int_overLimit: InOut.core_real
			channel int_underLimit__: TIDS.InOut.core_real
			channel int_underLimit: InOut.core_real
			channel int_DisableHV__: TIDS.InOut
			channel int_DisableHV: InOut
			channel int_ActualHV__: TIDS.InOut.core_real
			channel int_ActualHV: InOut.core_real
			channel ext_pow24VStatus__: TIDS.InOut.Power
			channel ext_pow24VStatus: InOut.Power
			
			-- declaring call and ret events for undefined operations
			
			enterCSet = {|
			i0::enter,
			s0::enter
			|}
			
			enteredCSet = 	{|
			s0::entered
			|}
			
			internal_events = union(enteredCSet,union(enterCSet,{|exit,exited|}))
			
			shared_variable_events = {|
			|}
		
			-- Only the undefined operations are declared here.
			-- If the state machine is in isolation, all required operations will be undefined.
			-- If it is in the context of a controller, the required operations not provided by the
			-- controller will be declared here, and the defined operations will be defined in the
			-- context of the Controller module, and therefore within scope of the state machien module.
			
			
			-- declaring identifiers of transitions
			datatype TIDS = NULLTRANSITION__
			              | TID_Watchdog_t0
			              | TID_Watchdog_t1
			
			-- declaring all nodes
			
			----------------------------------------------------------------------
			-- Initial: i0
			module i0
			exports
			
				channel enter, exit
				
				D__(id__) = dbisim(let
							Inactive = (MStop /\ enter -> SKIP) ; (MStop /\ exit -> Inactive)
						within
							Inactive)
							
				VS_O__(id__) = D__(id__)
			
			endmodule
			----------------------------------------------------------------------
			
			
			----------------------------------------------------------------------
			-- State: s0
			module s0
			
			enterCSet = 
					{|			i0::enter,
						f0::enter,
						Waiting::enter,
						PowerStatusRead::enter,
						ActualHVRead::enter,
						PowerAndActualHVRead::enter
					|}
			enteredCSet = 
					{|			f0::entered,
						Waiting::entered,
						PowerStatusRead::entered,
						ActualHVRead::entered,
						PowerAndActualHVRead::entered
					|}
			exports
			
				--  Declarations
				-- declaring identifiers of transitions
				datatype TIDS = NULLTRANSITION__
				              | TID_Watchdog_s0_t0
				              | TID_Watchdog_s0_t1
				              | TID_Watchdog_s0_t3
				              | TID_Watchdog_s0_t2
				              | TID_Watchdog_s0_t4
				              | TID_Watchdog_s0_t5
				              | TID_Watchdog_s0_t6
				              | TID_Watchdog_s0_t7
				              | TID_Watchdog_s0_t8
				              | TID_Watchdog_s0_t9
				              | TID_Watchdog_s0_t10
				
				channel internal__ : TIDS
				channel enter, entered, exit, exited
				channel enteredL, enteredR
				channel end__
				
								
				channel int_overLimit__: TIDS.InOut.core_real
				channel int_underLimit__: TIDS.InOut.core_real
				channel int_DisableHV__: TIDS.InOut
				channel int_ActualHV__: TIDS.InOut.core_real
				channel ext_pow24VStatus__: TIDS.InOut.Power
				
				--	Nodes
				-- declaring all nodes
				
				----------------------------------------------------------------------
				-- Initial: i0
				module i0
				exports
				
					channel enter, exit
					
					D__(id__) = dbisim(let
								Inactive = (MStop /\ enter -> SKIP) ; (MStop /\ exit -> Inactive)
							within
								Inactive)
								
					VS_O__(id__) = D__(id__)
				
				endmodule
				----------------------------------------------------------------------
				
				
				----------------------------------------------------------------------
				-- Final state: f0
				module f0
				
				exports
				
					channel enter, entered, exit, exited
					channel enteredL, enteredR
					
					--	Rule: behaviours(Node)
					D__(id__) = 
					dbisim(let
						Inactive = (MStop /\ enter -> SKIP) ; Behaviour ; exited -> Inactive
						Behaviour = entered -> (MStop /\ exit -> SKIP)
					within
						Inactive)
						
					VS_O__(id__) = D__(id__)
				
				endmodule
				----------------------------------------------------------------------
				
				
				----------------------------------------------------------------------
				-- State: Waiting
				module Waiting
				
				enterCSet = {}
				
				enteredCSet = {}
				
				exports
				
					--  Declarations
					-- declaring identifiers of transitions
					datatype TIDS = NULLTRANSITION__
					
					channel internal__ : TIDS
					channel enter, entered, exit, exited
					channel enteredL, enteredR
					channel end__
					
									
					
					--	Nodes
					-- declaring all nodes
					
					TransitionSync = {||}
					
					--	Rule: behaviours(Node)
					--  Note that FDR has problems with efficiently compiling the process below
					-- 	if using a different recursion pattern.
					D__(id__) = 
					dbisim(let
						Inactive = (MStop /\ enter -> SKIP) ; SKIP ; 
									Behaviour ; 
									SKIP ; 
									exited -> SKIP ; Inactive
					
						Behaviour = entered -> ((SKIP ; MStop) /\ exit -> SKIP)
					within
						Inactive)
						
					VS_O__(id__) = 
						dbisim(let
							Inactive = (MStop /\ enter -> SKIP) ; SKIP ; 
										Behaviour ; 
										SKIP ; 
										exited -> SKIP ; Inactive
					
							Behaviour = entered -> ((SKIP ; MStop) /\ exit -> SKIP)
						within
							Inactive)
					
				
				endmodule
				----------------------------------------------------------------------
				
				
				----------------------------------------------------------------------
				-- State: PowerStatusRead
				module PowerStatusRead
				
				enterCSet = {}
				
				enteredCSet = {}
				
				exports
				
					--  Declarations
					-- declaring identifiers of transitions
					datatype TIDS = NULLTRANSITION__
					
					channel internal__ : TIDS
					channel enter, entered, exit, exited
					channel enteredL, enteredR
					channel end__
					
									
					
					--	Nodes
					-- declaring all nodes
					
					TransitionSync = {||}
					
					--	Rule: behaviours(Node)
					--  Note that FDR has problems with efficiently compiling the process below
					-- 	if using a different recursion pattern.
					D__(id__) = 
					dbisim(let
						Inactive = (MStop /\ enter -> SKIP) ; SKIP ; 
									Behaviour ; 
									SKIP ; 
									exited -> SKIP ; Inactive
					
						Behaviour = entered -> ((SKIP ; MStop) /\ exit -> SKIP)
					within
						Inactive)
						
					VS_O__(id__) = 
						dbisim(let
							Inactive = (MStop /\ enter -> SKIP) ; SKIP ; 
										Behaviour ; 
										SKIP ; 
										exited -> SKIP ; Inactive
					
							Behaviour = entered -> ((SKIP ; MStop) /\ exit -> SKIP)
						within
							Inactive)
					
				
				endmodule
				----------------------------------------------------------------------
				
				
				----------------------------------------------------------------------
				-- State: ActualHVRead
				module ActualHVRead
				
				enterCSet = {}
				
				enteredCSet = {}
				
				exports
				
					--  Declarations
					-- declaring identifiers of transitions
					datatype TIDS = NULLTRANSITION__
					
					channel internal__ : TIDS
					channel enter, entered, exit, exited
					channel enteredL, enteredR
					channel end__
					
									
					
					--	Nodes
					-- declaring all nodes
					
					TransitionSync = {||}
					
					--	Rule: behaviours(Node)
					--  Note that FDR has problems with efficiently compiling the process below
					-- 	if using a different recursion pattern.
					D__(id__) = 
					dbisim(let
						Inactive = (MStop /\ enter -> SKIP) ; SKIP ; 
									Behaviour ; 
									SKIP ; 
									exited -> SKIP ; Inactive
					
						Behaviour = entered -> ((SKIP ; MStop) /\ exit -> SKIP)
					within
						Inactive)
						
					VS_O__(id__) = 
						dbisim(let
							Inactive = (MStop /\ enter -> SKIP) ; SKIP ; 
										Behaviour ; 
										SKIP ; 
										exited -> SKIP ; Inactive
					
							Behaviour = entered -> ((SKIP ; MStop) /\ exit -> SKIP)
						within
							Inactive)
					
				
				endmodule
				----------------------------------------------------------------------
				
				
				----------------------------------------------------------------------
				-- State: PowerAndActualHVRead
				module PowerAndActualHVRead
				
				enterCSet = {}
				
				enteredCSet = {}
				
				exports
				
					--  Declarations
					-- declaring identifiers of transitions
					datatype TIDS = NULLTRANSITION__
					
					channel internal__ : TIDS
					channel enter, entered, exit, exited
					channel enteredL, enteredR
					channel end__
					
									
					
					--	Nodes
					-- declaring all nodes
					
					TransitionSync = {||}
					
					--	Rule: behaviours(Node)
					--  Note that FDR has problems with efficiently compiling the process below
					-- 	if using a different recursion pattern.
					D__(id__) = 
					dbisim(let
						Inactive = (MStop /\ enter -> SKIP) ; SKIP ; 
									Behaviour ; 
									SKIP ; 
									exited -> SKIP ; Inactive
					
						Behaviour = entered -> ((SKIP ; MStop) /\ exit -> SKIP)
					within
						Inactive)
						
					VS_O__(id__) = 
						dbisim(let
							Inactive = (MStop /\ enter -> SKIP) ; SKIP ; 
										Behaviour ; 
										SKIP ; 
										exited -> SKIP ; Inactive
					
							Behaviour = entered -> ((SKIP ; MStop) /\ exit -> SKIP)
						within
							Inactive)
					
				
				endmodule
				----------------------------------------------------------------------
				
				
				TransitionSync = {|internal__.TID_Watchdog_s0_t0,
				internal__.TID_Watchdog_s0_t1,
				internal__.TID_Watchdog_s0_t3,
				internal__.TID_Watchdog_s0_t2,
				ext_pow24VStatus__.TID_Watchdog_s0_t4,
				int_ActualHV__.TID_Watchdog_s0_t5,
				int_ActualHV__.TID_Watchdog_s0_t6,
				ext_pow24VStatus__.TID_Watchdog_s0_t7,
				internal__.TID_Watchdog_s0_t8,
				internal__.TID_Watchdog_s0_t9,
				internal__.TID_Watchdog_s0_t10|}
				
				--	Rule: behaviours(Node)
				--  Note that FDR has problems with efficiently compiling the process below
				-- 	if using a different recursion pattern.
				D__(id__) = 
				dbisim(let
					Inactive = (MStop /\ enter -> SKIP) ; SKIP ; 
								Behaviour ; 
								SKIP ; 
								exited -> SKIP ; Inactive
				
				
					Behaviour = (
									(
										((
										 ((Body)
										  [[ up__ <- x__ | x__ <- {| up__,setR_underLimit,setR_power,setR_overLimit,setR_ActualHV |} ]] 
										  [[set_underLimit <- setL_underLimit,set_power <- setL_power,set_overLimit <- setL_overLimit,set_ActualHV <- setL_ActualHV]]
										 )
										 [| union(union(enteredCSet,{| exit, exited |}),{|up__
										 			,setL_underLimit,setR_underLimit
										 			 			,setL_power,setR_power
										 			 			,setL_overLimit,setR_overLimit
										 			 			,setL_ActualHV,setR_ActualHV
										 			|}) |]
										 ((During)
										  [[ up__ <- x__ | x__ <- {| up__,setL_underLimit,setL_power,setL_overLimit,setL_ActualHV |} ]]
										  [[set_underLimit <- setR_underLimit,set_power <- setR_power,set_overLimit <- setR_overLimit,set_ActualHV <- setR_ActualHV]]
										 )
										)[[setL_underLimit <- set_underLimit,setR_underLimit <- set_underLimit,setL_power <- set_power,setR_power <- set_power,setL_overLimit <- set_overLimit,setR_overLimit <- set_overLimit,setL_ActualHV <- set_ActualHV,setR_ActualHV <- set_ActualHV]]
										)\enteredCSet 
									[| {end__} |> SKIP
									) \ {end__}
								)
				
					Body = dbisim(((
					 (((ComposeNodes(id__)[[f0::exit <- x__ | x__ <- {|exit|}]]
					 [[Waiting::exit <- x__ | x__ <- {|exit,ext_pow24VStatus__.TID_Watchdog_s0_t4.in,int_ActualHV__.TID_Watchdog_s0_t5.in|}]]
					 [[PowerStatusRead::exit <- x__ | x__ <- {|exit,internal__.TID_Watchdog_s0_t2,int_ActualHV__.TID_Watchdog_s0_t6.in|}]]
					 [[ActualHVRead::exit <- x__ | x__ <- {|exit,internal__.TID_Watchdog_s0_t1,internal__.TID_Watchdog_s0_t3,ext_pow24VStatus__.TID_Watchdog_s0_t7.in|}]]
					 [[PowerAndActualHVRead::exit <- x__ | x__ <- {|exit,internal__.TID_Watchdog_s0_t8,internal__.TID_Watchdog_s0_t9,internal__.TID_Watchdog_s0_t10|}]]
					 [[i0::exit <- x__ | x__ <- {|internal__.TID_Watchdog_s0_t0|}]]
					 [[  
					 f0::exited <- exited,
					 Waiting::exited <- exited,
					 PowerStatusRead::exited <- exited,
					 ActualHVRead::exited <- exited,
					 PowerAndActualHVRead::exited <- exited
					 ]]
					 ))
					  [[ up__ <- x__ | x__ <- {| up__ |} ]] 
					  [[set_underLimit <- setL_underLimit,set_power <- setL_power,set_overLimit <- setL_overLimit,set_ActualHV <- setL_ActualHV]]
					 )
					 [| union(union(union(enterCSet,TransitionSync),{| exit, exited |}),{|up__
					 			,setL_underLimit
					 			,setL_power
					 			,setL_overLimit
					 			,setL_ActualHV
					|}) |]
					 ((i0::enter -> 
					 	((dbisim(Transitions(id__)) /\ exit -> SKIP) ; (MStop /\ exited -> end__ -> SKIP)))
					  [[ up__ <- x__ | x__ <- {| up__,setL_underLimit,setL_power,setL_overLimit,setL_ActualHV |} ]]
					 )
					)[[setL_underLimit <- set_underLimit,setL_power <- set_power,setL_overLimit <- set_overLimit,setL_ActualHV <- set_ActualHV]]
					\ union(enterCSet,{| exited, internal__ |}))
					[[
						int_overLimit__.x____ <- int_overLimit,
						int_underLimit__.x____ <- int_underLimit,
						int_DisableHV__.x____ <- int_DisableHV,
						int_ActualHV__.x____ <- int_ActualHV,
						ext_pow24VStatus__.x____ <- ext_pow24VStatus
						| x____ <- TIDS
					]]
					)
				
					During = (MStop /\ ([] e : enteredCSet @ e -> SKIP))
							 ; entered -> ((CRUN(enteredCSet) ||| SKIP ; MStop) /\ exit -> SKIP)
				within
					Inactive)
					
				VS_O__(id__) = 
					dbisim(let
						Inactive = (MStop /\ enter -> SKIP) ; SKIP ; 
									Behaviour ; 
									SKIP ; 
									exited -> SKIP ; Inactive
				
				
					Behaviour = (
									(
										((
										 ((Body)
										  [[ up__ <- x__ | x__ <- {| up__,setR_underLimit,setR_power,setR_overLimit,setR_ActualHV |} ]] 
										  [[set_underLimit <- setL_underLimit,set_power <- setL_power,set_overLimit <- setL_overLimit,set_ActualHV <- setL_ActualHV]]
										 )
										 [| union(union(enteredCSet,{| exit, exited |}),{|up__
										 			,setL_underLimit,setR_underLimit
										 			 			,setL_power,setR_power
										 			 			,setL_overLimit,setR_overLimit
										 			 			,setL_ActualHV,setR_ActualHV
										 			|}) |]
										 ((During)
										  [[ up__ <- x__ | x__ <- {| up__,setL_underLimit,setL_power,setL_overLimit,setL_ActualHV |} ]]
										  [[set_underLimit <- setR_underLimit,set_power <- setR_power,set_overLimit <- setR_overLimit,set_ActualHV <- setR_ActualHV]]
										 )
										)[[setL_underLimit <- set_underLimit,setR_underLimit <- set_underLimit,setL_power <- set_power,setR_power <- set_power,setL_overLimit <- set_overLimit,setR_overLimit <- set_overLimit,setL_ActualHV <- set_ActualHV,setR_ActualHV <- set_ActualHV]]
										) 
									[| {end__} |> SKIP
									) \ {end__}
								)
				
					Body = dbisim(((
					 (((ComposeNodes_VS_O(id__)[[f0::exit <- x__ | x__ <- {|exit|}]]
					 [[Waiting::exit <- x__ | x__ <- {|exit,ext_pow24VStatus__.TID_Watchdog_s0_t4.in,int_ActualHV__.TID_Watchdog_s0_t5.in|}]]
					 [[PowerStatusRead::exit <- x__ | x__ <- {|exit,internal__.TID_Watchdog_s0_t2,int_ActualHV__.TID_Watchdog_s0_t6.in|}]]
					 [[ActualHVRead::exit <- x__ | x__ <- {|exit,internal__.TID_Watchdog_s0_t1,internal__.TID_Watchdog_s0_t3,ext_pow24VStatus__.TID_Watchdog_s0_t7.in|}]]
					 [[PowerAndActualHVRead::exit <- x__ | x__ <- {|exit,internal__.TID_Watchdog_s0_t8,internal__.TID_Watchdog_s0_t9,internal__.TID_Watchdog_s0_t10|}]]
					 [[i0::exit <- x__ | x__ <- {|internal__.TID_Watchdog_s0_t0|}]]
					 [[  
					 f0::exited <- exited,
					 Waiting::exited <- exited,
					 PowerStatusRead::exited <- exited,
					 ActualHVRead::exited <- exited,
					 PowerAndActualHVRead::exited <- exited
					 ]]
					 ))
					  [[ up__ <- x__ | x__ <- {| up__ |} ]] 
					  [[set_underLimit <- setL_underLimit,set_power <- setL_power,set_overLimit <- setL_overLimit,set_ActualHV <- setL_ActualHV]]
					 )
					 [| union(union(union(enterCSet,TransitionSync),{| exit, exited |}),{|up__
					 			,setL_underLimit
					 			,setL_power
					 			,setL_overLimit
					 			,setL_ActualHV
					|}) |]
					 ((i0::enter -> 
					 	((dbisim(Transitions(id__)) /\ exit -> SKIP) ; (MStop /\ exited -> end__ -> SKIP)))
					  [[ up__ <- x__ | x__ <- {| up__,setL_underLimit,setL_power,setL_overLimit,setL_ActualHV |} ]]
					 )
					)[[setL_underLimit <- set_underLimit,setL_power <- set_power,setL_overLimit <- set_overLimit,setL_ActualHV <- set_ActualHV]]
					\ union(enterCSet,{| exited, internal__ |}))
					[[
						int_overLimit__.x____ <- int_overLimit,
						int_underLimit__.x____ <- int_underLimit,
						int_DisableHV__.x____ <- int_DisableHV,
						int_ActualHV__.x____ <- int_ActualHV,
						ext_pow24VStatus__.x____ <- ext_pow24VStatus
						| x____ <- TIDS
					]]
					)
				
					During = (MStop /\ ([] e : enteredCSet @ e -> SKIP))
							 ; entered -> ((CRUN(enteredCSet) ||| SKIP ; MStop) /\ exit -> SKIP)
					within
						Inactive)
				
				Transitions(id__) = get_underLimit?underLimit -> get_power?power -> get_overLimit?overLimit -> get_ActualHV?ActualHV -> (up__ -> SKIP
				[] dbisim((true)&(internal__!TID_Watchdog_s0_t0 -> SKIP ;  ((SKIP
				 ; Waiting::enter -> SKIP))))
				[] dbisim(((ActualHV>overLimit))&(internal__!TID_Watchdog_s0_t1 -> SKIP ;  ((MStop /\ exited -> SKIP) ; true&(int_DisableHV.out -> SKIP)
				 ; f0::enter -> SKIP)))
				[] dbisim(((ActualHV<underLimit))&(internal__!TID_Watchdog_s0_t3 -> SKIP ;  ((MStop /\ exited -> SKIP) ; true&(int_DisableHV.out -> SKIP)
				 ; f0::enter -> SKIP)))
				[] dbisim(((power==Power_Off))&(internal__!TID_Watchdog_s0_t2 -> SKIP ;  ((MStop /\ exited -> SKIP) ; true&(int_DisableHV.out -> SKIP)
				 ; f0::enter -> SKIP)))
				[] dbisim((true)&(ext_pow24VStatus__!TID_Watchdog_s0_t4.in?power:{power|power <- Power, true} -> set_power!power -> SKIP ;  ((MStop /\ exited -> SKIP) ; SKIP
				 ; PowerStatusRead::enter -> SKIP)))
				[] dbisim((true)&(int_ActualHV__!TID_Watchdog_s0_t5.in?ActualHV:{ActualHV|ActualHV <- core_real, true} -> set_ActualHV!ActualHV -> SKIP ;  ((MStop /\ exited -> SKIP) ; SKIP
				 ; ActualHVRead::enter -> SKIP)))
				[] dbisim((true)&(int_ActualHV__!TID_Watchdog_s0_t6.in?ActualHV:{ActualHV|ActualHV <- core_real, true} -> set_ActualHV!ActualHV -> SKIP ;  ((MStop /\ exited -> SKIP) ; SKIP
				 ; PowerAndActualHVRead::enter -> SKIP)))
				[] dbisim((true)&(ext_pow24VStatus__!TID_Watchdog_s0_t7.in?power:{power|power <- Power, true} -> set_power!power -> SKIP ;  ((MStop /\ exited -> SKIP) ; SKIP
				 ; PowerAndActualHVRead::enter -> SKIP)))
				[] dbisim(((ActualHV<underLimit))&(internal__!TID_Watchdog_s0_t8 -> SKIP ;  ((MStop /\ exited -> SKIP) ; true&(int_DisableHV.out -> SKIP)
				 ; f0::enter -> SKIP)))
				[] dbisim(((ActualHV>overLimit))&(internal__!TID_Watchdog_s0_t9 -> SKIP ;  ((MStop /\ exited -> SKIP) ; true&(int_DisableHV.out -> SKIP)
				 ; f0::enter -> SKIP)))
				[] dbisim(((power==Power_Off))&(internal__!TID_Watchdog_s0_t10 -> SKIP ;  ((MStop /\ exited -> SKIP) ; true&(int_DisableHV.out -> SKIP)
				 ; f0::enter -> SKIP)))
				)
				 ; Transitions(id__)
				
				ComposeNodes(id__) = [| { up__ } |] proc__ : {i0::D__(id__),f0::D__(id__),Waiting::D__(id__),PowerStatusRead::D__(id__),ActualHVRead::D__(id__),PowerAndActualHVRead::D__(id__)} @ proc__
				
				ComposeNodes_VS_O(id__) = [| { up__ } |] proc__ : {i0::VS_O__(id__),f0::VS_O__(id__),Waiting::VS_O__(id__),PowerStatusRead::VS_O__(id__),ActualHVRead::VS_O__(id__),PowerAndActualHVRead::VS_O__(id__)} @ proc__
			
			endmodule
			----------------------------------------------------------------------
			
			
			TransitionSync = {|internal__.TID_Watchdog_t0,
			internal__.TID_Watchdog_t1|}
			
			-- The following is obviously not efficient for FDR to compile.
			-- For efficiency reasons a stepwise composition should be implemented instead.
			ComposeNodes(id__) = [| { up__ } |] proc__ : {i0::D__(id__),s0::D__(id__)} @ proc__
			
			ComposeNodes_VS_O(id__) = [| { up__ } |] proc__ : {i0::VS_O__(id__),s0::VS_O__(id__)} @ proc__
			
			Transitions(id__) = ((up__ -> SKIP
			[] dbisim((true)&(internal__!TID_Watchdog_t0 -> SKIP ;  ((true&(int_overLimit.in?overLimit -> set_overLimit!overLimit -> SKIP);true&(int_underLimit.in?underLimit -> set_underLimit!underLimit -> SKIP)
			 ; s0::enter -> SKIP))))
			[] dbisim((true)&(internal__!TID_Watchdog_t1 -> SKIP ;  ((MStop /\ exited -> SKIP) ; SKIP
			 ; s0::enter -> SKIP)))
			)
			) ; Transitions(id__)
			
			Behaviours(id__) = ((
			 ((ComposeNodes(id__)[[s0::exit <- x__ | x__ <- {|exit,internal__.TID_Watchdog_t1|}]]
			 [[i0::exit <- x__ | x__ <- {|internal__.TID_Watchdog_t0|}]]
			 [[  
			 s0::exited <- exited
			 ]]
			 )
			  [[ up__ <- x__ | x__ <- {| up__ |} ]] 
			 )
			 [| union(union(union(enterCSet,TransitionSync),{| exited |}),{|up__
			|}) |]
			 ((i0::enter -> Transitions(id__))
			  [[ up__ <- x__ | x__ <- {| up__ |} ]]
			 )
			)
			\ union(enterCSet,{| exited, internal__ |})
			 [| {exit} |] STOP)
			
			Behaviours_VS_O(id__) = ((
			 ((ComposeNodes_VS_O(id__)[[s0::exit <- x__ | x__ <- {|exit,internal__.TID_Watchdog_t1|}]]
			 [[i0::exit <- x__ | x__ <- {|internal__.TID_Watchdog_t0|}]]
			 [[  
			 s0::exited <- exited
			 ]]
			 )
			  [[ up__ <- x__ | x__ <- {| up__ |} ]] 
			 )
			 [| union(union(union(enterCSet,TransitionSync),{| exited |}),{|up__
			|}) |]
			 ((i0::enter -> Transitions(id__))
			  [[ up__ <- x__ | x__ <- {| up__ |} ]]
			 )
			)
			\ union(enterCSet,{| exited, internal__ |})
			 [| {exit} |] STOP)
			
			
			-- memory process
			Memory_overLimit(overLimit) =
				get_overLimit!overLimit -> Memory_overLimit(overLimit)
				[]
				set_overLimit?x__ -> Memory_overLimit(x__)
			Memory_underLimit(underLimit) =
				get_underLimit!underLimit -> Memory_underLimit(underLimit)
				[]
				set_underLimit?x__ -> Memory_underLimit(x__)
			Memory_ActualHV(ActualHV) =
				get_ActualHV!ActualHV -> Memory_ActualHV(ActualHV)
				[]
				set_ActualHV?x__ -> Memory_ActualHV(x__)
			Memory_power(power) =
				get_power!power -> Memory_power(power)
				[]
				set_power?x__ -> Memory_power(x__)
			
			Memory(id__) =
				Memory_overLimit(0)
				|||
				Memory_underLimit(0)
				|||
				Memory_ActualHV(0)
				|||
				Memory_power(Power_On)
			
			SharedVariableMemory(id__) =
				STOP
			
			SharedVariablesSyncSet = {||}
			
			SharedVariableHidingSet = {||}
			
			MachineMemorySyncSet = 
				{|get_overLimit,set_overLimit,
				get_underLimit,set_underLimit,
				get_ActualHV,set_ActualHV,
				get_power,set_power|}
				
			MachineMemoryHidingSet = {|get_overLimit,set_overLimit,
			get_underLimit,set_underLimit,
			get_ActualHV,set_ActualHV,
			get_power,set_power|}
			
			MachineInternalEvents = {|
				internal__
			|}
			
							
			-- main process
			
			STM(id__) = (
				(
					(AUX(id__)[[ up__ <- x__ | x__ <- {||} ]]
				 	[| { up__ } |]
				 	SKIP)
				 /+ SharedVariablesSyncSet +\
				 SharedVariableMemory(id__))
				 \SharedVariableHidingSet
			)
			
			AUX(id__) = (
				(
					(Behaviours(id__)
					 [|MachineMemorySyncSet|]
					 Memory(id__))
				)[[
					int_overLimit__.x____ <- int_overLimit,
					int_underLimit__.x____ <- int_underLimit,
					int_DisableHV__.x____ <- int_DisableHV,
					int_ActualHV__.x____ <- int_ActualHV,
					ext_pow24VStatus__.x____ <- ext_pow24VStatus
					| x____ <- TIDS
				]]
				\MachineMemoryHidingSet
			)
			[|{|terminate|}|>SKIP\MachineInternalEvents
			
			
			
			STM_VS_O(id__) = (
				(
					(AUX_VS_O(id__)[[ up__ <- x__ | x__ <- {||} ]]
				 	[| { up__ } |]
				 	SKIP)
				 /+ SharedVariablesSyncSet +\
				 SharedVariableMemory(id__))
				 \SharedVariableHidingSet
			)
			
			AUX_VS_O(id__) = (
				(
					(Behaviours_VS_O(id__)
					 [|MachineMemorySyncSet|]
					 Memory(id__))
				)[[
					int_overLimit__.x____ <- int_overLimit,
					int_underLimit__.x____ <- int_underLimit,
					int_DisableHV__.x____ <- int_DisableHV,
					int_ActualHV__.x____ <- int_ActualHV,
					ext_pow24VStatus__.x____ <- ext_pow24VStatus
					| x____ <- TIDS
				]]
				\MachineMemoryHidingSet
			)
			[|{|terminate|}|>SKIP\MachineInternalEvents
			
			
			
			-- definition of the behaviour of state machines (default, optimised, visible, visible and optimised)
			
			FVS__(id__) = STM_VS_O(id__)
			
			D__(id__) = STM(id__) \ internal_events
			O__(id__) = sbisim(diamond(D__(id__)))
			VS__(id__) = FVS__(id__)
			VS_O__(id__) = sbisim(diamond(FVS__(id__)))
			HEXT__(id__) = O__(id__) [|shared_variable_events|] SKIP
			HUP__(id__) = O__(id__) [|{up__}|] SKIP
		endmodule
		
			-- undefined operations
			
			-- declaring controller memory
			Memory(id__) = SKIP
			
			D__(id__) = 	((
					stm_ref0::D__(id__)[[
						stm_ref0::terminate <- terminate,
						stm_ref0::int_ActualHV <- int_ActualHV,
						stm_ref0::int_DisableHV <- int_DisableHV,
						stm_ref0::int_underLimit <- int_underLimit,
						stm_ref0::int_overLimit <- int_overLimit,
						stm_ref0::ext_pow24VStatus <- ext_pow24VStatus
					]]
				)
					[|
						union(
							{|
							|},
							{|
							|}
						)
					|]
				Memory(id__)
			)
			\ union(
				{|
				|},
				{|
				|}
			)
			[|{|terminate|}|>SKIP
			
			-- VS version
			VS__(id__) = 	((
					stm_ref0::VS__(id__)[[
						stm_ref0::terminate <- terminate,
						stm_ref0::int_ActualHV <- int_ActualHV,
						stm_ref0::int_DisableHV <- int_DisableHV,
						stm_ref0::int_underLimit <- int_underLimit,
						stm_ref0::int_overLimit <- int_overLimit,
						stm_ref0::ext_pow24VStatus <- ext_pow24VStatus
					]]
				)
					[|
						union(
							{|
							|},
							{|
							|}
						)
					|]
				Memory(id__)
			)
			\ union(
				{|
				|},
				{|
				|}
			)
			[|{|terminate|}|>SKIP
		
			-- O version (optimised) THESE TWO PROCESSES SHOULD BE KEPT IN SYNC WITH THE ABOVE TWO
			O__(id__) = sbisim(diamond(	((
					stm_ref0::O__(id__)[[
						stm_ref0::terminate <- terminate,
						stm_ref0::int_ActualHV <- int_ActualHV,
						stm_ref0::int_DisableHV <- int_DisableHV,
						stm_ref0::int_underLimit <- int_underLimit,
						stm_ref0::int_overLimit <- int_overLimit,
						stm_ref0::ext_pow24VStatus <- ext_pow24VStatus
					]]
				)
					[|
						union(
							{|
							|},
							{|
							|}
						)
					|]
				Memory(id__)
			)
			\ union(
				{|
				|},
				{|
				|}
			)
			[|{|terminate|}|>SKIP
			))
							
			-- VS_O version
			VS_O__(id__) = sbisim(diamond(	((
					stm_ref0::VS_O__(id__)[[
						stm_ref0::terminate <- terminate,
						stm_ref0::int_ActualHV <- int_ActualHV,
						stm_ref0::int_DisableHV <- int_DisableHV,
						stm_ref0::int_underLimit <- int_underLimit,
						stm_ref0::int_overLimit <- int_overLimit,
						stm_ref0::ext_pow24VStatus <- ext_pow24VStatus
					]]
				)
					[|
						union(
							{|
							|},
							{|
							|}
						)
					|]
				Memory(id__)
			)
			\ union(
				{|
				|},
				{|
				|}
			)
			[|{|terminate|}|>SKIP
			))
		
			HEXT(id__) = O__(id__) [|shared_variable_events|] SKIP			

	endmodule
