	module ctrl2
		shared_variable_events = {|
		|}
		
	exports
		transparent diamond
		transparent sbisim
		transparent dbisim
		transparent chase

		-- declaring controller events
		channel ext_pow24VStatus: InOut.Power
		channel ext_pow24_1: InOut.Power
		channel ext_pow24_2: InOut.Power
		
		
		
		-- declaring call and ret events for undefined operations
		
		-- declaring controller termination channel		
		channel terminate

		-- defined operations
	
		-- declaring machines
		module stm0
		exports
			transparent diamond
			transparent sbisim
			transparent dbisim
			transparent chase
		
			-- flow channels
			channel internal__ : TIDS
			
			-- The following are now declared per state (using modules)
			--channel enter, entered: NIDS
			channel exit
			channel exited
			channel terminate
			
			-- variable channels
			channel get_power, set_power, setL_power, setR_power: Power
			
			-- shared variable channels
			
			-- local variable channels for defined operations that are required by the state machine
			
			-- declaring state machine events
			channel ext_pow24VStatus__: TIDS.InOut.Power
			channel ext_pow24VStatus: InOut.Power
			channel ext_pow24_1__: TIDS.InOut.Power
			channel ext_pow24_1: InOut.Power
			channel ext_pow24_2__: TIDS.InOut.Power
			channel ext_pow24_2: InOut.Power
			
			-- declaring call and ret events for undefined operations
			
			enterCSet = {|
			i0::enter,
			s0::enter
			|}
			
			enteredCSet = 	{|
			s0::entered
			|}
			
			internal_events = union(enteredCSet,union(enterCSet,{|exit,exited|}))
			
			shared_variable_events = {|
			|}
		
			-- Only the undefined operations are declared here.
			-- If the state machine is in isolation, all required operations will be undefined.
			-- If it is in the context of a controller, the required operations not provided by the
			-- controller will be declared here, and the defined operations will be defined in the
			-- context of the Controller module, and therefore within scope of the state machien module.
			
			
			-- declaring identifiers of transitions
			datatype TIDS = NULLTRANSITION__
			              | TID_stm0_t0
			              | TID_stm0_t1
			
			-- declaring all nodes
			
			----------------------------------------------------------------------
			-- Initial: i0
			module i0
			exports
			
				channel enter, exit
				
				D__(id__) = dbisim(let
							Inactive = (MStop /\ enter -> SKIP) ; (MStop /\ exit -> Inactive)
						within
							Inactive)
							
				VS_O__(id__) = D__(id__)
			
			endmodule
			----------------------------------------------------------------------
			
			
			----------------------------------------------------------------------
			-- State: s0
			module s0
			
			enterCSet = {}
			
			enteredCSet = {}
			
			exports
			
				--  Declarations
				-- declaring identifiers of transitions
				datatype TIDS = NULLTRANSITION__
				
				channel internal__ : TIDS
				channel enter, entered, exit, exited
				channel enteredL, enteredR
				channel end__
				
								
				
				--	Nodes
				-- declaring all nodes
				
				TransitionSync = {||}
				
				--	Rule: behaviours(Node)
				--  Note that FDR has problems with efficiently compiling the process below
				-- 	if using a different recursion pattern.
				D__(id__) = 
				dbisim(let
					Inactive = (MStop /\ enter -> SKIP) ; true&(ext_pow24VStatus.in?power -> set_power!power -> SKIP)
					 ; 
								Behaviour ; 
								SKIP ; 
								exited -> SKIP ; Inactive
				
					Behaviour = entered -> ((SKIP ; MStop) /\ exit -> SKIP)
				within
					Inactive)
					
				VS_O__(id__) = 
					dbisim(let
						Inactive = (MStop /\ enter -> SKIP) ; true&(ext_pow24VStatus.in?power -> set_power!power -> SKIP)
						 ; 
									Behaviour ; 
									SKIP ; 
									exited -> SKIP ; Inactive
				
						Behaviour = entered -> ((SKIP ; MStop) /\ exit -> SKIP)
					within
						Inactive)
				
			
			endmodule
			----------------------------------------------------------------------
			
			
			TransitionSync = {|internal__.TID_stm0_t0,
			internal__.TID_stm0_t1|}
			
			-- The following is obviously not efficient for FDR to compile.
			-- For efficiency reasons a stepwise composition should be implemented instead.
			ComposeNodes(id__) = [| { up__ } |] proc__ : {i0::D__(id__),s0::D__(id__)} @ proc__
			
			ComposeNodes_VS_O(id__) = [| { up__ } |] proc__ : {i0::VS_O__(id__),s0::VS_O__(id__)} @ proc__
			
			Transitions(id__) = ((up__ -> SKIP
			[] dbisim((true)&(internal__!TID_stm0_t0 -> SKIP ;  ((SKIP
			 ; s0::enter -> SKIP))))
			[] dbisim((true)&(internal__!TID_stm0_t1 -> SKIP ;  ((MStop /\ exited -> SKIP) ; get_power?power -> true&(ext_pow24_1.out!power -> SKIP);get_power?power -> true&(ext_pow24_2.out!power -> SKIP)
			 ; s0::enter -> SKIP)))
			)
			) ; Transitions(id__)
			
			Behaviours(id__) = ((
			 ((ComposeNodes(id__)[[s0::exit <- x__ | x__ <- {|exit,internal__.TID_stm0_t1|}]]
			 [[i0::exit <- x__ | x__ <- {|internal__.TID_stm0_t0|}]]
			 [[  
			 s0::exited <- exited
			 ]]
			 )
			  [[ up__ <- x__ | x__ <- {| up__ |} ]] 
			 )
			 [| union(union(union(enterCSet,TransitionSync),{| exited |}),{|up__
			|}) |]
			 ((i0::enter -> Transitions(id__))
			  [[ up__ <- x__ | x__ <- {| up__ |} ]]
			 )
			)
			\ union(enterCSet,{| exited, internal__ |})
			 [| {exit} |] STOP)
			
			Behaviours_VS_O(id__) = ((
			 ((ComposeNodes_VS_O(id__)[[s0::exit <- x__ | x__ <- {|exit,internal__.TID_stm0_t1|}]]
			 [[i0::exit <- x__ | x__ <- {|internal__.TID_stm0_t0|}]]
			 [[  
			 s0::exited <- exited
			 ]]
			 )
			  [[ up__ <- x__ | x__ <- {| up__ |} ]] 
			 )
			 [| union(union(union(enterCSet,TransitionSync),{| exited |}),{|up__
			|}) |]
			 ((i0::enter -> Transitions(id__))
			  [[ up__ <- x__ | x__ <- {| up__ |} ]]
			 )
			)
			\ union(enterCSet,{| exited, internal__ |})
			 [| {exit} |] STOP)
			
			
			-- memory process
			Memory_power(power) =
				get_power!power -> Memory_power(power)
				[]
				set_power?x__ -> Memory_power(x__)
			
			Memory(id__) =
				Memory_power(Power_On)
			
			SharedVariableMemory(id__) =
				STOP
			
			SharedVariablesSyncSet = {||}
			
			SharedVariableHidingSet = {||}
			
			MachineMemorySyncSet = 
				{|get_power,set_power|}
				
			MachineMemoryHidingSet = {|get_power,set_power|}
			
			MachineInternalEvents = {|
				internal__
			|}
			
							
			-- main process
			
			STM(id__) = (
				(
					(AUX(id__)[[ up__ <- x__ | x__ <- {||} ]]
				 	[| { up__ } |]
				 	SKIP)
				 /+ SharedVariablesSyncSet +\
				 SharedVariableMemory(id__))
				 \SharedVariableHidingSet
			)
			
			AUX(id__) = (
				(
					(Behaviours(id__)
					 [|MachineMemorySyncSet|]
					 Memory(id__))
				)[[
					ext_pow24VStatus__.x____ <- ext_pow24VStatus,
					ext_pow24_1__.x____ <- ext_pow24_1,
					ext_pow24_2__.x____ <- ext_pow24_2
					| x____ <- TIDS
				]]
				\MachineMemoryHidingSet
			)
			[|{|terminate|}|>SKIP\MachineInternalEvents
			
			
			
			STM_VS_O(id__) = (
				(
					(AUX_VS_O(id__)[[ up__ <- x__ | x__ <- {||} ]]
				 	[| { up__ } |]
				 	SKIP)
				 /+ SharedVariablesSyncSet +\
				 SharedVariableMemory(id__))
				 \SharedVariableHidingSet
			)
			
			AUX_VS_O(id__) = (
				(
					(Behaviours_VS_O(id__)
					 [|MachineMemorySyncSet|]
					 Memory(id__))
				)[[
					ext_pow24VStatus__.x____ <- ext_pow24VStatus,
					ext_pow24_1__.x____ <- ext_pow24_1,
					ext_pow24_2__.x____ <- ext_pow24_2
					| x____ <- TIDS
				]]
				\MachineMemoryHidingSet
			)
			[|{|terminate|}|>SKIP\MachineInternalEvents
			
			
			
			-- definition of the behaviour of state machines (default, optimised, visible, visible and optimised)
			
			FVS__(id__) = STM_VS_O(id__)
			
			D__(id__) = STM(id__) \ internal_events
			O__(id__) = sbisim(diamond(D__(id__)))
			VS__(id__) = FVS__(id__)
			VS_O__(id__) = sbisim(diamond(FVS__(id__)))
			HEXT__(id__) = O__(id__) [|shared_variable_events|] SKIP
			HUP__(id__) = O__(id__) [|{up__}|] SKIP
		endmodule
		
			-- undefined operations
			
			-- declaring controller memory
			Memory(id__) = SKIP
			
			D__(id__) = 	((
					stm0::D__(id__)[[
						stm0::terminate <- terminate,
						stm0::ext_pow24VStatus <- ext_pow24VStatus,
						stm0::ext_pow24_1 <- ext_pow24_1,
						stm0::ext_pow24_2 <- ext_pow24_2
					]]
				)
					[|
						union(
							{|
							|},
							{|
							|}
						)
					|]
				Memory(id__)
			)
			\ union(
				{|
				|},
				{|
				|}
			)
			[|{|terminate|}|>SKIP
			
			-- VS version
			VS__(id__) = 	((
					stm0::VS__(id__)[[
						stm0::terminate <- terminate,
						stm0::ext_pow24VStatus <- ext_pow24VStatus,
						stm0::ext_pow24_1 <- ext_pow24_1,
						stm0::ext_pow24_2 <- ext_pow24_2
					]]
				)
					[|
						union(
							{|
							|},
							{|
							|}
						)
					|]
				Memory(id__)
			)
			\ union(
				{|
				|},
				{|
				|}
			)
			[|{|terminate|}|>SKIP
		
			-- O version (optimised) THESE TWO PROCESSES SHOULD BE KEPT IN SYNC WITH THE ABOVE TWO
			O__(id__) = sbisim(diamond(	((
					stm0::O__(id__)[[
						stm0::terminate <- terminate,
						stm0::ext_pow24VStatus <- ext_pow24VStatus,
						stm0::ext_pow24_1 <- ext_pow24_1,
						stm0::ext_pow24_2 <- ext_pow24_2
					]]
				)
					[|
						union(
							{|
							|},
							{|
							|}
						)
					|]
				Memory(id__)
			)
			\ union(
				{|
				|},
				{|
				|}
			)
			[|{|terminate|}|>SKIP
			))
							
			-- VS_O version
			VS_O__(id__) = sbisim(diamond(	((
					stm0::VS_O__(id__)[[
						stm0::terminate <- terminate,
						stm0::ext_pow24VStatus <- ext_pow24VStatus,
						stm0::ext_pow24_1 <- ext_pow24_1,
						stm0::ext_pow24_2 <- ext_pow24_2
					]]
				)
					[|
						union(
							{|
							|},
							{|
							|}
						)
					|]
				Memory(id__)
			)
			\ union(
				{|
				|},
				{|
				|}
			)
			[|{|terminate|}|>SKIP
			))
		
			HEXT(id__) = O__(id__) [|shared_variable_events|] SKIP			

	endmodule
