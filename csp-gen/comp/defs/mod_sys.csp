module mod_sys
	exports
	
	transparent diamond
	transparent sbisim
	transparent dbisim
	transparent chase
	
	-- declaring channels
	-- declaring robotic platform events
	channel int_ActualHV: InOut.core_real
	channel currentState: InOut.State
	channel int_pwmSignal: InOut.Power
	channel ext_setPoint: InOut.core_real
	channel ext_pow24VStatus: InOut.Power
	
	
	-- declaring module termination channel
	channel terminate
	
	-- declaring robotic platform variables
	
	-- declaring controller
		module ctrl_ref0
			shared_variable_events = {|
			|}
			
		exports
			transparent diamond
			transparent sbisim
			transparent dbisim
			transparent chase
	
			-- declaring controller events
			channel currentState: InOut.State
			channel ext_setPoint: InOut.core_real
			channel ext_pow24VStatus: InOut.Power
			channel int_overLimit: InOut.core_real
			channel int_pwmSignal: InOut.Power
			channel int_underLimit: InOut.core_real
			channel int_DisableHV: InOut
			channel int_ActualHV: InOut.core_real
			
			
			
			-- declaring call and ret events for undefined operations
			
			-- declaring controller termination channel		
			channel terminate
	
			-- defined operations
			-- compileOperationDef
			module OP_disableHV
			exports
				transparent diamond
				transparent sbisim
				transparent dbisim
				transparent chase
				
				-- flow channels
				channel internal__ : TIDS
				
				-- The following are now declared per state (using modules)
				--channel enter, entered: NIDS
				channel exit
				channel exited
				channel terminate
				
				-- variable channels
				channel get_setPoint, set_setPoint, setL_setPoint, setR_setPoint: core_real
				channel get_res, set_res, setL_res, setR_res: core_boolean
				channel get_errorFlag, set_errorFlag, setL_errorFlag, setR_errorFlag: core_boolean
				channel get_lim, set_lim, setL_lim, setR_lim: core_boolean
				channel get_supplyLim, set_supplyLim, setL_supplyLim, setR_supplyLim: core_boolean
				channel get_ActualHV, set_ActualHV, setL_ActualHV, setR_ActualHV: core_real
				channel get_errorAck, set_errorAck, setL_errorAck, setR_errorAck: core_boolean
				channel get_overLimit, set_overLimit, setL_overLimit, setR_overLimit: core_real
				channel get_underLimit, set_underLimit, setL_underLimit, setR_underLimit: core_real
				
				-- shared variable channels
				channel set_EXT_setPoint: core_real
				channel set_EXT_res: core_boolean
				channel set_EXT_errorFlag: core_boolean
				channel set_EXT_lim: core_boolean
				channel set_EXT_supplyLim: core_boolean
				channel set_EXT_ActualHV: core_real
				channel set_EXT_errorAck: core_boolean
				channel set_EXT_overLimit: core_real
				channel set_EXT_underLimit: core_real
				
				-- local variable channels for defined operations that are required by the state machine
				
				-- declaring state machine events
				channel int_pwmSignal__: TIDS.InOut.Power
				channel int_pwmSignal: InOut.Power
				
				-- declaring call and ret events for undefined operations
				
				enterCSet = {|
				i0::enter,
				s1::enter,
				f0::enter,
				s0::enter
				|}
				
				enteredCSet = 	{|
				s1::entered,
				f0::entered,
				s0::entered
				|}
				
				internal_events = union(enteredCSet,union(enterCSet,{|exit,exited|}))
				
				shared_variable_events = {|
					set_EXT_setPoint,
					set_EXT_res,
					set_EXT_errorFlag,
					set_EXT_lim,
					set_EXT_supplyLim,
					set_EXT_ActualHV,
					set_EXT_errorAck,
					set_EXT_overLimit,
					set_EXT_underLimit
				|}
				
				-- Only the undefined operations are declared here.
				-- If the state machine is in isolation, all required operations will be undefined.
				-- If it is in the context of a controller, the required operations not provided by the
				-- controller will be declared here, and the defined operations will be defined in the
				-- context of the Controller module, and therefore within scope of the state machien module.
				
				
				-- declaring identifiers of transitions
				datatype TIDS = NULLTRANSITION__
				              | TID_disableHV_t0
				              | TID_disableHV_t1
				              | TID_disableHV_t2
				              | TID_disableHV_t3
				
				-- declaring all nodes
				
				----------------------------------------------------------------------
				-- Initial: i0
				module i0
				exports
				
					channel enter, exit
					
					D__(id__,
								arg) = dbisim(let
								Inactive = (MStop /\ enter -> SKIP) ; (MStop /\ exit -> Inactive)
							within
								Inactive)
								
					VS_O__(id__,
								arg) = D__(id__,
								arg)
				
				endmodule
				----------------------------------------------------------------------
				
				
				----------------------------------------------------------------------
				-- State: s1
				module s1
				
				enterCSet = {}
				
				enteredCSet = {}
				
				exports
				
					--  Declarations
					-- declaring identifiers of transitions
					datatype TIDS = NULLTRANSITION__
					
					channel internal__ : TIDS
					channel enter, entered, exit, exited
					channel enteredL, enteredR
					channel end__
					
									
					
					--	Nodes
					-- declaring all nodes
					
					TransitionSync = {||}
					
					--	Rule: behaviours(Node)
					--  Note that FDR has problems with efficiently compiling the process below
					-- 	if using a different recursion pattern.
					D__(id__,
								arg) = 
					dbisim(let
						Inactive = (MStop /\ enter -> SKIP) ; true & (set_setPoint!0 -> SKIP)
						 ; 
									Behaviour ; 
									SKIP ; 
									exited -> SKIP ; Inactive
					
						Behaviour = entered -> ((SKIP ; MStop) /\ exit -> SKIP)
					within
						Inactive)
						
					VS_O__(id__,
								arg) = 
						dbisim(let
							Inactive = (MStop /\ enter -> SKIP) ; true & (set_setPoint!0 -> SKIP)
							 ; 
										Behaviour ; 
										SKIP ; 
										exited -> SKIP ; Inactive
					
							Behaviour = entered -> ((SKIP ; MStop) /\ exit -> SKIP)
						within
							Inactive)
					
				
				endmodule
				----------------------------------------------------------------------
				
				
				----------------------------------------------------------------------
				-- Final state: f0
				module f0
				
				exports
				
					channel enter, entered, exit, exited
					channel enteredL, enteredR
					
					--	Rule: behaviours(Node)
					D__(id__,
								arg) = 
					dbisim(let
						Inactive = (MStop /\ enter -> SKIP) ; Behaviour ; exited -> Inactive
						Behaviour = entered -> (MStop /\ exit -> SKIP)
					within
						Inactive)
						
					VS_O__(id__,
								arg) = D__(id__,
								arg)
				
				endmodule
				----------------------------------------------------------------------
				
				
				----------------------------------------------------------------------
				-- State: s0
				module s0
				
				enterCSet = {}
				
				enteredCSet = {}
				
				exports
				
					--  Declarations
					-- declaring identifiers of transitions
					datatype TIDS = NULLTRANSITION__
					
					channel internal__ : TIDS
					channel enter, entered, exit, exited
					channel enteredL, enteredR
					channel end__
					
									
					
					--	Nodes
					-- declaring all nodes
					
					TransitionSync = {||}
					
					--	Rule: behaviours(Node)
					--  Note that FDR has problems with efficiently compiling the process below
					-- 	if using a different recursion pattern.
					D__(id__,
								arg) = 
					dbisim(let
						Inactive = (MStop /\ enter -> SKIP) ; true&(int_pwmSignal.out!Power_Off -> SKIP)
						 ; 
									Behaviour ; 
									SKIP ; 
									exited -> SKIP ; Inactive
					
						Behaviour = entered -> ((SKIP ; MStop) /\ exit -> SKIP)
					within
						Inactive)
						
					VS_O__(id__,
								arg) = 
						dbisim(let
							Inactive = (MStop /\ enter -> SKIP) ; true&(int_pwmSignal.out!Power_Off -> SKIP)
							 ; 
										Behaviour ; 
										SKIP ; 
										exited -> SKIP ; Inactive
					
							Behaviour = entered -> ((SKIP ; MStop) /\ exit -> SKIP)
						within
							Inactive)
					
				
				endmodule
				----------------------------------------------------------------------
				
				
				TransitionSync = {|internal__.TID_disableHV_t0,
				internal__.TID_disableHV_t1,
				internal__.TID_disableHV_t2,
				internal__.TID_disableHV_t3|}
				
				-- The following is obviously not efficient for FDR to compile.
				-- For efficiency reasons a stepwise composition should be implemented instead.
				ComposeNodes(id__,
							arg) = [| { up__ } |] proc__ : {i0::D__(id__,
							arg),s1::D__(id__,
							arg),f0::D__(id__,
							arg),s0::D__(id__,
							arg)} @ proc__
				
				ComposeNodes_VS_O(id__,
							arg) = [| { up__ } |] proc__ : {i0::VS_O__(id__,
							arg),s1::VS_O__(id__,
							arg),f0::VS_O__(id__,
							arg),s0::VS_O__(id__,
							arg)} @ proc__
				
				Transitions(id__,
							arg) = ((up__ -> SKIP
				[] dbisim(((arg==false))&(internal__!TID_disableHV_t0 -> SKIP ;  ((MStop /\ exited -> SKIP) ; true & (set_res!false -> SKIP)
				 ; f0::enter -> SKIP)))
				[] dbisim(((arg==true))&(internal__!TID_disableHV_t1 -> SKIP ;  ((MStop /\ exited -> SKIP) ; true & (set_res!true -> SKIP)
				 ; f0::enter -> SKIP)))
				[] dbisim((true)&(internal__!TID_disableHV_t2 -> SKIP ;  ((SKIP
				 ; s0::enter -> SKIP))))
				[] dbisim((true)&(internal__!TID_disableHV_t3 -> SKIP ;  ((MStop /\ exited -> SKIP) ; SKIP
				 ; s1::enter -> SKIP)))
				)
				) ; Transitions(id__,
							arg)
				
				Behaviours(id__,
							arg) = ((
				 ((ComposeNodes(id__,
				 			arg)[[s1::exit <- x__ | x__ <- {|exit,internal__.TID_disableHV_t0,internal__.TID_disableHV_t1|}]]
				 [[f0::exit <- x__ | x__ <- {|exit,terminate|}]]
				 [[s0::exit <- x__ | x__ <- {|exit,internal__.TID_disableHV_t3|}]]
				 [[i0::exit <- x__ | x__ <- {|internal__.TID_disableHV_t2|}]]
				 [[  
				 s1::exited <- exited,
				 f0::exited <- exited,
				 s0::exited <- exited
				 ]]
				 )
				  [[ up__ <- x__ | x__ <- {| up__ |} ]] 
				 )
				 [| union(union(union(enterCSet,TransitionSync),{| exited |}),{|up__
				|}) |]
				 ((i0::enter -> Transitions(id__,
				 			arg))
				  [[ up__ <- x__ | x__ <- {| up__ |} ]]
				 )
				)
				\ union(enterCSet,{| exited, internal__ |})
				 [| {exit} |] STOP)
				
				Behaviours_VS_O(id__,
							arg) = ((
				 ((ComposeNodes_VS_O(id__,
				 			arg)[[s1::exit <- x__ | x__ <- {|exit,internal__.TID_disableHV_t0,internal__.TID_disableHV_t1|}]]
				 [[f0::exit <- x__ | x__ <- {|exit,terminate|}]]
				 [[s0::exit <- x__ | x__ <- {|exit,internal__.TID_disableHV_t3|}]]
				 [[i0::exit <- x__ | x__ <- {|internal__.TID_disableHV_t2|}]]
				 [[  
				 s1::exited <- exited,
				 f0::exited <- exited,
				 s0::exited <- exited
				 ]]
				 )
				  [[ up__ <- x__ | x__ <- {| up__ |} ]] 
				 )
				 [| union(union(union(enterCSet,TransitionSync),{| exited |}),{|up__
				|}) |]
				 ((i0::enter -> Transitions(id__,
				 			arg))
				  [[ up__ <- x__ | x__ <- {| up__ |} ]]
				 )
				)
				\ union(enterCSet,{| exited, internal__ |})
				 [| {exit} |] STOP)
				
				
				-- memory process
				
				Memory(id__,
							arg) =
					STOP
				Memory_setPoint(setPoint) =
					get_setPoint!setPoint -> Memory_setPoint(setPoint)
					[]
					set_setPoint?x__ -> Memory_setPoint(x__)
					[]
					set_EXT_setPoint?x__ -> Memory_setPoint(x__)
				Memory_res(res) =
					get_res!res -> Memory_res(res)
					[]
					set_res?x__ -> Memory_res(x__)
					[]
					set_EXT_res?x__ -> Memory_res(x__)
				Memory_errorFlag(errorFlag) =
					get_errorFlag!errorFlag -> Memory_errorFlag(errorFlag)
					[]
					set_errorFlag?x__ -> Memory_errorFlag(x__)
					[]
					set_EXT_errorFlag?x__ -> Memory_errorFlag(x__)
				Memory_lim(lim) =
					get_lim!lim -> Memory_lim(lim)
					[]
					set_lim?x__ -> Memory_lim(x__)
					[]
					set_EXT_lim?x__ -> Memory_lim(x__)
				Memory_supplyLim(supplyLim) =
					get_supplyLim!supplyLim -> Memory_supplyLim(supplyLim)
					[]
					set_supplyLim?x__ -> Memory_supplyLim(x__)
					[]
					set_EXT_supplyLim?x__ -> Memory_supplyLim(x__)
				Memory_ActualHV(ActualHV) =
					get_ActualHV!ActualHV -> Memory_ActualHV(ActualHV)
					[]
					set_ActualHV?x__ -> Memory_ActualHV(x__)
					[]
					set_EXT_ActualHV?x__ -> Memory_ActualHV(x__)
				Memory_errorAck(errorAck) =
					get_errorAck!errorAck -> Memory_errorAck(errorAck)
					[]
					set_errorAck?x__ -> Memory_errorAck(x__)
					[]
					set_EXT_errorAck?x__ -> Memory_errorAck(x__)
				Memory_overLimit(overLimit) =
					get_overLimit!overLimit -> Memory_overLimit(overLimit)
					[]
					set_overLimit?x__ -> Memory_overLimit(x__)
					[]
					set_EXT_overLimit?x__ -> Memory_overLimit(x__)
				Memory_underLimit(underLimit) =
					get_underLimit!underLimit -> Memory_underLimit(underLimit)
					[]
					set_underLimit?x__ -> Memory_underLimit(x__)
					[]
					set_EXT_underLimit?x__ -> Memory_underLimit(x__)
				
				SharedVariableMemory(id__,
							arg) =
					Memory_setPoint(0)
					|||
					Memory_res(false)
					|||
					Memory_errorFlag(true)
					|||
					Memory_lim(false)
					|||
					Memory_supplyLim(false)
					|||
					Memory_ActualHV(0)
					|||
					Memory_errorAck(false)
					|||
					Memory_overLimit(0)
					|||
					Memory_underLimit(0)
				
				SharedVariablesSyncSet = {|get_setPoint,set_setPoint,set_EXT_setPoint,get_res,set_res,set_EXT_res,get_errorFlag,set_errorFlag,set_EXT_errorFlag,get_lim,set_lim,set_EXT_lim,get_supplyLim,set_supplyLim,set_EXT_supplyLim,get_ActualHV,set_ActualHV,set_EXT_ActualHV,get_errorAck,set_errorAck,set_EXT_errorAck,get_overLimit,set_overLimit,set_EXT_overLimit,get_underLimit,set_underLimit,set_EXT_underLimit|}
				
				SharedVariableHidingSet = {|get_setPoint,get_res,get_errorFlag,get_lim,get_supplyLim,get_ActualHV,get_errorAck,get_overLimit,get_underLimit|}
				
				MachineMemorySyncSet = 
					{||}
					
				MachineMemoryHidingSet = {||}
				
				MachineInternalEvents = {|
					internal__
				|}
				
								
				-- main process
				
				STM(id__, arg) = (AUX(id__, arg))\{terminate} 
				
				AUX(id__, arg) = (
					(
						(Behaviours(id__,
									arg)
						 [|MachineMemorySyncSet|]
						 Memory(id__,
						 			arg))
					)[[
						int_pwmSignal__.x____ <- int_pwmSignal
						| x____ <- TIDS
					]]
					\MachineMemoryHidingSet
				)
				[|{|terminate|}|>SKIP\MachineInternalEvents
				
				STM_VS_O(id__, arg) = (AUX(id__, arg))\{terminate} 
				
				AUX_VS_O(id__, arg) = (
					(
						(Behaviours_VS_O(id__,
									arg)
						 [|MachineMemorySyncSet|]
						 Memory(id__,
						 			arg))
					)[[
						int_pwmSignal__.x____ <- int_pwmSignal
						| x____ <- TIDS
					]]
					\MachineMemoryHidingSet
				)
				[|{|terminate|}|>SKIP\MachineInternalEvents
				
				-- definition of the behaviour of state machines (default, optimised, visible, visible and optimised)
				
				FVS__(id__,
							arg) = STM_VS_O(id__,
							arg)
				
				D__(id__,
							arg) = STM(id__,
							arg) \ internal_events
				O__(id__,
							arg) = sbisim(diamond(D__(id__,
							arg)))
				VS__(id__,
							arg) = FVS__(id__,
							arg)
				VS_O__(id__,
							arg) = sbisim(diamond(FVS__(id__,
							arg)))
				HEXT__(id__,
							arg) = O__(id__,
							arg) [|shared_variable_events|] SKIP
				HUP__(id__,
							arg) = O__(id__,
							arg) [|{up__}|] SKIP
			endmodule
			-- compileOperationDef
			module OP_supplyVoltCheck
			exports
				transparent diamond
				transparent sbisim
				transparent dbisim
				transparent chase
				
				-- flow channels
				channel internal__ : TIDS
				
				-- The following are now declared per state (using modules)
				--channel enter, entered: NIDS
				channel exit
				channel exited
				channel terminate
				
				-- variable channels
				channel get_power, set_power, setL_power, setR_power: Power
				channel get_setPoint, set_setPoint, setL_setPoint, setR_setPoint: core_real
				channel get_res, set_res, setL_res, setR_res: core_boolean
				channel get_errorFlag, set_errorFlag, setL_errorFlag, setR_errorFlag: core_boolean
				channel get_lim, set_lim, setL_lim, setR_lim: core_boolean
				channel get_supplyLim, set_supplyLim, setL_supplyLim, setR_supplyLim: core_boolean
				channel get_ActualHV, set_ActualHV, setL_ActualHV, setR_ActualHV: core_real
				channel get_errorAck, set_errorAck, setL_errorAck, setR_errorAck: core_boolean
				channel get_overLimit, set_overLimit, setL_overLimit, setR_overLimit: core_real
				channel get_underLimit, set_underLimit, setL_underLimit, setR_underLimit: core_real
				
				-- shared variable channels
				channel set_EXT_setPoint: core_real
				channel set_EXT_res: core_boolean
				channel set_EXT_errorFlag: core_boolean
				channel set_EXT_lim: core_boolean
				channel set_EXT_supplyLim: core_boolean
				channel set_EXT_ActualHV: core_real
				channel set_EXT_errorAck: core_boolean
				channel set_EXT_overLimit: core_real
				channel set_EXT_underLimit: core_real
				
				-- local variable channels for defined operations that are required by the state machine
				
				-- declaring state machine events
				channel ext_setPoint__: TIDS.InOut.core_real
				channel ext_setPoint: InOut.core_real
				channel ext_pow24VStatus__: TIDS.InOut.Power
				channel ext_pow24VStatus: InOut.Power
				
				-- declaring call and ret events for undefined operations
				
				enterCSet = {|
				i0::enter,
				s0::enter,
				f0::enter
				|}
				
				enteredCSet = 	{|
				s0::entered,
				f0::entered
				|}
				
				internal_events = union(enteredCSet,union(enterCSet,{|exit,exited|}))
				
				shared_variable_events = {|
					set_EXT_setPoint,
					set_EXT_res,
					set_EXT_errorFlag,
					set_EXT_lim,
					set_EXT_supplyLim,
					set_EXT_ActualHV,
					set_EXT_errorAck,
					set_EXT_overLimit,
					set_EXT_underLimit
				|}
				
				-- Only the undefined operations are declared here.
				-- If the state machine is in isolation, all required operations will be undefined.
				-- If it is in the context of a controller, the required operations not provided by the
				-- controller will be declared here, and the defined operations will be defined in the
				-- context of the Controller module, and therefore within scope of the state machien module.
				
				
				-- declaring identifiers of transitions
				datatype TIDS = NULLTRANSITION__
				              | TID_supplyVoltCheck_t0
				              | TID_supplyVoltCheck_t1
				              | TID_supplyVoltCheck_t2
				
				-- declaring all nodes
				
				----------------------------------------------------------------------
				-- Initial: i0
				module i0
				exports
				
					channel enter, exit
					
					D__(id__) = dbisim(let
								Inactive = (MStop /\ enter -> SKIP) ; (MStop /\ exit -> Inactive)
							within
								Inactive)
								
					VS_O__(id__) = D__(id__)
				
				endmodule
				----------------------------------------------------------------------
				
				
				----------------------------------------------------------------------
				-- State: s0
				module s0
				
				enterCSet = {}
				
				enteredCSet = {}
				
				exports
				
					--  Declarations
					-- declaring identifiers of transitions
					datatype TIDS = NULLTRANSITION__
					
					channel internal__ : TIDS
					channel enter, entered, exit, exited
					channel enteredL, enteredR
					channel end__
					
									
					
					--	Nodes
					-- declaring all nodes
					
					TransitionSync = {||}
					
					--	Rule: behaviours(Node)
					--  Note that FDR has problems with efficiently compiling the process below
					-- 	if using a different recursion pattern.
					D__(id__) = 
					dbisim(let
						Inactive = (MStop /\ enter -> SKIP) ; SKIP ; 
									Behaviour ; 
									SKIP ; 
									exited -> SKIP ; Inactive
					
						Behaviour = entered -> ((SKIP ; MStop) /\ exit -> SKIP)
					within
						Inactive)
						
					VS_O__(id__) = 
						dbisim(let
							Inactive = (MStop /\ enter -> SKIP) ; SKIP ; 
										Behaviour ; 
										SKIP ; 
										exited -> SKIP ; Inactive
					
							Behaviour = entered -> ((SKIP ; MStop) /\ exit -> SKIP)
						within
							Inactive)
					
				
				endmodule
				----------------------------------------------------------------------
				
				
				----------------------------------------------------------------------
				-- Final state: f0
				module f0
				
				exports
				
					channel enter, entered, exit, exited
					channel enteredL, enteredR
					
					--	Rule: behaviours(Node)
					D__(id__) = 
					dbisim(let
						Inactive = (MStop /\ enter -> SKIP) ; Behaviour ; exited -> Inactive
						Behaviour = entered -> (MStop /\ exit -> SKIP)
					within
						Inactive)
						
					VS_O__(id__) = D__(id__)
				
				endmodule
				----------------------------------------------------------------------
				
				
				TransitionSync = {|internal__.TID_supplyVoltCheck_t0,
				ext_pow24VStatus__.TID_supplyVoltCheck_t1,
				ext_pow24VStatus__.TID_supplyVoltCheck_t2|}
				
				-- The following is obviously not efficient for FDR to compile.
				-- For efficiency reasons a stepwise composition should be implemented instead.
				ComposeNodes(id__) = [| { up__ } |] proc__ : {i0::D__(id__),s0::D__(id__),f0::D__(id__)} @ proc__
				
				ComposeNodes_VS_O(id__) = [| { up__ } |] proc__ : {i0::VS_O__(id__),s0::VS_O__(id__),f0::VS_O__(id__)} @ proc__
				
				Transitions(id__) = (get_power?power -> (up__ -> SKIP
				[] dbisim((true)&(internal__!TID_supplyVoltCheck_t0 -> SKIP ;  ((SKIP
				 ; s0::enter -> SKIP))))
				[] dbisim((ext_pow24VStatus__!TID_supplyVoltCheck_t1.in?power:{power|power <- Power, (power==Power_On)} -> set_power!power -> SKIP ; ((MStop /\ exited -> SKIP) ; true & (set_lim!false -> SKIP)
				 ; f0::enter -> SKIP)))
				[] dbisim((ext_pow24VStatus__!TID_supplyVoltCheck_t2.in?power:{power|power <- Power, (power==Power_Off)} -> set_power!power -> SKIP ; ((MStop /\ exited -> SKIP) ; true & (set_lim!true -> SKIP)
				 ; f0::enter -> SKIP)))
				)
				) ; Transitions(id__)
				
				Behaviours(id__) = ((
				 ((ComposeNodes(id__)[[s0::exit <- x__ | x__ <- {|exit,ext_pow24VStatus__.TID_supplyVoltCheck_t1.in,ext_pow24VStatus__.TID_supplyVoltCheck_t2.in|}]]
				 [[f0::exit <- x__ | x__ <- {|exit,terminate|}]]
				 [[i0::exit <- x__ | x__ <- {|internal__.TID_supplyVoltCheck_t0|}]]
				 [[  
				 s0::exited <- exited,
				 f0::exited <- exited
				 ]]
				 )
				  [[ up__ <- x__ | x__ <- {| up__ |} ]] 
				  [[set_power <- setL_power]]
				 )
				 [| union(union(union(enterCSet,TransitionSync),{| exited |}),{|up__
				 			,setL_power
				|}) |]
				 ((i0::enter -> Transitions(id__))
				  [[ up__ <- x__ | x__ <- {| up__,setL_power |} ]]
				 )
				)[[setL_power <- set_power]]
				\ union(enterCSet,{| exited, internal__ |})
				 [| {exit} |] STOP)
				
				Behaviours_VS_O(id__) = ((
				 ((ComposeNodes_VS_O(id__)[[s0::exit <- x__ | x__ <- {|exit,ext_pow24VStatus__.TID_supplyVoltCheck_t1.in,ext_pow24VStatus__.TID_supplyVoltCheck_t2.in|}]]
				 [[f0::exit <- x__ | x__ <- {|exit,terminate|}]]
				 [[i0::exit <- x__ | x__ <- {|internal__.TID_supplyVoltCheck_t0|}]]
				 [[  
				 s0::exited <- exited,
				 f0::exited <- exited
				 ]]
				 )
				  [[ up__ <- x__ | x__ <- {| up__ |} ]] 
				  [[set_power <- setL_power]]
				 )
				 [| union(union(union(enterCSet,TransitionSync),{| exited |}),{|up__
				 			,setL_power
				|}) |]
				 ((i0::enter -> Transitions(id__))
				  [[ up__ <- x__ | x__ <- {| up__,setL_power |} ]]
				 )
				)[[setL_power <- set_power]]
				\ union(enterCSet,{| exited, internal__ |})
				 [| {exit} |] STOP)
				
				
				-- memory process
				Memory_power(power) =
					get_power!power -> Memory_power(power)
					[]
					set_power?x__ -> Memory_power(x__)
				
				Memory(id__) =
					Memory_power(Power_On)
				Memory_setPoint(setPoint) =
					get_setPoint!setPoint -> Memory_setPoint(setPoint)
					[]
					set_setPoint?x__ -> Memory_setPoint(x__)
					[]
					set_EXT_setPoint?x__ -> Memory_setPoint(x__)
				Memory_res(res) =
					get_res!res -> Memory_res(res)
					[]
					set_res?x__ -> Memory_res(x__)
					[]
					set_EXT_res?x__ -> Memory_res(x__)
				Memory_errorFlag(errorFlag) =
					get_errorFlag!errorFlag -> Memory_errorFlag(errorFlag)
					[]
					set_errorFlag?x__ -> Memory_errorFlag(x__)
					[]
					set_EXT_errorFlag?x__ -> Memory_errorFlag(x__)
				Memory_lim(lim) =
					get_lim!lim -> Memory_lim(lim)
					[]
					set_lim?x__ -> Memory_lim(x__)
					[]
					set_EXT_lim?x__ -> Memory_lim(x__)
				Memory_supplyLim(supplyLim) =
					get_supplyLim!supplyLim -> Memory_supplyLim(supplyLim)
					[]
					set_supplyLim?x__ -> Memory_supplyLim(x__)
					[]
					set_EXT_supplyLim?x__ -> Memory_supplyLim(x__)
				Memory_ActualHV(ActualHV) =
					get_ActualHV!ActualHV -> Memory_ActualHV(ActualHV)
					[]
					set_ActualHV?x__ -> Memory_ActualHV(x__)
					[]
					set_EXT_ActualHV?x__ -> Memory_ActualHV(x__)
				Memory_errorAck(errorAck) =
					get_errorAck!errorAck -> Memory_errorAck(errorAck)
					[]
					set_errorAck?x__ -> Memory_errorAck(x__)
					[]
					set_EXT_errorAck?x__ -> Memory_errorAck(x__)
				Memory_overLimit(overLimit) =
					get_overLimit!overLimit -> Memory_overLimit(overLimit)
					[]
					set_overLimit?x__ -> Memory_overLimit(x__)
					[]
					set_EXT_overLimit?x__ -> Memory_overLimit(x__)
				Memory_underLimit(underLimit) =
					get_underLimit!underLimit -> Memory_underLimit(underLimit)
					[]
					set_underLimit?x__ -> Memory_underLimit(x__)
					[]
					set_EXT_underLimit?x__ -> Memory_underLimit(x__)
				
				SharedVariableMemory(id__) =
					Memory_setPoint(0)
					|||
					Memory_res(false)
					|||
					Memory_errorFlag(true)
					|||
					Memory_lim(false)
					|||
					Memory_supplyLim(false)
					|||
					Memory_ActualHV(0)
					|||
					Memory_errorAck(false)
					|||
					Memory_overLimit(0)
					|||
					Memory_underLimit(0)
				
				SharedVariablesSyncSet = {|get_setPoint,set_setPoint,set_EXT_setPoint,get_res,set_res,set_EXT_res,get_errorFlag,set_errorFlag,set_EXT_errorFlag,get_lim,set_lim,set_EXT_lim,get_supplyLim,set_supplyLim,set_EXT_supplyLim,get_ActualHV,set_ActualHV,set_EXT_ActualHV,get_errorAck,set_errorAck,set_EXT_errorAck,get_overLimit,set_overLimit,set_EXT_overLimit,get_underLimit,set_underLimit,set_EXT_underLimit|}
				
				SharedVariableHidingSet = {|get_setPoint,get_res,get_errorFlag,get_lim,get_supplyLim,get_ActualHV,get_errorAck,get_overLimit,get_underLimit|}
				
				MachineMemorySyncSet = 
					{|get_power,set_power|}
					
				MachineMemoryHidingSet = {|get_power,set_power|}
				
				MachineInternalEvents = {|
					internal__
				|}
				
								
				-- main process
				
				STM(id__) = (AUX(id__))\{terminate} 
				
				AUX(id__) = (
					(
						(Behaviours(id__)
						 [|MachineMemorySyncSet|]
						 Memory(id__))
					)[[
						ext_setPoint__.x____ <- ext_setPoint,
						ext_pow24VStatus__.x____ <- ext_pow24VStatus
						| x____ <- TIDS
					]]
					\MachineMemoryHidingSet
				)
				[|{|terminate|}|>SKIP\MachineInternalEvents
				
				STM_VS_O(id__) = (AUX(id__))\{terminate} 
				
				AUX_VS_O(id__) = (
					(
						(Behaviours_VS_O(id__)
						 [|MachineMemorySyncSet|]
						 Memory(id__))
					)[[
						ext_setPoint__.x____ <- ext_setPoint,
						ext_pow24VStatus__.x____ <- ext_pow24VStatus
						| x____ <- TIDS
					]]
					\MachineMemoryHidingSet
				)
				[|{|terminate|}|>SKIP\MachineInternalEvents
				
				-- definition of the behaviour of state machines (default, optimised, visible, visible and optimised)
				
				FVS__(id__) = STM_VS_O(id__)
				
				D__(id__) = STM(id__) \ internal_events
				O__(id__) = sbisim(diamond(D__(id__)))
				VS__(id__) = FVS__(id__)
				VS_O__(id__) = sbisim(diamond(FVS__(id__)))
				HEXT__(id__) = O__(id__) [|shared_variable_events|] SKIP
				HUP__(id__) = O__(id__) [|{up__}|] SKIP
			endmodule
			-- compileOperationDef
			module OP_checkLimits
			exports
				transparent diamond
				transparent sbisim
				transparent dbisim
				transparent chase
				
				-- flow channels
				channel internal__ : TIDS
				
				-- The following are now declared per state (using modules)
				--channel enter, entered: NIDS
				channel exit
				channel exited
				channel terminate
				
				-- variable channels
				channel get_setPoint, set_setPoint, setL_setPoint, setR_setPoint: core_real
				channel get_res, set_res, setL_res, setR_res: core_boolean
				channel get_errorFlag, set_errorFlag, setL_errorFlag, setR_errorFlag: core_boolean
				channel get_lim, set_lim, setL_lim, setR_lim: core_boolean
				channel get_supplyLim, set_supplyLim, setL_supplyLim, setR_supplyLim: core_boolean
				channel get_ActualHV, set_ActualHV, setL_ActualHV, setR_ActualHV: core_real
				channel get_errorAck, set_errorAck, setL_errorAck, setR_errorAck: core_boolean
				channel get_overLimit, set_overLimit, setL_overLimit, setR_overLimit: core_real
				channel get_underLimit, set_underLimit, setL_underLimit, setR_underLimit: core_real
				
				-- shared variable channels
				channel set_EXT_setPoint: core_real
				channel set_EXT_res: core_boolean
				channel set_EXT_errorFlag: core_boolean
				channel set_EXT_lim: core_boolean
				channel set_EXT_supplyLim: core_boolean
				channel set_EXT_ActualHV: core_real
				channel set_EXT_errorAck: core_boolean
				channel set_EXT_overLimit: core_real
				channel set_EXT_underLimit: core_real
				
				-- local variable channels for defined operations that are required by the state machine
				
				-- declaring state machine events
				channel ext_setPoint__: TIDS.InOut.core_real
				channel ext_setPoint: InOut.core_real
				channel ext_pow24VStatus__: TIDS.InOut.Power
				channel ext_pow24VStatus: InOut.Power
				
				-- declaring call and ret events for undefined operations
				
				enterCSet = {|
				i0::enter,
				s0::enter,
				f0::enter
				|}
				
				enteredCSet = 	{|
				s0::entered,
				f0::entered
				|}
				
				internal_events = union(enteredCSet,union(enterCSet,{|exit,exited|}))
				
				shared_variable_events = {|
					set_EXT_setPoint,
					set_EXT_res,
					set_EXT_errorFlag,
					set_EXT_lim,
					set_EXT_supplyLim,
					set_EXT_ActualHV,
					set_EXT_errorAck,
					set_EXT_overLimit,
					set_EXT_underLimit
				|}
				
				-- Only the undefined operations are declared here.
				-- If the state machine is in isolation, all required operations will be undefined.
				-- If it is in the context of a controller, the required operations not provided by the
				-- controller will be declared here, and the defined operations will be defined in the
				-- context of the Controller module, and therefore within scope of the state machien module.
				
				
				-- declaring identifiers of transitions
				datatype TIDS = NULLTRANSITION__
				              | TID_checkLimits_t0
				              | TID_checkLimits_t1
				              | TID_checkLimits_t2
				
				-- declaring all nodes
				
				----------------------------------------------------------------------
				-- Initial: i0
				module i0
				exports
				
					channel enter, exit
					
					D__(id__) = dbisim(let
								Inactive = (MStop /\ enter -> SKIP) ; (MStop /\ exit -> Inactive)
							within
								Inactive)
								
					VS_O__(id__) = D__(id__)
				
				endmodule
				----------------------------------------------------------------------
				
				
				----------------------------------------------------------------------
				-- State: s0
				module s0
				
				enterCSet = {}
				
				enteredCSet = {}
				
				exports
				
					--  Declarations
					-- declaring identifiers of transitions
					datatype TIDS = NULLTRANSITION__
					
					channel internal__ : TIDS
					channel enter, entered, exit, exited
					channel enteredL, enteredR
					channel end__
					
									
					
					--	Nodes
					-- declaring all nodes
					
					TransitionSync = {||}
					
					--	Rule: behaviours(Node)
					--  Note that FDR has problems with efficiently compiling the process below
					-- 	if using a different recursion pattern.
					D__(id__) = 
					dbisim(let
						Inactive = (MStop /\ enter -> SKIP) ; SKIP ; 
									Behaviour ; 
									SKIP ; 
									exited -> SKIP ; Inactive
					
						Behaviour = entered -> ((SKIP ; MStop) /\ exit -> SKIP)
					within
						Inactive)
						
					VS_O__(id__) = 
						dbisim(let
							Inactive = (MStop /\ enter -> SKIP) ; SKIP ; 
										Behaviour ; 
										SKIP ; 
										exited -> SKIP ; Inactive
					
							Behaviour = entered -> ((SKIP ; MStop) /\ exit -> SKIP)
						within
							Inactive)
					
				
				endmodule
				----------------------------------------------------------------------
				
				
				----------------------------------------------------------------------
				-- Final state: f0
				module f0
				
				exports
				
					channel enter, entered, exit, exited
					channel enteredL, enteredR
					
					--	Rule: behaviours(Node)
					D__(id__) = 
					dbisim(let
						Inactive = (MStop /\ enter -> SKIP) ; Behaviour ; exited -> Inactive
						Behaviour = entered -> (MStop /\ exit -> SKIP)
					within
						Inactive)
						
					VS_O__(id__) = D__(id__)
				
				endmodule
				----------------------------------------------------------------------
				
				
				TransitionSync = {|internal__.TID_checkLimits_t0,
				internal__.TID_checkLimits_t1,
				internal__.TID_checkLimits_t2|}
				
				-- The following is obviously not efficient for FDR to compile.
				-- For efficiency reasons a stepwise composition should be implemented instead.
				ComposeNodes(id__) = [| { up__ } |] proc__ : {i0::D__(id__),s0::D__(id__),f0::D__(id__)} @ proc__
				
				ComposeNodes_VS_O(id__) = [| { up__ } |] proc__ : {i0::VS_O__(id__),s0::VS_O__(id__),f0::VS_O__(id__)} @ proc__
				
				Transitions(id__) = (get_overLimit?overLimit -> get_ActualHV?ActualHV -> get_underLimit?underLimit -> (up__ -> SKIP
				[] dbisim((true)&(internal__!TID_checkLimits_t0 -> SKIP ;  ((SKIP
				 ; s0::enter -> SKIP))))
				[] dbisim((((ActualHV<=overLimit) and (ActualHV>=underLimit)))&(internal__!TID_checkLimits_t1 -> SKIP ;  ((MStop /\ exited -> SKIP) ; true & (set_lim!false -> SKIP)
				 ; f0::enter -> SKIP)))
				[] dbisim((((ActualHV<underLimit) or (ActualHV>overLimit)))&(internal__!TID_checkLimits_t2 -> SKIP ;  ((MStop /\ exited -> SKIP) ; true & (set_lim!true -> SKIP)
				 ; f0::enter -> SKIP)))
				)
				) ; Transitions(id__)
				
				Behaviours(id__) = ((
				 ((ComposeNodes(id__)[[s0::exit <- x__ | x__ <- {|exit,internal__.TID_checkLimits_t1,internal__.TID_checkLimits_t2|}]]
				 [[f0::exit <- x__ | x__ <- {|exit,terminate|}]]
				 [[i0::exit <- x__ | x__ <- {|internal__.TID_checkLimits_t0|}]]
				 [[  
				 s0::exited <- exited,
				 f0::exited <- exited
				 ]]
				 )
				  [[ up__ <- x__ | x__ <- {| up__ |} ]] 
				  [[set_overLimit <- setL_overLimit,set_ActualHV <- setL_ActualHV,set_underLimit <- setL_underLimit]]
				 )
				 [| union(union(union(enterCSet,TransitionSync),{| exited |}),{|up__
				 			,setL_overLimit
				 			,setL_ActualHV
				 			,setL_underLimit
				|}) |]
				 ((i0::enter -> Transitions(id__))
				  [[ up__ <- x__ | x__ <- {| up__,setL_overLimit,setL_ActualHV,setL_underLimit |} ]]
				 )
				)[[setL_overLimit <- set_overLimit,setL_ActualHV <- set_ActualHV,setL_underLimit <- set_underLimit]]
				\ union(enterCSet,{| exited, internal__ |})
				 [| {exit} |] STOP)
				
				Behaviours_VS_O(id__) = ((
				 ((ComposeNodes_VS_O(id__)[[s0::exit <- x__ | x__ <- {|exit,internal__.TID_checkLimits_t1,internal__.TID_checkLimits_t2|}]]
				 [[f0::exit <- x__ | x__ <- {|exit,terminate|}]]
				 [[i0::exit <- x__ | x__ <- {|internal__.TID_checkLimits_t0|}]]
				 [[  
				 s0::exited <- exited,
				 f0::exited <- exited
				 ]]
				 )
				  [[ up__ <- x__ | x__ <- {| up__ |} ]] 
				  [[set_overLimit <- setL_overLimit,set_ActualHV <- setL_ActualHV,set_underLimit <- setL_underLimit]]
				 )
				 [| union(union(union(enterCSet,TransitionSync),{| exited |}),{|up__
				 			,setL_overLimit
				 			,setL_ActualHV
				 			,setL_underLimit
				|}) |]
				 ((i0::enter -> Transitions(id__))
				  [[ up__ <- x__ | x__ <- {| up__,setL_overLimit,setL_ActualHV,setL_underLimit |} ]]
				 )
				)[[setL_overLimit <- set_overLimit,setL_ActualHV <- set_ActualHV,setL_underLimit <- set_underLimit]]
				\ union(enterCSet,{| exited, internal__ |})
				 [| {exit} |] STOP)
				
				
				-- memory process
				
				Memory(id__) =
					STOP
				Memory_setPoint(setPoint) =
					get_setPoint!setPoint -> Memory_setPoint(setPoint)
					[]
					set_setPoint?x__ -> Memory_setPoint(x__)
					[]
					set_EXT_setPoint?x__ -> Memory_setPoint(x__)
				Memory_res(res) =
					get_res!res -> Memory_res(res)
					[]
					set_res?x__ -> Memory_res(x__)
					[]
					set_EXT_res?x__ -> Memory_res(x__)
				Memory_errorFlag(errorFlag) =
					get_errorFlag!errorFlag -> Memory_errorFlag(errorFlag)
					[]
					set_errorFlag?x__ -> Memory_errorFlag(x__)
					[]
					set_EXT_errorFlag?x__ -> Memory_errorFlag(x__)
				Memory_lim(lim) =
					get_lim!lim -> Memory_lim(lim)
					[]
					set_lim?x__ -> Memory_lim(x__)
					[]
					set_EXT_lim?x__ -> Memory_lim(x__)
				Memory_supplyLim(supplyLim) =
					get_supplyLim!supplyLim -> Memory_supplyLim(supplyLim)
					[]
					set_supplyLim?x__ -> Memory_supplyLim(x__)
					[]
					set_EXT_supplyLim?x__ -> Memory_supplyLim(x__)
				Memory_ActualHV(ActualHV) =
					get_ActualHV!ActualHV -> Memory_ActualHV(ActualHV)
					[]
					set_ActualHV?x__ -> Memory_ActualHV(x__)
					[]
					set_EXT_ActualHV?x__ -> Memory_ActualHV(x__)
				Memory_errorAck(errorAck) =
					get_errorAck!errorAck -> Memory_errorAck(errorAck)
					[]
					set_errorAck?x__ -> Memory_errorAck(x__)
					[]
					set_EXT_errorAck?x__ -> Memory_errorAck(x__)
				Memory_overLimit(overLimit) =
					get_overLimit!overLimit -> Memory_overLimit(overLimit)
					[]
					set_overLimit?x__ -> Memory_overLimit(x__)
					[]
					set_EXT_overLimit?x__ -> Memory_overLimit(x__)
				Memory_underLimit(underLimit) =
					get_underLimit!underLimit -> Memory_underLimit(underLimit)
					[]
					set_underLimit?x__ -> Memory_underLimit(x__)
					[]
					set_EXT_underLimit?x__ -> Memory_underLimit(x__)
				
				SharedVariableMemory(id__) =
					Memory_setPoint(0)
					|||
					Memory_res(false)
					|||
					Memory_errorFlag(true)
					|||
					Memory_lim(false)
					|||
					Memory_supplyLim(false)
					|||
					Memory_ActualHV(0)
					|||
					Memory_errorAck(false)
					|||
					Memory_overLimit(0)
					|||
					Memory_underLimit(0)
				
				SharedVariablesSyncSet = {|get_setPoint,set_setPoint,set_EXT_setPoint,get_res,set_res,set_EXT_res,get_errorFlag,set_errorFlag,set_EXT_errorFlag,get_lim,set_lim,set_EXT_lim,get_supplyLim,set_supplyLim,set_EXT_supplyLim,get_ActualHV,set_ActualHV,set_EXT_ActualHV,get_errorAck,set_errorAck,set_EXT_errorAck,get_overLimit,set_overLimit,set_EXT_overLimit,get_underLimit,set_underLimit,set_EXT_underLimit|}
				
				SharedVariableHidingSet = {|get_setPoint,get_res,get_errorFlag,get_lim,get_supplyLim,get_ActualHV,get_errorAck,get_overLimit,get_underLimit|}
				
				MachineMemorySyncSet = 
					{||}
					
				MachineMemoryHidingSet = {||}
				
				MachineInternalEvents = {|
					internal__
				|}
				
								
				-- main process
				
				STM(id__) = (AUX(id__))\{terminate} 
				
				AUX(id__) = (
					(
						(Behaviours(id__)
						 [|MachineMemorySyncSet|]
						 Memory(id__))
					)[[
						ext_setPoint__.x____ <- ext_setPoint,
						ext_pow24VStatus__.x____ <- ext_pow24VStatus
						| x____ <- TIDS
					]]
					\MachineMemoryHidingSet
				)
				[|{|terminate|}|>SKIP\MachineInternalEvents
				
				STM_VS_O(id__) = (AUX(id__))\{terminate} 
				
				AUX_VS_O(id__) = (
					(
						(Behaviours_VS_O(id__)
						 [|MachineMemorySyncSet|]
						 Memory(id__))
					)[[
						ext_setPoint__.x____ <- ext_setPoint,
						ext_pow24VStatus__.x____ <- ext_pow24VStatus
						| x____ <- TIDS
					]]
					\MachineMemoryHidingSet
				)
				[|{|terminate|}|>SKIP\MachineInternalEvents
				
				-- definition of the behaviour of state machines (default, optimised, visible, visible and optimised)
				
				FVS__(id__) = STM_VS_O(id__)
				
				D__(id__) = STM(id__) \ internal_events
				O__(id__) = sbisim(diamond(D__(id__)))
				VS__(id__) = FVS__(id__)
				VS_O__(id__) = sbisim(diamond(FVS__(id__)))
				HEXT__(id__) = O__(id__) [|shared_variable_events|] SKIP
				HUP__(id__) = O__(id__) [|{up__}|] SKIP
			endmodule
		
			-- declaring machines
			module stm_ref0
			exports
				transparent diamond
				transparent sbisim
				transparent dbisim
				transparent chase
			
				-- flow channels
				channel internal__ : TIDS
				
				-- The following are now declared per state (using modules)
				--channel enter, entered: NIDS
				channel exit
				channel exited
				channel terminate
				
				-- variable channels
				channel get_power, set_power, setL_power, setR_power: Power
				channel get_setPoint, set_setPoint, setL_setPoint, setR_setPoint: core_real
				channel get_res, set_res, setL_res, setR_res: core_boolean
				channel get_errorFlag, set_errorFlag, setL_errorFlag, setR_errorFlag: core_boolean
				channel get_lim, set_lim, setL_lim, setR_lim: core_boolean
				channel get_supplyLim, set_supplyLim, setL_supplyLim, setR_supplyLim: core_boolean
				channel get_ActualHV, set_ActualHV, setL_ActualHV, setR_ActualHV: core_real
				channel get_errorAck, set_errorAck, setL_errorAck, setR_errorAck: core_boolean
				channel get_overLimit, set_overLimit, setL_overLimit, setR_overLimit: core_real
				channel get_underLimit, set_underLimit, setL_underLimit, setR_underLimit: core_real
				
				-- shared variable channels
				
				-- local variable channels for defined operations that are required by the state machine
				channel get_supplyVoltCheck_power, set_supplyVoltCheck_power: Power
				
				-- declaring state machine events
				channel currentState__: TIDS.InOut.State
				channel currentState: InOut.State
				channel ext_setPoint__: TIDS.InOut.core_real
				channel ext_setPoint: InOut.core_real
				channel ext_pow24VStatus__: TIDS.InOut.Power
				channel ext_pow24VStatus: InOut.Power
				channel int_overLimit__: TIDS.InOut.core_real
				channel int_overLimit: InOut.core_real
				channel int_pwmSignal__: TIDS.InOut.Power
				channel int_pwmSignal: InOut.Power
				channel int_underLimit__: TIDS.InOut.core_real
				channel int_underLimit: InOut.core_real
				channel int_DisableHV__: TIDS.InOut
				channel int_DisableHV: InOut
				channel int_ActualHV__: TIDS.InOut.core_real
				channel int_ActualHV: InOut.core_real
				
				-- declaring call and ret events for undefined operations
				
				enterCSet = {|
				Ramping::enter,
				Init::enter,
				Wait24Vpower::enter,
				ClosedLoop::enter,
				ErrorMode::enter,
				i0::enter,
				j0::enter
				|}
				
				enteredCSet = 	{|
				Ramping::entered,
				Init::entered,
				Wait24Vpower::entered,
				ClosedLoop::entered,
				ErrorMode::entered
				|}
				
				internal_events = union(enteredCSet,union(enterCSet,{|exit,exited|}))
				
				shared_variable_events = {|
				|}
			
				-- Only the undefined operations are declared here.
				-- If the state machine is in isolation, all required operations will be undefined.
				-- If it is in the context of a controller, the required operations not provided by the
				-- controller will be declared here, and the defined operations will be defined in the
				-- context of the Controller module, and therefore within scope of the state machien module.
				
				CALL__disableHV(id__,
							arg) = call__ -> (OP_disableHV::O__(id__,
							arg))
				[[
					OP_disableHV::int_pwmSignal <- int_pwmSignal
				]]
				[[
					OP_disableHV::get_setPoint <- get_setPoint,
					OP_disableHV::set_setPoint <- set_setPoint,
					OP_disableHV::get_res <- get_res,
					OP_disableHV::set_res <- set_res,
					OP_disableHV::get_errorFlag <- get_errorFlag,
					OP_disableHV::set_errorFlag <- set_errorFlag,
					OP_disableHV::get_lim <- get_lim,
					OP_disableHV::set_lim <- set_lim,
					OP_disableHV::get_supplyLim <- get_supplyLim,
					OP_disableHV::set_supplyLim <- set_supplyLim,
					OP_disableHV::get_ActualHV <- get_ActualHV,
					OP_disableHV::set_ActualHV <- set_ActualHV,
					OP_disableHV::get_errorAck <- get_errorAck,
					OP_disableHV::set_errorAck <- set_errorAck,
					OP_disableHV::get_overLimit <- get_overLimit,
					OP_disableHV::set_overLimit <- set_overLimit,
					OP_disableHV::get_underLimit <- get_underLimit,
					OP_disableHV::set_underLimit <- set_underLimit
				]]
				 ; ret__ -> SKIP
				CALL__supplyVoltCheck(id__) = call__ -> (OP_supplyVoltCheck::O__(id__))
				[[
					OP_supplyVoltCheck::ext_setPoint <- ext_setPoint,
					OP_supplyVoltCheck::ext_pow24VStatus <- ext_pow24VStatus
				]]
				[[
					OP_supplyVoltCheck::get_setPoint <- get_setPoint,
					OP_supplyVoltCheck::set_setPoint <- set_setPoint,
					OP_supplyVoltCheck::get_res <- get_res,
					OP_supplyVoltCheck::set_res <- set_res,
					OP_supplyVoltCheck::get_errorFlag <- get_errorFlag,
					OP_supplyVoltCheck::set_errorFlag <- set_errorFlag,
					OP_supplyVoltCheck::get_lim <- get_lim,
					OP_supplyVoltCheck::set_lim <- set_lim,
					OP_supplyVoltCheck::get_supplyLim <- get_supplyLim,
					OP_supplyVoltCheck::set_supplyLim <- set_supplyLim,
					OP_supplyVoltCheck::get_ActualHV <- get_ActualHV,
					OP_supplyVoltCheck::set_ActualHV <- set_ActualHV,
					OP_supplyVoltCheck::get_errorAck <- get_errorAck,
					OP_supplyVoltCheck::set_errorAck <- set_errorAck,
					OP_supplyVoltCheck::get_overLimit <- get_overLimit,
					OP_supplyVoltCheck::set_overLimit <- set_overLimit,
					OP_supplyVoltCheck::get_underLimit <- get_underLimit,
					OP_supplyVoltCheck::set_underLimit <- set_underLimit
				]]
				 ; ret__ -> SKIP
				CALL__checkLimits(id__) = call__ -> (OP_checkLimits::O__(id__))
				[[
					OP_checkLimits::ext_setPoint <- ext_setPoint,
					OP_checkLimits::ext_pow24VStatus <- ext_pow24VStatus
				]]
				[[
					OP_checkLimits::get_setPoint <- get_setPoint,
					OP_checkLimits::set_setPoint <- set_setPoint,
					OP_checkLimits::get_res <- get_res,
					OP_checkLimits::set_res <- set_res,
					OP_checkLimits::get_errorFlag <- get_errorFlag,
					OP_checkLimits::set_errorFlag <- set_errorFlag,
					OP_checkLimits::get_lim <- get_lim,
					OP_checkLimits::set_lim <- set_lim,
					OP_checkLimits::get_supplyLim <- get_supplyLim,
					OP_checkLimits::set_supplyLim <- set_supplyLim,
					OP_checkLimits::get_ActualHV <- get_ActualHV,
					OP_checkLimits::set_ActualHV <- set_ActualHV,
					OP_checkLimits::get_errorAck <- get_errorAck,
					OP_checkLimits::set_errorAck <- set_errorAck,
					OP_checkLimits::get_overLimit <- get_overLimit,
					OP_checkLimits::set_overLimit <- set_overLimit,
					OP_checkLimits::get_underLimit <- get_underLimit,
					OP_checkLimits::set_underLimit <- set_underLimit
				]]
				 ; ret__ -> SKIP
				
				-- declaring identifiers of transitions
				datatype TIDS = NULLTRANSITION__
				              | TID_State_machine_t0
				              | TID_State_machine_t1
				              | TID_State_machine_t2
				              | TID_State_machine_t3
				              | TID_State_machine_t4
				              | TID_State_machine_t5
				              | TID_State_machine_t6
				              | TID_State_machine_t8
				              | TID_State_machine_t11
				              | TID_State_machine_t7
				
				-- declaring all nodes
				
				----------------------------------------------------------------------
				-- State: Ramping
				module Ramping
				
				enterCSet = {}
				
				enteredCSet = {}
				
				exports
				
					--  Declarations
					-- declaring identifiers of transitions
					datatype TIDS = NULLTRANSITION__
					
					channel internal__ : TIDS
					channel enter, entered, exit, exited
					channel enteredL, enteredR
					channel end__
					
									
					
					--	Nodes
					-- declaring all nodes
					
					TransitionSync = {||}
					
					--	Rule: behaviours(Node)
					--  Note that FDR has problems with efficiently compiling the process below
					-- 	if using a different recursion pattern.
					D__(id__) = 
					dbisim(let
						Inactive = (MStop /\ enter -> SKIP) ; true&(currentState.out!State_Ramp -> SKIP)
						 ; 
									Behaviour ; 
									SKIP ; 
									exited -> SKIP ; Inactive
					
						Behaviour = entered -> ((SKIP ; MStop) /\ exit -> SKIP)
					within
						Inactive)
						
					VS_O__(id__) = 
						dbisim(let
							Inactive = (MStop /\ enter -> SKIP) ; true&(currentState.out!State_Ramp -> SKIP)
							 ; 
										Behaviour ; 
										SKIP ; 
										exited -> SKIP ; Inactive
					
							Behaviour = entered -> ((SKIP ; MStop) /\ exit -> SKIP)
						within
							Inactive)
					
				
				endmodule
				----------------------------------------------------------------------
				
				
				----------------------------------------------------------------------
				-- State: Init
				module Init
				
				enterCSet = 
						{|			i0::enter,
							si0::enter
						|}
				enteredCSet = 
						{|			si0::entered
						|}
				exports
				
					--  Declarations
					-- declaring identifiers of transitions
					datatype TIDS = NULLTRANSITION__
					              | TID_State_machine_Init_t0
					
					channel internal__ : TIDS
					channel enter, entered, exit, exited
					channel enteredL, enteredR
					channel end__
					
									
					channel currentState__: TIDS.InOut.State
					channel ext_setPoint__: TIDS.InOut.core_real
					channel ext_pow24VStatus__: TIDS.InOut.Power
					channel int_overLimit__: TIDS.InOut.core_real
					channel int_pwmSignal__: TIDS.InOut.Power
					channel int_underLimit__: TIDS.InOut.core_real
					channel int_DisableHV__: TIDS.InOut
					channel int_ActualHV__: TIDS.InOut.core_real
					
					--	Nodes
					-- declaring all nodes
					
					----------------------------------------------------------------------
					-- Initial: i0
					module i0
					exports
					
						channel enter, exit
						
						D__(id__) = dbisim(let
									Inactive = (MStop /\ enter -> SKIP) ; (MStop /\ exit -> Inactive)
								within
									Inactive)
									
						VS_O__(id__) = D__(id__)
					
					endmodule
					----------------------------------------------------------------------
					
					
					----------------------------------------------------------------------
					-- State: si0
					module si0
					
					enterCSet = {}
					
					enteredCSet = {}
					
					exports
					
						--  Declarations
						-- declaring identifiers of transitions
						datatype TIDS = NULLTRANSITION__
						
						channel internal__ : TIDS
						channel enter, entered, exit, exited
						channel enteredL, enteredR
						channel end__
						
										
						
						--	Nodes
						-- declaring all nodes
						
						TransitionSync = {||}
						
						--	Rule: behaviours(Node)
						--  Note that FDR has problems with efficiently compiling the process below
						-- 	if using a different recursion pattern.
						D__(id__) = 
						dbisim(let
							Inactive = (MStop /\ enter -> SKIP) ; get_setPoint?setPoint -> true & (set_overLimit!overLimitF(Plus(setPoint, 2, core_real)) -> SKIP);get_setPoint?setPoint -> true & (set_underLimit!underLimitF(Minus(setPoint, 2, core_real)) -> SKIP);get_underLimit?underLimit -> true&(int_underLimit.out!underLimit -> SKIP);get_overLimit?overLimit -> true&(int_overLimit.out!overLimit -> SKIP)
							 ; 
										Behaviour ; 
										SKIP ; 
										exited -> SKIP ; Inactive
						
							Behaviour = entered -> ((SKIP ; MStop) /\ exit -> SKIP)
						within
							Inactive)
							
						VS_O__(id__) = 
							dbisim(let
								Inactive = (MStop /\ enter -> SKIP) ; get_setPoint?setPoint -> true & (set_overLimit!overLimitF(Plus(setPoint, 2, core_real)) -> SKIP);get_setPoint?setPoint -> true & (set_underLimit!underLimitF(Minus(setPoint, 2, core_real)) -> SKIP);get_underLimit?underLimit -> true&(int_underLimit.out!underLimit -> SKIP);get_overLimit?overLimit -> true&(int_overLimit.out!overLimit -> SKIP)
								 ; 
											Behaviour ; 
											SKIP ; 
											exited -> SKIP ; Inactive
						
								Behaviour = entered -> ((SKIP ; MStop) /\ exit -> SKIP)
							within
								Inactive)
						
					
					endmodule
					----------------------------------------------------------------------
					
					
					TransitionSync = {|internal__.TID_State_machine_Init_t0|}
					
					--	Rule: behaviours(Node)
					--  Note that FDR has problems with efficiently compiling the process below
					-- 	if using a different recursion pattern.
					D__(id__) = 
					dbisim(let
						Inactive = (MStop /\ enter -> SKIP) ; true&(currentState.out!State_Init -> SKIP);true&CALL__disableHV(
									id__,
									false
								)
						 ; 
									Behaviour ; 
									SKIP ; 
									exited -> SKIP ; Inactive
					
					
						Behaviour = (
										(
											((
											 ((Body)
											  [[ up__ <- x__ | x__ <- {| up__,setR_errorAck,setR_lim,setR_overLimit,setR_errorFlag,setR_ActualHV,setR_power,setR_setPoint,setR_res,setR_supplyLim,setR_underLimit |} ]] 
											  [[set_errorAck <- setL_errorAck,set_lim <- setL_lim,set_overLimit <- setL_overLimit,set_errorFlag <- setL_errorFlag,set_ActualHV <- setL_ActualHV,set_power <- setL_power,set_setPoint <- setL_setPoint,set_res <- setL_res,set_supplyLim <- setL_supplyLim,set_underLimit <- setL_underLimit]]
											 )
											 [| union(union(enteredCSet,{| exit, exited |}),{|up__
											 			,setL_errorAck,setR_errorAck
											 			 			,setL_lim,setR_lim
											 			 			,setL_overLimit,setR_overLimit
											 			 			,setL_errorFlag,setR_errorFlag
											 			 			,setL_ActualHV,setR_ActualHV
											 			 			,setL_power,setR_power
											 			 			,setL_setPoint,setR_setPoint
											 			 			,setL_res,setR_res
											 			 			,setL_supplyLim,setR_supplyLim
											 			 			,setL_underLimit,setR_underLimit
											 			|}) |]
											 ((During)
											  [[ up__ <- x__ | x__ <- {| up__,setL_errorAck,setL_lim,setL_overLimit,setL_errorFlag,setL_ActualHV,setL_power,setL_setPoint,setL_res,setL_supplyLim,setL_underLimit |} ]]
											  [[set_errorAck <- setR_errorAck,set_lim <- setR_lim,set_overLimit <- setR_overLimit,set_errorFlag <- setR_errorFlag,set_ActualHV <- setR_ActualHV,set_power <- setR_power,set_setPoint <- setR_setPoint,set_res <- setR_res,set_supplyLim <- setR_supplyLim,set_underLimit <- setR_underLimit]]
											 )
											)[[setL_errorAck <- set_errorAck,setR_errorAck <- set_errorAck,setL_lim <- set_lim,setR_lim <- set_lim,setL_overLimit <- set_overLimit,setR_overLimit <- set_overLimit,setL_errorFlag <- set_errorFlag,setR_errorFlag <- set_errorFlag,setL_ActualHV <- set_ActualHV,setR_ActualHV <- set_ActualHV,setL_power <- set_power,setR_power <- set_power,setL_setPoint <- set_setPoint,setR_setPoint <- set_setPoint,setL_res <- set_res,setR_res <- set_res,setL_supplyLim <- set_supplyLim,setR_supplyLim <- set_supplyLim,setL_underLimit <- set_underLimit,setR_underLimit <- set_underLimit]]
											)\enteredCSet 
										[| {end__} |> SKIP
										) \ {end__}
									)
					
						Body = dbisim(((
						 (((ComposeNodes(id__)[[si0::exit <- x__ | x__ <- {|exit|}]]
						 [[i0::exit <- x__ | x__ <- {|internal__.TID_State_machine_Init_t0|}]]
						 [[  
						 si0::exited <- exited
						 ]]
						 ))
						  [[ up__ <- x__ | x__ <- {| up__ |} ]] 
						 )
						 [| union(union(union(enterCSet,TransitionSync),{| exit, exited |}),{|up__
						|}) |]
						 ((i0::enter -> 
						 	((dbisim(Transitions(id__)) /\ exit -> SKIP) ; (MStop /\ exited -> end__ -> SKIP)))
						  [[ up__ <- x__ | x__ <- {| up__ |} ]]
						 )
						)
						\ union(enterCSet,{| exited, internal__ |}))
						[[
							currentState__.x____ <- currentState,
							ext_setPoint__.x____ <- ext_setPoint,
							ext_pow24VStatus__.x____ <- ext_pow24VStatus,
							int_overLimit__.x____ <- int_overLimit,
							int_pwmSignal__.x____ <- int_pwmSignal,
							int_underLimit__.x____ <- int_underLimit,
							int_DisableHV__.x____ <- int_DisableHV,
							int_ActualHV__.x____ <- int_ActualHV
							| x____ <- TIDS
						]]
						[[
							OP_disableHV::int_pwmSignal__.x____ <- int_pwmSignal
							| x____ <- OP_disableHV::TIDS
						]]
						[[
							OP_supplyVoltCheck::ext_setPoint__.x____ <- ext_setPoint,
							OP_supplyVoltCheck::ext_pow24VStatus__.x____ <- ext_pow24VStatus
							| x____ <- OP_supplyVoltCheck::TIDS
						]]
						[[
							OP_checkLimits::ext_setPoint__.x____ <- ext_setPoint,
							OP_checkLimits::ext_pow24VStatus__.x____ <- ext_pow24VStatus
							| x____ <- OP_checkLimits::TIDS
						]]
						)
					
						During = (MStop /\ ([] e : enteredCSet @ e -> SKIP))
								 ; entered -> ((CRUN(enteredCSet) ||| SKIP ; MStop) /\ exit -> SKIP)
					within
						Inactive)
						
					VS_O__(id__) = 
						dbisim(let
							Inactive = (MStop /\ enter -> SKIP) ; true&(currentState.out!State_Init -> SKIP);true&CALL__disableHV(
										id__,
										false
									)
							 ; 
										Behaviour ; 
										SKIP ; 
										exited -> SKIP ; Inactive
					
					
						Behaviour = (
										(
											((
											 ((Body)
											  [[ up__ <- x__ | x__ <- {| up__,setR_errorAck,setR_lim,setR_overLimit,setR_errorFlag,setR_ActualHV,setR_power,setR_setPoint,setR_res,setR_supplyLim,setR_underLimit |} ]] 
											  [[set_errorAck <- setL_errorAck,set_lim <- setL_lim,set_overLimit <- setL_overLimit,set_errorFlag <- setL_errorFlag,set_ActualHV <- setL_ActualHV,set_power <- setL_power,set_setPoint <- setL_setPoint,set_res <- setL_res,set_supplyLim <- setL_supplyLim,set_underLimit <- setL_underLimit]]
											 )
											 [| union(union(enteredCSet,{| exit, exited |}),{|up__
											 			,setL_errorAck,setR_errorAck
											 			 			,setL_lim,setR_lim
											 			 			,setL_overLimit,setR_overLimit
											 			 			,setL_errorFlag,setR_errorFlag
											 			 			,setL_ActualHV,setR_ActualHV
											 			 			,setL_power,setR_power
											 			 			,setL_setPoint,setR_setPoint
											 			 			,setL_res,setR_res
											 			 			,setL_supplyLim,setR_supplyLim
											 			 			,setL_underLimit,setR_underLimit
											 			|}) |]
											 ((During)
											  [[ up__ <- x__ | x__ <- {| up__,setL_errorAck,setL_lim,setL_overLimit,setL_errorFlag,setL_ActualHV,setL_power,setL_setPoint,setL_res,setL_supplyLim,setL_underLimit |} ]]
											  [[set_errorAck <- setR_errorAck,set_lim <- setR_lim,set_overLimit <- setR_overLimit,set_errorFlag <- setR_errorFlag,set_ActualHV <- setR_ActualHV,set_power <- setR_power,set_setPoint <- setR_setPoint,set_res <- setR_res,set_supplyLim <- setR_supplyLim,set_underLimit <- setR_underLimit]]
											 )
											)[[setL_errorAck <- set_errorAck,setR_errorAck <- set_errorAck,setL_lim <- set_lim,setR_lim <- set_lim,setL_overLimit <- set_overLimit,setR_overLimit <- set_overLimit,setL_errorFlag <- set_errorFlag,setR_errorFlag <- set_errorFlag,setL_ActualHV <- set_ActualHV,setR_ActualHV <- set_ActualHV,setL_power <- set_power,setR_power <- set_power,setL_setPoint <- set_setPoint,setR_setPoint <- set_setPoint,setL_res <- set_res,setR_res <- set_res,setL_supplyLim <- set_supplyLim,setR_supplyLim <- set_supplyLim,setL_underLimit <- set_underLimit,setR_underLimit <- set_underLimit]]
											) 
										[| {end__} |> SKIP
										) \ {end__}
									)
					
						Body = dbisim(((
						 (((ComposeNodes_VS_O(id__)[[si0::exit <- x__ | x__ <- {|exit|}]]
						 [[i0::exit <- x__ | x__ <- {|internal__.TID_State_machine_Init_t0|}]]
						 [[  
						 si0::exited <- exited
						 ]]
						 ))
						  [[ up__ <- x__ | x__ <- {| up__ |} ]] 
						 )
						 [| union(union(union(enterCSet,TransitionSync),{| exit, exited |}),{|up__
						|}) |]
						 ((i0::enter -> 
						 	((dbisim(Transitions(id__)) /\ exit -> SKIP) ; (MStop /\ exited -> end__ -> SKIP)))
						  [[ up__ <- x__ | x__ <- {| up__ |} ]]
						 )
						)
						\ union(enterCSet,{| exited, internal__ |}))
						[[
							currentState__.x____ <- currentState,
							ext_setPoint__.x____ <- ext_setPoint,
							ext_pow24VStatus__.x____ <- ext_pow24VStatus,
							int_overLimit__.x____ <- int_overLimit,
							int_pwmSignal__.x____ <- int_pwmSignal,
							int_underLimit__.x____ <- int_underLimit,
							int_DisableHV__.x____ <- int_DisableHV,
							int_ActualHV__.x____ <- int_ActualHV
							| x____ <- TIDS
						]]
						[[
							OP_disableHV::int_pwmSignal__.x____ <- int_pwmSignal
							| x____ <- OP_disableHV::TIDS
						]]
						[[
							OP_supplyVoltCheck::ext_setPoint__.x____ <- ext_setPoint,
							OP_supplyVoltCheck::ext_pow24VStatus__.x____ <- ext_pow24VStatus
							| x____ <- OP_supplyVoltCheck::TIDS
						]]
						[[
							OP_checkLimits::ext_setPoint__.x____ <- ext_setPoint,
							OP_checkLimits::ext_pow24VStatus__.x____ <- ext_pow24VStatus
							| x____ <- OP_checkLimits::TIDS
						]]
						)
					
						During = (MStop /\ ([] e : enteredCSet @ e -> SKIP))
								 ; entered -> ((CRUN(enteredCSet) ||| SKIP ; MStop) /\ exit -> SKIP)
						within
							Inactive)
					
					Transitions(id__) = (up__ -> SKIP
					[] dbisim((true)&(internal__!TID_State_machine_Init_t0 -> SKIP ;  ((true&(ext_setPoint.in?setPoint -> set_setPoint!setPoint -> SKIP)
					 ; si0::enter -> SKIP))))
					)
					 ; Transitions(id__)
					
					ComposeNodes(id__) = [| { up__ } |] proc__ : {i0::D__(id__),si0::D__(id__)} @ proc__
					
					ComposeNodes_VS_O(id__) = [| { up__ } |] proc__ : {i0::VS_O__(id__),si0::VS_O__(id__)} @ proc__
				
				endmodule
				----------------------------------------------------------------------
				
				
				----------------------------------------------------------------------
				-- State: Wait24Vpower
				module Wait24Vpower
				
				enterCSet = 
						{|			i0::enter,
							si0::enter,
							s1::enter
						|}
				enteredCSet = 
						{|			si0::entered,
							s1::entered
						|}
				exports
				
					--  Declarations
					-- declaring identifiers of transitions
					datatype TIDS = NULLTRANSITION__
					              | TID_State_machine_Wait24Vpower_t0
					              | TID_State_machine_Wait24Vpower_t1
					
					channel internal__ : TIDS
					channel enter, entered, exit, exited
					channel enteredL, enteredR
					channel end__
					
									
					channel currentState__: TIDS.InOut.State
					channel ext_setPoint__: TIDS.InOut.core_real
					channel ext_pow24VStatus__: TIDS.InOut.Power
					channel int_overLimit__: TIDS.InOut.core_real
					channel int_pwmSignal__: TIDS.InOut.Power
					channel int_underLimit__: TIDS.InOut.core_real
					channel int_DisableHV__: TIDS.InOut
					channel int_ActualHV__: TIDS.InOut.core_real
					
					--	Nodes
					-- declaring all nodes
					
					----------------------------------------------------------------------
					-- Initial: i0
					module i0
					exports
					
						channel enter, exit
						
						D__(id__) = dbisim(let
									Inactive = (MStop /\ enter -> SKIP) ; (MStop /\ exit -> Inactive)
								within
									Inactive)
									
						VS_O__(id__) = D__(id__)
					
					endmodule
					----------------------------------------------------------------------
					
					
					----------------------------------------------------------------------
					-- State: si0
					module si0
					
					enterCSet = {}
					
					enteredCSet = {}
					
					exports
					
						--  Declarations
						-- declaring identifiers of transitions
						datatype TIDS = NULLTRANSITION__
						
						channel internal__ : TIDS
						channel enter, entered, exit, exited
						channel enteredL, enteredR
						channel end__
						
										
						
						--	Nodes
						-- declaring all nodes
						
						TransitionSync = {||}
						
						--	Rule: behaviours(Node)
						--  Note that FDR has problems with efficiently compiling the process below
						-- 	if using a different recursion pattern.
						D__(id__) = 
						dbisim(let
							Inactive = (MStop /\ enter -> SKIP) ; true&CALL__supplyVoltCheck(
										id__
									)
							 ; 
										Behaviour ; 
										SKIP ; 
										exited -> SKIP ; Inactive
						
							Behaviour = entered -> ((SKIP ; MStop) /\ exit -> SKIP)
						within
							Inactive)
							
						VS_O__(id__) = 
							dbisim(let
								Inactive = (MStop /\ enter -> SKIP) ; true&CALL__supplyVoltCheck(
											id__
										)
								 ; 
											Behaviour ; 
											SKIP ; 
											exited -> SKIP ; Inactive
						
								Behaviour = entered -> ((SKIP ; MStop) /\ exit -> SKIP)
							within
								Inactive)
						
					
					endmodule
					----------------------------------------------------------------------
					
					
					----------------------------------------------------------------------
					-- State: s1
					module s1
					
					enterCSet = {}
					
					enteredCSet = {}
					
					exports
					
						--  Declarations
						-- declaring identifiers of transitions
						datatype TIDS = NULLTRANSITION__
						
						channel internal__ : TIDS
						channel enter, entered, exit, exited
						channel enteredL, enteredR
						channel end__
						
										
						
						--	Nodes
						-- declaring all nodes
						
						TransitionSync = {||}
						
						--	Rule: behaviours(Node)
						--  Note that FDR has problems with efficiently compiling the process below
						-- 	if using a different recursion pattern.
						D__(id__) = 
						dbisim(let
							Inactive = (MStop /\ enter -> SKIP) ; true&CALL__disableHV(
										id__,
										true
									)
							 ; 
										Behaviour ; 
										SKIP ; 
										exited -> SKIP ; Inactive
						
							Behaviour = entered -> ((SKIP ; MStop) /\ exit -> SKIP)
						within
							Inactive)
							
						VS_O__(id__) = 
							dbisim(let
								Inactive = (MStop /\ enter -> SKIP) ; true&CALL__disableHV(
											id__,
											true
										)
								 ; 
											Behaviour ; 
											SKIP ; 
											exited -> SKIP ; Inactive
						
								Behaviour = entered -> ((SKIP ; MStop) /\ exit -> SKIP)
							within
								Inactive)
						
					
					endmodule
					----------------------------------------------------------------------
					
					
					TransitionSync = {|internal__.TID_State_machine_Wait24Vpower_t0,
					internal__.TID_State_machine_Wait24Vpower_t1|}
					
					--	Rule: behaviours(Node)
					--  Note that FDR has problems with efficiently compiling the process below
					-- 	if using a different recursion pattern.
					D__(id__) = 
					dbisim(let
						Inactive = (MStop /\ enter -> SKIP) ; true&(currentState.out!State_Wait24Vpower -> SKIP);true&CALL__disableHV(
									id__,
									false
								)
						 ; 
									Behaviour ; 
									SKIP ; 
									exited -> SKIP ; Inactive
					
					
						Behaviour = (
										(
											((
											 ((Body)
											  [[ up__ <- x__ | x__ <- {| up__,setR_errorAck,setR_lim,setR_overLimit,setR_errorFlag,setR_ActualHV,setR_power,setR_setPoint,setR_res,setR_supplyLim,setR_underLimit |} ]] 
											  [[set_errorAck <- setL_errorAck,set_lim <- setL_lim,set_overLimit <- setL_overLimit,set_errorFlag <- setL_errorFlag,set_ActualHV <- setL_ActualHV,set_power <- setL_power,set_setPoint <- setL_setPoint,set_res <- setL_res,set_supplyLim <- setL_supplyLim,set_underLimit <- setL_underLimit]]
											 )
											 [| union(union(enteredCSet,{| exit, exited |}),{|up__
											 			,setL_errorAck,setR_errorAck
											 			 			,setL_lim,setR_lim
											 			 			,setL_overLimit,setR_overLimit
											 			 			,setL_errorFlag,setR_errorFlag
											 			 			,setL_ActualHV,setR_ActualHV
											 			 			,setL_power,setR_power
											 			 			,setL_setPoint,setR_setPoint
											 			 			,setL_res,setR_res
											 			 			,setL_supplyLim,setR_supplyLim
											 			 			,setL_underLimit,setR_underLimit
											 			|}) |]
											 ((During)
											  [[ up__ <- x__ | x__ <- {| up__,setL_errorAck,setL_lim,setL_overLimit,setL_errorFlag,setL_ActualHV,setL_power,setL_setPoint,setL_res,setL_supplyLim,setL_underLimit |} ]]
											  [[set_errorAck <- setR_errorAck,set_lim <- setR_lim,set_overLimit <- setR_overLimit,set_errorFlag <- setR_errorFlag,set_ActualHV <- setR_ActualHV,set_power <- setR_power,set_setPoint <- setR_setPoint,set_res <- setR_res,set_supplyLim <- setR_supplyLim,set_underLimit <- setR_underLimit]]
											 )
											)[[setL_errorAck <- set_errorAck,setR_errorAck <- set_errorAck,setL_lim <- set_lim,setR_lim <- set_lim,setL_overLimit <- set_overLimit,setR_overLimit <- set_overLimit,setL_errorFlag <- set_errorFlag,setR_errorFlag <- set_errorFlag,setL_ActualHV <- set_ActualHV,setR_ActualHV <- set_ActualHV,setL_power <- set_power,setR_power <- set_power,setL_setPoint <- set_setPoint,setR_setPoint <- set_setPoint,setL_res <- set_res,setR_res <- set_res,setL_supplyLim <- set_supplyLim,setR_supplyLim <- set_supplyLim,setL_underLimit <- set_underLimit,setR_underLimit <- set_underLimit]]
											)\enteredCSet 
										[| {end__} |> SKIP
										) \ {end__}
									)
					
						Body = dbisim(((
						 (((ComposeNodes(id__)[[si0::exit <- x__ | x__ <- {|exit,internal__.TID_State_machine_Wait24Vpower_t1|}]]
						 [[s1::exit <- x__ | x__ <- {|exit|}]]
						 [[i0::exit <- x__ | x__ <- {|internal__.TID_State_machine_Wait24Vpower_t0|}]]
						 [[  
						 si0::exited <- exited,
						 s1::exited <- exited
						 ]]
						 ))
						  [[ up__ <- x__ | x__ <- {| up__ |} ]] 
						  [[set_lim <- setL_lim,set_setPoint <- setL_setPoint]]
						 )
						 [| union(union(union(enterCSet,TransitionSync),{| exit, exited |}),{|up__
						 			,setL_lim
						 			,setL_setPoint
						|}) |]
						 ((i0::enter -> 
						 	((dbisim(Transitions(id__)) /\ exit -> SKIP) ; (MStop /\ exited -> end__ -> SKIP)))
						  [[ up__ <- x__ | x__ <- {| up__,setL_lim,setL_setPoint |} ]]
						 )
						)[[setL_lim <- set_lim,setL_setPoint <- set_setPoint]]
						\ union(enterCSet,{| exited, internal__ |}))
						[[
							currentState__.x____ <- currentState,
							ext_setPoint__.x____ <- ext_setPoint,
							ext_pow24VStatus__.x____ <- ext_pow24VStatus,
							int_overLimit__.x____ <- int_overLimit,
							int_pwmSignal__.x____ <- int_pwmSignal,
							int_underLimit__.x____ <- int_underLimit,
							int_DisableHV__.x____ <- int_DisableHV,
							int_ActualHV__.x____ <- int_ActualHV
							| x____ <- TIDS
						]]
						[[
							OP_disableHV::int_pwmSignal__.x____ <- int_pwmSignal
							| x____ <- OP_disableHV::TIDS
						]]
						[[
							OP_supplyVoltCheck::ext_setPoint__.x____ <- ext_setPoint,
							OP_supplyVoltCheck::ext_pow24VStatus__.x____ <- ext_pow24VStatus
							| x____ <- OP_supplyVoltCheck::TIDS
						]]
						[[
							OP_checkLimits::ext_setPoint__.x____ <- ext_setPoint,
							OP_checkLimits::ext_pow24VStatus__.x____ <- ext_pow24VStatus
							| x____ <- OP_checkLimits::TIDS
						]]
						)
					
						During = (MStop /\ ([] e : enteredCSet @ e -> SKIP))
								 ; entered -> ((CRUN(enteredCSet) ||| SKIP ; MStop) /\ exit -> SKIP)
					within
						Inactive)
						
					VS_O__(id__) = 
						dbisim(let
							Inactive = (MStop /\ enter -> SKIP) ; true&(currentState.out!State_Wait24Vpower -> SKIP);true&CALL__disableHV(
										id__,
										false
									)
							 ; 
										Behaviour ; 
										SKIP ; 
										exited -> SKIP ; Inactive
					
					
						Behaviour = (
										(
											((
											 ((Body)
											  [[ up__ <- x__ | x__ <- {| up__,setR_errorAck,setR_lim,setR_overLimit,setR_errorFlag,setR_ActualHV,setR_power,setR_setPoint,setR_res,setR_supplyLim,setR_underLimit |} ]] 
											  [[set_errorAck <- setL_errorAck,set_lim <- setL_lim,set_overLimit <- setL_overLimit,set_errorFlag <- setL_errorFlag,set_ActualHV <- setL_ActualHV,set_power <- setL_power,set_setPoint <- setL_setPoint,set_res <- setL_res,set_supplyLim <- setL_supplyLim,set_underLimit <- setL_underLimit]]
											 )
											 [| union(union(enteredCSet,{| exit, exited |}),{|up__
											 			,setL_errorAck,setR_errorAck
											 			 			,setL_lim,setR_lim
											 			 			,setL_overLimit,setR_overLimit
											 			 			,setL_errorFlag,setR_errorFlag
											 			 			,setL_ActualHV,setR_ActualHV
											 			 			,setL_power,setR_power
											 			 			,setL_setPoint,setR_setPoint
											 			 			,setL_res,setR_res
											 			 			,setL_supplyLim,setR_supplyLim
											 			 			,setL_underLimit,setR_underLimit
											 			|}) |]
											 ((During)
											  [[ up__ <- x__ | x__ <- {| up__,setL_errorAck,setL_lim,setL_overLimit,setL_errorFlag,setL_ActualHV,setL_power,setL_setPoint,setL_res,setL_supplyLim,setL_underLimit |} ]]
											  [[set_errorAck <- setR_errorAck,set_lim <- setR_lim,set_overLimit <- setR_overLimit,set_errorFlag <- setR_errorFlag,set_ActualHV <- setR_ActualHV,set_power <- setR_power,set_setPoint <- setR_setPoint,set_res <- setR_res,set_supplyLim <- setR_supplyLim,set_underLimit <- setR_underLimit]]
											 )
											)[[setL_errorAck <- set_errorAck,setR_errorAck <- set_errorAck,setL_lim <- set_lim,setR_lim <- set_lim,setL_overLimit <- set_overLimit,setR_overLimit <- set_overLimit,setL_errorFlag <- set_errorFlag,setR_errorFlag <- set_errorFlag,setL_ActualHV <- set_ActualHV,setR_ActualHV <- set_ActualHV,setL_power <- set_power,setR_power <- set_power,setL_setPoint <- set_setPoint,setR_setPoint <- set_setPoint,setL_res <- set_res,setR_res <- set_res,setL_supplyLim <- set_supplyLim,setR_supplyLim <- set_supplyLim,setL_underLimit <- set_underLimit,setR_underLimit <- set_underLimit]]
											) 
										[| {end__} |> SKIP
										) \ {end__}
									)
					
						Body = dbisim(((
						 (((ComposeNodes_VS_O(id__)[[si0::exit <- x__ | x__ <- {|exit,internal__.TID_State_machine_Wait24Vpower_t1|}]]
						 [[s1::exit <- x__ | x__ <- {|exit|}]]
						 [[i0::exit <- x__ | x__ <- {|internal__.TID_State_machine_Wait24Vpower_t0|}]]
						 [[  
						 si0::exited <- exited,
						 s1::exited <- exited
						 ]]
						 ))
						  [[ up__ <- x__ | x__ <- {| up__ |} ]] 
						  [[set_lim <- setL_lim,set_setPoint <- setL_setPoint]]
						 )
						 [| union(union(union(enterCSet,TransitionSync),{| exit, exited |}),{|up__
						 			,setL_lim
						 			,setL_setPoint
						|}) |]
						 ((i0::enter -> 
						 	((dbisim(Transitions(id__)) /\ exit -> SKIP) ; (MStop /\ exited -> end__ -> SKIP)))
						  [[ up__ <- x__ | x__ <- {| up__,setL_lim,setL_setPoint |} ]]
						 )
						)[[setL_lim <- set_lim,setL_setPoint <- set_setPoint]]
						\ union(enterCSet,{| exited, internal__ |}))
						[[
							currentState__.x____ <- currentState,
							ext_setPoint__.x____ <- ext_setPoint,
							ext_pow24VStatus__.x____ <- ext_pow24VStatus,
							int_overLimit__.x____ <- int_overLimit,
							int_pwmSignal__.x____ <- int_pwmSignal,
							int_underLimit__.x____ <- int_underLimit,
							int_DisableHV__.x____ <- int_DisableHV,
							int_ActualHV__.x____ <- int_ActualHV
							| x____ <- TIDS
						]]
						[[
							OP_disableHV::int_pwmSignal__.x____ <- int_pwmSignal
							| x____ <- OP_disableHV::TIDS
						]]
						[[
							OP_supplyVoltCheck::ext_setPoint__.x____ <- ext_setPoint,
							OP_supplyVoltCheck::ext_pow24VStatus__.x____ <- ext_pow24VStatus
							| x____ <- OP_supplyVoltCheck::TIDS
						]]
						[[
							OP_checkLimits::ext_setPoint__.x____ <- ext_setPoint,
							OP_checkLimits::ext_pow24VStatus__.x____ <- ext_pow24VStatus
							| x____ <- OP_checkLimits::TIDS
						]]
						)
					
						During = (MStop /\ ([] e : enteredCSet @ e -> SKIP))
								 ; entered -> ((CRUN(enteredCSet) ||| SKIP ; MStop) /\ exit -> SKIP)
						within
							Inactive)
					
					Transitions(id__) = get_lim?lim -> get_setPoint?setPoint -> (up__ -> SKIP
					[] dbisim((true)&(internal__!TID_State_machine_Wait24Vpower_t0 -> SKIP ;  ((true&(ext_setPoint.in?setPoint -> set_setPoint!setPoint -> SKIP)
					 ; si0::enter -> SKIP))))
					[] dbisim((((setPoint!=0) or (lim==true)))&(internal__!TID_State_machine_Wait24Vpower_t1 -> SKIP ;  ((MStop /\ exited -> SKIP) ; SKIP
					 ; s1::enter -> SKIP)))
					)
					 ; Transitions(id__)
					
					ComposeNodes(id__) = [| { up__ } |] proc__ : {i0::D__(id__),si0::D__(id__),s1::D__(id__)} @ proc__
					
					ComposeNodes_VS_O(id__) = [| { up__ } |] proc__ : {i0::VS_O__(id__),si0::VS_O__(id__),s1::VS_O__(id__)} @ proc__
				
				endmodule
				----------------------------------------------------------------------
				
				
				----------------------------------------------------------------------
				-- State: ClosedLoop
				module ClosedLoop
				
				enterCSet = 
						{|			i0::enter,
							s1::enter,
							s2::enter,
							s3::enter,
							s4::enter
						|}
				enteredCSet = 
						{|			s1::entered,
							s2::entered,
							s3::entered,
							s4::entered
						|}
				exports
				
					--  Declarations
					-- declaring identifiers of transitions
					datatype TIDS = NULLTRANSITION__
					              | TID_State_machine_ClosedLoop_t1
					              | TID_State_machine_ClosedLoop_t2
					              | TID_State_machine_ClosedLoop_t3
					              | TID_State_machine_ClosedLoop_t4
					              | TID_State_machine_ClosedLoop_t5
					              | TID_State_machine_ClosedLoop_t0
					
					channel internal__ : TIDS
					channel enter, entered, exit, exited
					channel enteredL, enteredR
					channel end__
					
									
					channel currentState__: TIDS.InOut.State
					channel ext_setPoint__: TIDS.InOut.core_real
					channel ext_pow24VStatus__: TIDS.InOut.Power
					channel int_overLimit__: TIDS.InOut.core_real
					channel int_pwmSignal__: TIDS.InOut.Power
					channel int_underLimit__: TIDS.InOut.core_real
					channel int_DisableHV__: TIDS.InOut
					channel int_ActualHV__: TIDS.InOut.core_real
					
					--	Nodes
					-- declaring all nodes
					
					----------------------------------------------------------------------
					-- Initial: i0
					module i0
					exports
					
						channel enter, exit
						
						D__(id__) = dbisim(let
									Inactive = (MStop /\ enter -> SKIP) ; (MStop /\ exit -> Inactive)
								within
									Inactive)
									
						VS_O__(id__) = D__(id__)
					
					endmodule
					----------------------------------------------------------------------
					
					
					----------------------------------------------------------------------
					-- State: s1
					module s1
					
					enterCSet = {}
					
					enteredCSet = {}
					
					exports
					
						--  Declarations
						-- declaring identifiers of transitions
						datatype TIDS = NULLTRANSITION__
						
						channel internal__ : TIDS
						channel enter, entered, exit, exited
						channel enteredL, enteredR
						channel end__
						
										
						
						--	Nodes
						-- declaring all nodes
						
						TransitionSync = {||}
						
						--	Rule: behaviours(Node)
						--  Note that FDR has problems with efficiently compiling the process below
						-- 	if using a different recursion pattern.
						D__(id__) = 
						dbisim(let
							Inactive = (MStop /\ enter -> SKIP) ; true & (set_lim!false -> SKIP);true&CALL__disableHV(
										id__,
										true
									)
							 ; 
										Behaviour ; 
										SKIP ; 
										exited -> SKIP ; Inactive
						
							Behaviour = entered -> ((SKIP ; MStop) /\ exit -> SKIP)
						within
							Inactive)
							
						VS_O__(id__) = 
							dbisim(let
								Inactive = (MStop /\ enter -> SKIP) ; true & (set_lim!false -> SKIP);true&CALL__disableHV(
											id__,
											true
										)
								 ; 
											Behaviour ; 
											SKIP ; 
											exited -> SKIP ; Inactive
						
								Behaviour = entered -> ((SKIP ; MStop) /\ exit -> SKIP)
							within
								Inactive)
						
					
					endmodule
					----------------------------------------------------------------------
					
					
					----------------------------------------------------------------------
					-- State: s2
					module s2
					
					enterCSet = 
							{|			i0::enter,
								s0::enter,
								s1::enter,
								j0::enter
							|}
					enteredCSet = 
							{|			s0::entered,
								s1::entered
							|}
					exports
					
						--  Declarations
						-- declaring identifiers of transitions
						datatype TIDS = NULLTRANSITION__
						              | TID_State_machine_ClosedLoop_s2_t0
						              | TID_State_machine_ClosedLoop_s2_t1
						              | TID_State_machine_ClosedLoop_s2_t5
						              | TID_State_machine_ClosedLoop_s2_t2
						
						channel internal__ : TIDS
						channel enter, entered, exit, exited
						channel enteredL, enteredR
						channel end__
						
										
						channel currentState__: TIDS.InOut.State
						channel ext_setPoint__: TIDS.InOut.core_real
						channel ext_pow24VStatus__: TIDS.InOut.Power
						channel int_overLimit__: TIDS.InOut.core_real
						channel int_pwmSignal__: TIDS.InOut.Power
						channel int_underLimit__: TIDS.InOut.core_real
						channel int_DisableHV__: TIDS.InOut
						channel int_ActualHV__: TIDS.InOut.core_real
						
						--	Nodes
						-- declaring all nodes
						
						----------------------------------------------------------------------
						-- Initial: i0
						module i0
						exports
						
							channel enter, exit
							
							D__(id__) = dbisim(let
										Inactive = (MStop /\ enter -> SKIP) ; (MStop /\ exit -> Inactive)
									within
										Inactive)
										
							VS_O__(id__) = D__(id__)
						
						endmodule
						----------------------------------------------------------------------
						
						
						----------------------------------------------------------------------
						-- State: s0
						module s0
						
						enterCSet = {}
						
						enteredCSet = {}
						
						exports
						
							--  Declarations
							-- declaring identifiers of transitions
							datatype TIDS = NULLTRANSITION__
							
							channel internal__ : TIDS
							channel enter, entered, exit, exited
							channel enteredL, enteredR
							channel end__
							
											
							
							--	Nodes
							-- declaring all nodes
							
							TransitionSync = {||}
							
							--	Rule: behaviours(Node)
							--  Note that FDR has problems with efficiently compiling the process below
							-- 	if using a different recursion pattern.
							D__(id__) = 
							dbisim(let
								Inactive = (MStop /\ enter -> SKIP) ; true&CALL__checkLimits(
											id__
										)
								 ; 
											Behaviour ; 
											SKIP ; 
											exited -> SKIP ; Inactive
							
								Behaviour = entered -> ((SKIP ; MStop) /\ exit -> SKIP)
							within
								Inactive)
								
							VS_O__(id__) = 
								dbisim(let
									Inactive = (MStop /\ enter -> SKIP) ; true&CALL__checkLimits(
												id__
											)
									 ; 
												Behaviour ; 
												SKIP ; 
												exited -> SKIP ; Inactive
							
									Behaviour = entered -> ((SKIP ; MStop) /\ exit -> SKIP)
								within
									Inactive)
							
						
						endmodule
						----------------------------------------------------------------------
						
						
						----------------------------------------------------------------------
						-- State: s1
						module s1
						
						enterCSet = {}
						
						enteredCSet = {}
						
						exports
						
							--  Declarations
							-- declaring identifiers of transitions
							datatype TIDS = NULLTRANSITION__
							
							channel internal__ : TIDS
							channel enter, entered, exit, exited
							channel enteredL, enteredR
							channel end__
							
											
							
							--	Nodes
							-- declaring all nodes
							
							TransitionSync = {||}
							
							--	Rule: behaviours(Node)
							--  Note that FDR has problems with efficiently compiling the process below
							-- 	if using a different recursion pattern.
							D__(id__) = 
							dbisim(let
								Inactive = (MStop /\ enter -> SKIP) ; true&(ext_setPoint.in?setPoint -> set_setPoint!setPoint -> SKIP)
								 ; 
											Behaviour ; 
											SKIP ; 
											exited -> SKIP ; Inactive
							
								Behaviour = entered -> ((SKIP ; MStop) /\ exit -> SKIP)
							within
								Inactive)
								
							VS_O__(id__) = 
								dbisim(let
									Inactive = (MStop /\ enter -> SKIP) ; true&(ext_setPoint.in?setPoint -> set_setPoint!setPoint -> SKIP)
									 ; 
												Behaviour ; 
												SKIP ; 
												exited -> SKIP ; Inactive
							
									Behaviour = entered -> ((SKIP ; MStop) /\ exit -> SKIP)
								within
									Inactive)
							
						
						endmodule
						----------------------------------------------------------------------
						
						
						----------------------------------------------------------------------
						-- Junction: j0
						module j0
						exports
						
							channel enter, exit
							
							D__(id__) = dbisim(let
								Inactive = (MStop /\ enter -> SKIP) ; (MStop /\ exit -> Inactive)
							within
								Inactive)
								
							VS_O__(id__) = D__(id__)
						
						endmodule
						----------------------------------------------------------------------
						
						
						TransitionSync = {|internal__.TID_State_machine_ClosedLoop_s2_t0,
						internal__.TID_State_machine_ClosedLoop_s2_t1,
						internal__.TID_State_machine_ClosedLoop_s2_t5,
						internal__.TID_State_machine_ClosedLoop_s2_t2|}
						
						--	Rule: behaviours(Node)
						--  Note that FDR has problems with efficiently compiling the process below
						-- 	if using a different recursion pattern.
						D__(id__) = 
						dbisim(let
							Inactive = (MStop /\ enter -> SKIP) ; SKIP ; 
										Behaviour ; 
										SKIP ; 
										exited -> SKIP ; Inactive
						
						
							Behaviour = (
											(
												((
												 ((Body)
												  [[ up__ <- x__ | x__ <- {| up__,setR_errorAck,setR_lim,setR_overLimit,setR_errorFlag,setR_ActualHV,setR_power,setR_setPoint,setR_res,setR_supplyLim,setR_underLimit |} ]] 
												  [[set_errorAck <- setL_errorAck,set_lim <- setL_lim,set_overLimit <- setL_overLimit,set_errorFlag <- setL_errorFlag,set_ActualHV <- setL_ActualHV,set_power <- setL_power,set_setPoint <- setL_setPoint,set_res <- setL_res,set_supplyLim <- setL_supplyLim,set_underLimit <- setL_underLimit]]
												 )
												 [| union(union(enteredCSet,{| exit, exited |}),{|up__
												 			,setL_errorAck,setR_errorAck
												 			 			,setL_lim,setR_lim
												 			 			,setL_overLimit,setR_overLimit
												 			 			,setL_errorFlag,setR_errorFlag
												 			 			,setL_ActualHV,setR_ActualHV
												 			 			,setL_power,setR_power
												 			 			,setL_setPoint,setR_setPoint
												 			 			,setL_res,setR_res
												 			 			,setL_supplyLim,setR_supplyLim
												 			 			,setL_underLimit,setR_underLimit
												 			|}) |]
												 ((During)
												  [[ up__ <- x__ | x__ <- {| up__,setL_errorAck,setL_lim,setL_overLimit,setL_errorFlag,setL_ActualHV,setL_power,setL_setPoint,setL_res,setL_supplyLim,setL_underLimit |} ]]
												  [[set_errorAck <- setR_errorAck,set_lim <- setR_lim,set_overLimit <- setR_overLimit,set_errorFlag <- setR_errorFlag,set_ActualHV <- setR_ActualHV,set_power <- setR_power,set_setPoint <- setR_setPoint,set_res <- setR_res,set_supplyLim <- setR_supplyLim,set_underLimit <- setR_underLimit]]
												 )
												)[[setL_errorAck <- set_errorAck,setR_errorAck <- set_errorAck,setL_lim <- set_lim,setR_lim <- set_lim,setL_overLimit <- set_overLimit,setR_overLimit <- set_overLimit,setL_errorFlag <- set_errorFlag,setR_errorFlag <- set_errorFlag,setL_ActualHV <- set_ActualHV,setR_ActualHV <- set_ActualHV,setL_power <- set_power,setR_power <- set_power,setL_setPoint <- set_setPoint,setR_setPoint <- set_setPoint,setL_res <- set_res,setR_res <- set_res,setL_supplyLim <- set_supplyLim,setR_supplyLim <- set_supplyLim,setL_underLimit <- set_underLimit,setR_underLimit <- set_underLimit]]
												)\enteredCSet 
											[| {end__} |> SKIP
											) \ {end__}
										)
						
							Body = dbisim(((
							 (((ComposeNodes(id__)[[s0::exit <- x__ | x__ <- {|exit,internal__.TID_State_machine_ClosedLoop_s2_t1|}]]
							 [[s1::exit <- x__ | x__ <- {|exit,internal__.TID_State_machine_ClosedLoop_s2_t2|}]]
							 [[i0::exit <- x__ | x__ <- {|internal__.TID_State_machine_ClosedLoop_s2_t0|}]]
							 [[j0::exit <- x__ | x__ <- {|internal__.TID_State_machine_ClosedLoop_s2_t5|}]]
							 [[  
							 s0::exited <- exited,
							 s1::exited <- exited
							 ]]
							 ))
							  [[ up__ <- x__ | x__ <- {| up__ |} ]] 
							 )
							 [| union(union(union(enterCSet,TransitionSync),{| exit, exited |}),{|up__
							|}) |]
							 ((i0::enter -> 
							 	((dbisim(Transitions(id__)) /\ exit -> SKIP) ; (MStop /\ exited -> end__ -> SKIP)))
							  [[ up__ <- x__ | x__ <- {| up__ |} ]]
							 )
							)
							\ union(enterCSet,{| exited, internal__ |}))
							[[
								currentState__.x____ <- currentState,
								ext_setPoint__.x____ <- ext_setPoint,
								ext_pow24VStatus__.x____ <- ext_pow24VStatus,
								int_overLimit__.x____ <- int_overLimit,
								int_pwmSignal__.x____ <- int_pwmSignal,
								int_underLimit__.x____ <- int_underLimit,
								int_DisableHV__.x____ <- int_DisableHV,
								int_ActualHV__.x____ <- int_ActualHV
								| x____ <- TIDS
							]]
							[[
								OP_disableHV::int_pwmSignal__.x____ <- int_pwmSignal
								| x____ <- OP_disableHV::TIDS
							]]
							[[
								OP_supplyVoltCheck::ext_setPoint__.x____ <- ext_setPoint,
								OP_supplyVoltCheck::ext_pow24VStatus__.x____ <- ext_pow24VStatus
								| x____ <- OP_supplyVoltCheck::TIDS
							]]
							[[
								OP_checkLimits::ext_setPoint__.x____ <- ext_setPoint,
								OP_checkLimits::ext_pow24VStatus__.x____ <- ext_pow24VStatus
								| x____ <- OP_checkLimits::TIDS
							]]
							)
						
							During = (MStop /\ ([] e : enteredCSet @ e -> SKIP))
									 ; entered -> ((CRUN(enteredCSet) ||| SKIP ; MStop) /\ exit -> SKIP)
						within
							Inactive)
							
						VS_O__(id__) = 
							dbisim(let
								Inactive = (MStop /\ enter -> SKIP) ; SKIP ; 
											Behaviour ; 
											SKIP ; 
											exited -> SKIP ; Inactive
						
						
							Behaviour = (
											(
												((
												 ((Body)
												  [[ up__ <- x__ | x__ <- {| up__,setR_errorAck,setR_lim,setR_overLimit,setR_errorFlag,setR_ActualHV,setR_power,setR_setPoint,setR_res,setR_supplyLim,setR_underLimit |} ]] 
												  [[set_errorAck <- setL_errorAck,set_lim <- setL_lim,set_overLimit <- setL_overLimit,set_errorFlag <- setL_errorFlag,set_ActualHV <- setL_ActualHV,set_power <- setL_power,set_setPoint <- setL_setPoint,set_res <- setL_res,set_supplyLim <- setL_supplyLim,set_underLimit <- setL_underLimit]]
												 )
												 [| union(union(enteredCSet,{| exit, exited |}),{|up__
												 			,setL_errorAck,setR_errorAck
												 			 			,setL_lim,setR_lim
												 			 			,setL_overLimit,setR_overLimit
												 			 			,setL_errorFlag,setR_errorFlag
												 			 			,setL_ActualHV,setR_ActualHV
												 			 			,setL_power,setR_power
												 			 			,setL_setPoint,setR_setPoint
												 			 			,setL_res,setR_res
												 			 			,setL_supplyLim,setR_supplyLim
												 			 			,setL_underLimit,setR_underLimit
												 			|}) |]
												 ((During)
												  [[ up__ <- x__ | x__ <- {| up__,setL_errorAck,setL_lim,setL_overLimit,setL_errorFlag,setL_ActualHV,setL_power,setL_setPoint,setL_res,setL_supplyLim,setL_underLimit |} ]]
												  [[set_errorAck <- setR_errorAck,set_lim <- setR_lim,set_overLimit <- setR_overLimit,set_errorFlag <- setR_errorFlag,set_ActualHV <- setR_ActualHV,set_power <- setR_power,set_setPoint <- setR_setPoint,set_res <- setR_res,set_supplyLim <- setR_supplyLim,set_underLimit <- setR_underLimit]]
												 )
												)[[setL_errorAck <- set_errorAck,setR_errorAck <- set_errorAck,setL_lim <- set_lim,setR_lim <- set_lim,setL_overLimit <- set_overLimit,setR_overLimit <- set_overLimit,setL_errorFlag <- set_errorFlag,setR_errorFlag <- set_errorFlag,setL_ActualHV <- set_ActualHV,setR_ActualHV <- set_ActualHV,setL_power <- set_power,setR_power <- set_power,setL_setPoint <- set_setPoint,setR_setPoint <- set_setPoint,setL_res <- set_res,setR_res <- set_res,setL_supplyLim <- set_supplyLim,setR_supplyLim <- set_supplyLim,setL_underLimit <- set_underLimit,setR_underLimit <- set_underLimit]]
												) 
											[| {end__} |> SKIP
											) \ {end__}
										)
						
							Body = dbisim(((
							 (((ComposeNodes_VS_O(id__)[[s0::exit <- x__ | x__ <- {|exit,internal__.TID_State_machine_ClosedLoop_s2_t1|}]]
							 [[s1::exit <- x__ | x__ <- {|exit,internal__.TID_State_machine_ClosedLoop_s2_t2|}]]
							 [[i0::exit <- x__ | x__ <- {|internal__.TID_State_machine_ClosedLoop_s2_t0|}]]
							 [[j0::exit <- x__ | x__ <- {|internal__.TID_State_machine_ClosedLoop_s2_t5|}]]
							 [[  
							 s0::exited <- exited,
							 s1::exited <- exited
							 ]]
							 ))
							  [[ up__ <- x__ | x__ <- {| up__ |} ]] 
							 )
							 [| union(union(union(enterCSet,TransitionSync),{| exit, exited |}),{|up__
							|}) |]
							 ((i0::enter -> 
							 	((dbisim(Transitions(id__)) /\ exit -> SKIP) ; (MStop /\ exited -> end__ -> SKIP)))
							  [[ up__ <- x__ | x__ <- {| up__ |} ]]
							 )
							)
							\ union(enterCSet,{| exited, internal__ |}))
							[[
								currentState__.x____ <- currentState,
								ext_setPoint__.x____ <- ext_setPoint,
								ext_pow24VStatus__.x____ <- ext_pow24VStatus,
								int_overLimit__.x____ <- int_overLimit,
								int_pwmSignal__.x____ <- int_pwmSignal,
								int_underLimit__.x____ <- int_underLimit,
								int_DisableHV__.x____ <- int_DisableHV,
								int_ActualHV__.x____ <- int_ActualHV
								| x____ <- TIDS
							]]
							[[
								OP_disableHV::int_pwmSignal__.x____ <- int_pwmSignal
								| x____ <- OP_disableHV::TIDS
							]]
							[[
								OP_supplyVoltCheck::ext_setPoint__.x____ <- ext_setPoint,
								OP_supplyVoltCheck::ext_pow24VStatus__.x____ <- ext_pow24VStatus
								| x____ <- OP_supplyVoltCheck::TIDS
							]]
							[[
								OP_checkLimits::ext_setPoint__.x____ <- ext_setPoint,
								OP_checkLimits::ext_pow24VStatus__.x____ <- ext_pow24VStatus
								| x____ <- OP_checkLimits::TIDS
							]]
							)
						
							During = (MStop /\ ([] e : enteredCSet @ e -> SKIP))
									 ; entered -> ((CRUN(enteredCSet) ||| SKIP ; MStop) /\ exit -> SKIP)
							within
								Inactive)
						
						Transitions(id__) = (up__ -> SKIP
						[] dbisim((true)&(internal__!TID_State_machine_ClosedLoop_s2_t0 -> SKIP ;  ((SKIP
						 ; s1::enter -> SKIP))))
						[] dbisim((true)&(internal__!TID_State_machine_ClosedLoop_s2_t1 -> SKIP ;  ((MStop /\ exited -> SKIP) ; SKIP
						 ; s1::enter -> SKIP)))
						[] dbisim((true)&(internal__!TID_State_machine_ClosedLoop_s2_t5 -> SKIP ;  ((get_ActualHV?ActualHV -> true&(int_ActualHV.out!ActualHV -> SKIP)
						 ; s0::enter -> SKIP))))
						[] dbisim((true)&(internal__!TID_State_machine_ClosedLoop_s2_t2 -> SKIP ;  ((MStop /\ exited -> SKIP) ; get_setPoint?setPoint -> true & (set_ActualHV!setPoint -> SKIP)
						 ; j0::enter -> SKIP)))
						)
						 ; Transitions(id__)
						
						ComposeNodes(id__) = [| { up__ } |] proc__ : {i0::D__(id__),s0::D__(id__),s1::D__(id__),j0::D__(id__)} @ proc__
						
						ComposeNodes_VS_O(id__) = [| { up__ } |] proc__ : {i0::VS_O__(id__),s0::VS_O__(id__),s1::VS_O__(id__),j0::VS_O__(id__)} @ proc__
					
					endmodule
					----------------------------------------------------------------------
					
					
					----------------------------------------------------------------------
					-- State: s3
					module s3
					
					enterCSet = {}
					
					enteredCSet = {}
					
					exports
					
						--  Declarations
						-- declaring identifiers of transitions
						datatype TIDS = NULLTRANSITION__
						
						channel internal__ : TIDS
						channel enter, entered, exit, exited
						channel enteredL, enteredR
						channel end__
						
										
						
						--	Nodes
						-- declaring all nodes
						
						TransitionSync = {||}
						
						--	Rule: behaviours(Node)
						--  Note that FDR has problems with efficiently compiling the process below
						-- 	if using a different recursion pattern.
						D__(id__) = 
						dbisim(let
							Inactive = (MStop /\ enter -> SKIP) ; true&CALL__checkLimits(
										id__
									)
							 ; 
										Behaviour ; 
										SKIP ; 
										exited -> SKIP ; Inactive
						
							Behaviour = entered -> ((SKIP ; MStop) /\ exit -> SKIP)
						within
							Inactive)
							
						VS_O__(id__) = 
							dbisim(let
								Inactive = (MStop /\ enter -> SKIP) ; true&CALL__checkLimits(
											id__
										)
								 ; 
											Behaviour ; 
											SKIP ; 
											exited -> SKIP ; Inactive
						
								Behaviour = entered -> ((SKIP ; MStop) /\ exit -> SKIP)
							within
								Inactive)
						
					
					endmodule
					----------------------------------------------------------------------
					
					
					----------------------------------------------------------------------
					-- State: s4
					module s4
					
					enterCSet = {}
					
					enteredCSet = {}
					
					exports
					
						--  Declarations
						-- declaring identifiers of transitions
						datatype TIDS = NULLTRANSITION__
						
						channel internal__ : TIDS
						channel enter, entered, exit, exited
						channel enteredL, enteredR
						channel end__
						
										
						
						--	Nodes
						-- declaring all nodes
						
						TransitionSync = {||}
						
						--	Rule: behaviours(Node)
						--  Note that FDR has problems with efficiently compiling the process below
						-- 	if using a different recursion pattern.
						D__(id__) = 
						dbisim(let
							Inactive = (MStop /\ enter -> SKIP) ; true&CALL__supplyVoltCheck(
										id__
									)
							 ; 
										Behaviour ; 
										SKIP ; 
										exited -> SKIP ; Inactive
						
							Behaviour = entered -> ((SKIP ; MStop) /\ exit -> SKIP)
						within
							Inactive)
							
						VS_O__(id__) = 
							dbisim(let
								Inactive = (MStop /\ enter -> SKIP) ; true&CALL__supplyVoltCheck(
											id__
										)
								 ; 
											Behaviour ; 
											SKIP ; 
											exited -> SKIP ; Inactive
						
								Behaviour = entered -> ((SKIP ; MStop) /\ exit -> SKIP)
							within
								Inactive)
						
					
					endmodule
					----------------------------------------------------------------------
					
					
					TransitionSync = {|internal__.TID_State_machine_ClosedLoop_t1,
					internal__.TID_State_machine_ClosedLoop_t2,
					internal__.TID_State_machine_ClosedLoop_t3,
					internal__.TID_State_machine_ClosedLoop_t4,
					internal__.TID_State_machine_ClosedLoop_t5,
					internal__.TID_State_machine_ClosedLoop_t0|}
					
					--	Rule: behaviours(Node)
					--  Note that FDR has problems with efficiently compiling the process below
					-- 	if using a different recursion pattern.
					D__(id__) = 
					dbisim(let
						Inactive = (MStop /\ enter -> SKIP) ; true&(currentState.out!State_ClosedLoop -> SKIP)
						 ; 
									Behaviour ; 
									SKIP ; 
									exited -> SKIP ; Inactive
					
					
						Behaviour = (
										(
											((
											 ((Body)
											  [[ up__ <- x__ | x__ <- {| up__,setR_errorAck,setR_lim,setR_overLimit,setR_errorFlag,setR_ActualHV,setR_power,setR_setPoint,setR_res,setR_supplyLim,setR_underLimit |} ]] 
											  [[set_errorAck <- setL_errorAck,set_lim <- setL_lim,set_overLimit <- setL_overLimit,set_errorFlag <- setL_errorFlag,set_ActualHV <- setL_ActualHV,set_power <- setL_power,set_setPoint <- setL_setPoint,set_res <- setL_res,set_supplyLim <- setL_supplyLim,set_underLimit <- setL_underLimit]]
											 )
											 [| union(union(enteredCSet,{| exit, exited |}),{|up__
											 			,setL_errorAck,setR_errorAck
											 			 			,setL_lim,setR_lim
											 			 			,setL_overLimit,setR_overLimit
											 			 			,setL_errorFlag,setR_errorFlag
											 			 			,setL_ActualHV,setR_ActualHV
											 			 			,setL_power,setR_power
											 			 			,setL_setPoint,setR_setPoint
											 			 			,setL_res,setR_res
											 			 			,setL_supplyLim,setR_supplyLim
											 			 			,setL_underLimit,setR_underLimit
											 			|}) |]
											 ((During)
											  [[ up__ <- x__ | x__ <- {| up__,setL_errorAck,setL_lim,setL_overLimit,setL_errorFlag,setL_ActualHV,setL_power,setL_setPoint,setL_res,setL_supplyLim,setL_underLimit |} ]]
											  [[set_errorAck <- setR_errorAck,set_lim <- setR_lim,set_overLimit <- setR_overLimit,set_errorFlag <- setR_errorFlag,set_ActualHV <- setR_ActualHV,set_power <- setR_power,set_setPoint <- setR_setPoint,set_res <- setR_res,set_supplyLim <- setR_supplyLim,set_underLimit <- setR_underLimit]]
											 )
											)[[setL_errorAck <- set_errorAck,setR_errorAck <- set_errorAck,setL_lim <- set_lim,setR_lim <- set_lim,setL_overLimit <- set_overLimit,setR_overLimit <- set_overLimit,setL_errorFlag <- set_errorFlag,setR_errorFlag <- set_errorFlag,setL_ActualHV <- set_ActualHV,setR_ActualHV <- set_ActualHV,setL_power <- set_power,setR_power <- set_power,setL_setPoint <- set_setPoint,setR_setPoint <- set_setPoint,setL_res <- set_res,setR_res <- set_res,setL_supplyLim <- set_supplyLim,setR_supplyLim <- set_supplyLim,setL_underLimit <- set_underLimit,setR_underLimit <- set_underLimit]]
											)\enteredCSet 
										[| {end__} |> SKIP
										) \ {end__}
									)
					
						Body = dbisim(((
						 (((ComposeNodes(id__)[[s1::exit <- x__ | x__ <- {|exit|}]]
						 [[s2::exit <- x__ | x__ <- {|exit,internal__.TID_State_machine_ClosedLoop_t2|}]]
						 [[s3::exit <- x__ | x__ <- {|exit,internal__.TID_State_machine_ClosedLoop_t4,internal__.TID_State_machine_ClosedLoop_t5|}]]
						 [[s4::exit <- x__ | x__ <- {|exit,internal__.TID_State_machine_ClosedLoop_t1,internal__.TID_State_machine_ClosedLoop_t3|}]]
						 [[i0::exit <- x__ | x__ <- {|internal__.TID_State_machine_ClosedLoop_t0|}]]
						 [[  
						 s1::exited <- exited,
						 s2::exited <- exited,
						 s3::exited <- exited,
						 s4::exited <- exited
						 ]]
						 ))
						  [[ up__ <- x__ | x__ <- {| up__ |} ]] 
						  [[set_lim <- setL_lim]]
						 )
						 [| union(union(union(enterCSet,TransitionSync),{| exit, exited |}),{|up__
						 			,setL_lim
						|}) |]
						 ((i0::enter -> 
						 	((dbisim(Transitions(id__)) /\ exit -> SKIP) ; (MStop /\ exited -> end__ -> SKIP)))
						  [[ up__ <- x__ | x__ <- {| up__,setL_lim |} ]]
						 )
						)[[setL_lim <- set_lim]]
						\ union(enterCSet,{| exited, internal__ |}))
						[[
							currentState__.x____ <- currentState,
							ext_setPoint__.x____ <- ext_setPoint,
							ext_pow24VStatus__.x____ <- ext_pow24VStatus,
							int_overLimit__.x____ <- int_overLimit,
							int_pwmSignal__.x____ <- int_pwmSignal,
							int_underLimit__.x____ <- int_underLimit,
							int_DisableHV__.x____ <- int_DisableHV,
							int_ActualHV__.x____ <- int_ActualHV
							| x____ <- TIDS
						]]
						[[
							OP_disableHV::int_pwmSignal__.x____ <- int_pwmSignal
							| x____ <- OP_disableHV::TIDS
						]]
						[[
							OP_supplyVoltCheck::ext_setPoint__.x____ <- ext_setPoint,
							OP_supplyVoltCheck::ext_pow24VStatus__.x____ <- ext_pow24VStatus
							| x____ <- OP_supplyVoltCheck::TIDS
						]]
						[[
							OP_checkLimits::ext_setPoint__.x____ <- ext_setPoint,
							OP_checkLimits::ext_pow24VStatus__.x____ <- ext_pow24VStatus
							| x____ <- OP_checkLimits::TIDS
						]]
						)
					
						During = (MStop /\ ([] e : enteredCSet @ e -> SKIP))
								 ; entered -> ((CRUN(enteredCSet) ||| SKIP ; MStop) /\ exit -> SKIP)
					within
						Inactive)
						
					VS_O__(id__) = 
						dbisim(let
							Inactive = (MStop /\ enter -> SKIP) ; true&(currentState.out!State_ClosedLoop -> SKIP)
							 ; 
										Behaviour ; 
										SKIP ; 
										exited -> SKIP ; Inactive
					
					
						Behaviour = (
										(
											((
											 ((Body)
											  [[ up__ <- x__ | x__ <- {| up__,setR_errorAck,setR_lim,setR_overLimit,setR_errorFlag,setR_ActualHV,setR_power,setR_setPoint,setR_res,setR_supplyLim,setR_underLimit |} ]] 
											  [[set_errorAck <- setL_errorAck,set_lim <- setL_lim,set_overLimit <- setL_overLimit,set_errorFlag <- setL_errorFlag,set_ActualHV <- setL_ActualHV,set_power <- setL_power,set_setPoint <- setL_setPoint,set_res <- setL_res,set_supplyLim <- setL_supplyLim,set_underLimit <- setL_underLimit]]
											 )
											 [| union(union(enteredCSet,{| exit, exited |}),{|up__
											 			,setL_errorAck,setR_errorAck
											 			 			,setL_lim,setR_lim
											 			 			,setL_overLimit,setR_overLimit
											 			 			,setL_errorFlag,setR_errorFlag
											 			 			,setL_ActualHV,setR_ActualHV
											 			 			,setL_power,setR_power
											 			 			,setL_setPoint,setR_setPoint
											 			 			,setL_res,setR_res
											 			 			,setL_supplyLim,setR_supplyLim
											 			 			,setL_underLimit,setR_underLimit
											 			|}) |]
											 ((During)
											  [[ up__ <- x__ | x__ <- {| up__,setL_errorAck,setL_lim,setL_overLimit,setL_errorFlag,setL_ActualHV,setL_power,setL_setPoint,setL_res,setL_supplyLim,setL_underLimit |} ]]
											  [[set_errorAck <- setR_errorAck,set_lim <- setR_lim,set_overLimit <- setR_overLimit,set_errorFlag <- setR_errorFlag,set_ActualHV <- setR_ActualHV,set_power <- setR_power,set_setPoint <- setR_setPoint,set_res <- setR_res,set_supplyLim <- setR_supplyLim,set_underLimit <- setR_underLimit]]
											 )
											)[[setL_errorAck <- set_errorAck,setR_errorAck <- set_errorAck,setL_lim <- set_lim,setR_lim <- set_lim,setL_overLimit <- set_overLimit,setR_overLimit <- set_overLimit,setL_errorFlag <- set_errorFlag,setR_errorFlag <- set_errorFlag,setL_ActualHV <- set_ActualHV,setR_ActualHV <- set_ActualHV,setL_power <- set_power,setR_power <- set_power,setL_setPoint <- set_setPoint,setR_setPoint <- set_setPoint,setL_res <- set_res,setR_res <- set_res,setL_supplyLim <- set_supplyLim,setR_supplyLim <- set_supplyLim,setL_underLimit <- set_underLimit,setR_underLimit <- set_underLimit]]
											) 
										[| {end__} |> SKIP
										) \ {end__}
									)
					
						Body = dbisim(((
						 (((ComposeNodes_VS_O(id__)[[s1::exit <- x__ | x__ <- {|exit|}]]
						 [[s2::exit <- x__ | x__ <- {|exit,internal__.TID_State_machine_ClosedLoop_t2|}]]
						 [[s3::exit <- x__ | x__ <- {|exit,internal__.TID_State_machine_ClosedLoop_t4,internal__.TID_State_machine_ClosedLoop_t5|}]]
						 [[s4::exit <- x__ | x__ <- {|exit,internal__.TID_State_machine_ClosedLoop_t1,internal__.TID_State_machine_ClosedLoop_t3|}]]
						 [[i0::exit <- x__ | x__ <- {|internal__.TID_State_machine_ClosedLoop_t0|}]]
						 [[  
						 s1::exited <- exited,
						 s2::exited <- exited,
						 s3::exited <- exited,
						 s4::exited <- exited
						 ]]
						 ))
						  [[ up__ <- x__ | x__ <- {| up__ |} ]] 
						  [[set_lim <- setL_lim]]
						 )
						 [| union(union(union(enterCSet,TransitionSync),{| exit, exited |}),{|up__
						 			,setL_lim
						|}) |]
						 ((i0::enter -> 
						 	((dbisim(Transitions(id__)) /\ exit -> SKIP) ; (MStop /\ exited -> end__ -> SKIP)))
						  [[ up__ <- x__ | x__ <- {| up__,setL_lim |} ]]
						 )
						)[[setL_lim <- set_lim]]
						\ union(enterCSet,{| exited, internal__ |}))
						[[
							currentState__.x____ <- currentState,
							ext_setPoint__.x____ <- ext_setPoint,
							ext_pow24VStatus__.x____ <- ext_pow24VStatus,
							int_overLimit__.x____ <- int_overLimit,
							int_pwmSignal__.x____ <- int_pwmSignal,
							int_underLimit__.x____ <- int_underLimit,
							int_DisableHV__.x____ <- int_DisableHV,
							int_ActualHV__.x____ <- int_ActualHV
							| x____ <- TIDS
						]]
						[[
							OP_disableHV::int_pwmSignal__.x____ <- int_pwmSignal
							| x____ <- OP_disableHV::TIDS
						]]
						[[
							OP_supplyVoltCheck::ext_setPoint__.x____ <- ext_setPoint,
							OP_supplyVoltCheck::ext_pow24VStatus__.x____ <- ext_pow24VStatus
							| x____ <- OP_supplyVoltCheck::TIDS
						]]
						[[
							OP_checkLimits::ext_setPoint__.x____ <- ext_setPoint,
							OP_checkLimits::ext_pow24VStatus__.x____ <- ext_pow24VStatus
							| x____ <- OP_checkLimits::TIDS
						]]
						)
					
						During = (MStop /\ ([] e : enteredCSet @ e -> SKIP))
								 ; entered -> ((CRUN(enteredCSet) ||| SKIP ; MStop) /\ exit -> SKIP)
						within
							Inactive)
					
					Transitions(id__) = get_lim?lim -> (up__ -> SKIP
					[] dbisim(((lim==true))&(internal__!TID_State_machine_ClosedLoop_t1 -> SKIP ;  ((MStop /\ exited -> SKIP) ; SKIP
					 ; s1::enter -> SKIP)))
					[] dbisim(((lim==true))&(internal__!TID_State_machine_ClosedLoop_t2 -> SKIP ;  ((MStop /\ exited -> SKIP) ; SKIP
					 ; s1::enter -> SKIP)))
					[] dbisim(((lim==false))&(internal__!TID_State_machine_ClosedLoop_t3 -> SKIP ;  ((MStop /\ exited -> SKIP) ; true&(int_pwmSignal.out!Power_On -> SKIP)
					 ; s3::enter -> SKIP)))
					[] dbisim((true)&(internal__!TID_State_machine_ClosedLoop_t4 -> SKIP ;  ((MStop /\ exited -> SKIP) ; SKIP
					 ; s2::enter -> SKIP)))
					[] dbisim(((lim==true))&(internal__!TID_State_machine_ClosedLoop_t5 -> SKIP ;  ((MStop /\ exited -> SKIP) ; SKIP
					 ; s1::enter -> SKIP)))
					[] dbisim((true)&(internal__!TID_State_machine_ClosedLoop_t0 -> SKIP ;  ((SKIP
					 ; s4::enter -> SKIP))))
					)
					 ; Transitions(id__)
					
					ComposeNodes(id__) = [| { up__ } |] proc__ : {i0::D__(id__),s1::D__(id__),s2::D__(id__),s3::D__(id__),s4::D__(id__)} @ proc__
					
					ComposeNodes_VS_O(id__) = [| { up__ } |] proc__ : {i0::VS_O__(id__),s1::VS_O__(id__),s2::VS_O__(id__),s3::VS_O__(id__),s4::VS_O__(id__)} @ proc__
				
				endmodule
				----------------------------------------------------------------------
				
				
				----------------------------------------------------------------------
				-- State: ErrorMode
				module ErrorMode
				
				enterCSet = 
						{|			i0::enter,
							f0::enter,
							s1::enter,
							s2::enter,
							j0::enter
						|}
				enteredCSet = 
						{|			f0::entered,
							s1::entered,
							s2::entered
						|}
				exports
				
					--  Declarations
					-- declaring identifiers of transitions
					datatype TIDS = NULLTRANSITION__
					              | TID_State_machine_ErrorMode_t0
					              | TID_State_machine_ErrorMode_t2
					              | TID_State_machine_ErrorMode_t4
					              | TID_State_machine_ErrorMode_t5
					              | TID_State_machine_ErrorMode_t1
					
					channel internal__ : TIDS
					channel enter, entered, exit, exited
					channel enteredL, enteredR
					channel end__
					
									
					channel currentState__: TIDS.InOut.State
					channel ext_setPoint__: TIDS.InOut.core_real
					channel ext_pow24VStatus__: TIDS.InOut.Power
					channel int_overLimit__: TIDS.InOut.core_real
					channel int_pwmSignal__: TIDS.InOut.Power
					channel int_underLimit__: TIDS.InOut.core_real
					channel int_DisableHV__: TIDS.InOut
					channel int_ActualHV__: TIDS.InOut.core_real
					
					--	Nodes
					-- declaring all nodes
					
					----------------------------------------------------------------------
					-- Initial: i0
					module i0
					exports
					
						channel enter, exit
						
						D__(id__) = dbisim(let
									Inactive = (MStop /\ enter -> SKIP) ; (MStop /\ exit -> Inactive)
								within
									Inactive)
									
						VS_O__(id__) = D__(id__)
					
					endmodule
					----------------------------------------------------------------------
					
					
					----------------------------------------------------------------------
					-- Final state: f0
					module f0
					
					exports
					
						channel enter, entered, exit, exited
						channel enteredL, enteredR
						
						--	Rule: behaviours(Node)
						D__(id__) = 
						dbisim(let
							Inactive = (MStop /\ enter -> SKIP) ; Behaviour ; exited -> Inactive
							Behaviour = entered -> (MStop /\ exit -> SKIP)
						within
							Inactive)
							
						VS_O__(id__) = D__(id__)
					
					endmodule
					----------------------------------------------------------------------
					
					
					----------------------------------------------------------------------
					-- State: s1
					module s1
					
					enterCSet = {}
					
					enteredCSet = {}
					
					exports
					
						--  Declarations
						-- declaring identifiers of transitions
						datatype TIDS = NULLTRANSITION__
						
						channel internal__ : TIDS
						channel enter, entered, exit, exited
						channel enteredL, enteredR
						channel end__
						
										
						
						--	Nodes
						-- declaring all nodes
						
						TransitionSync = {||}
						
						--	Rule: behaviours(Node)
						--  Note that FDR has problems with efficiently compiling the process below
						-- 	if using a different recursion pattern.
						D__(id__) = 
						dbisim(let
							Inactive = (MStop /\ enter -> SKIP) ; true & (set_setPoint!0 -> SKIP)
							 ; 
										Behaviour ; 
										SKIP ; 
										exited -> SKIP ; Inactive
						
							Behaviour = entered -> ((SKIP ; MStop) /\ exit -> SKIP)
						within
							Inactive)
							
						VS_O__(id__) = 
							dbisim(let
								Inactive = (MStop /\ enter -> SKIP) ; true & (set_setPoint!0 -> SKIP)
								 ; 
											Behaviour ; 
											SKIP ; 
											exited -> SKIP ; Inactive
						
								Behaviour = entered -> ((SKIP ; MStop) /\ exit -> SKIP)
							within
								Inactive)
						
					
					endmodule
					----------------------------------------------------------------------
					
					
					----------------------------------------------------------------------
					-- State: s2
					module s2
					
					enterCSet = {}
					
					enteredCSet = {}
					
					exports
					
						--  Declarations
						-- declaring identifiers of transitions
						datatype TIDS = NULLTRANSITION__
						
						channel internal__ : TIDS
						channel enter, entered, exit, exited
						channel enteredL, enteredR
						channel end__
						
										
						
						--	Nodes
						-- declaring all nodes
						
						TransitionSync = {||}
						
						--	Rule: behaviours(Node)
						--  Note that FDR has problems with efficiently compiling the process below
						-- 	if using a different recursion pattern.
						D__(id__) = 
						dbisim(let
							Inactive = (MStop /\ enter -> SKIP) ; true & (set_ActualHV!0 -> SKIP)
							 ; 
										Behaviour ; 
										SKIP ; 
										exited -> SKIP ; Inactive
						
							Behaviour = entered -> ((SKIP ; MStop) /\ exit -> SKIP)
						within
							Inactive)
							
						VS_O__(id__) = 
							dbisim(let
								Inactive = (MStop /\ enter -> SKIP) ; true & (set_ActualHV!0 -> SKIP)
								 ; 
											Behaviour ; 
											SKIP ; 
											exited -> SKIP ; Inactive
						
								Behaviour = entered -> ((SKIP ; MStop) /\ exit -> SKIP)
							within
								Inactive)
						
					
					endmodule
					----------------------------------------------------------------------
					
					
					----------------------------------------------------------------------
					-- Junction: j0
					module j0
					exports
					
						channel enter, exit
						
						D__(id__) = dbisim(let
							Inactive = (MStop /\ enter -> SKIP) ; (MStop /\ exit -> Inactive)
						within
							Inactive)
							
						VS_O__(id__) = D__(id__)
					
					endmodule
					----------------------------------------------------------------------
					
					
					TransitionSync = {|internal__.TID_State_machine_ErrorMode_t0,
					internal__.TID_State_machine_ErrorMode_t2,
					internal__.TID_State_machine_ErrorMode_t4,
					internal__.TID_State_machine_ErrorMode_t5,
					internal__.TID_State_machine_ErrorMode_t1|}
					
					--	Rule: behaviours(Node)
					--  Note that FDR has problems with efficiently compiling the process below
					-- 	if using a different recursion pattern.
					D__(id__) = 
					dbisim(let
						Inactive = (MStop /\ enter -> SKIP) ; true&(currentState.out!State_ErrorMode -> SKIP);true&CALL__disableHV(
									id__,
									false
								)
						 ; 
									Behaviour ; 
									SKIP ; 
									exited -> SKIP ; Inactive
					
					
						Behaviour = (
										(
											((
											 ((Body)
											  [[ up__ <- x__ | x__ <- {| up__,setR_errorAck,setR_lim,setR_overLimit,setR_errorFlag,setR_ActualHV,setR_power,setR_setPoint,setR_res,setR_supplyLim,setR_underLimit |} ]] 
											  [[set_errorAck <- setL_errorAck,set_lim <- setL_lim,set_overLimit <- setL_overLimit,set_errorFlag <- setL_errorFlag,set_ActualHV <- setL_ActualHV,set_power <- setL_power,set_setPoint <- setL_setPoint,set_res <- setL_res,set_supplyLim <- setL_supplyLim,set_underLimit <- setL_underLimit]]
											 )
											 [| union(union(enteredCSet,{| exit, exited |}),{|up__
											 			,setL_errorAck,setR_errorAck
											 			 			,setL_lim,setR_lim
											 			 			,setL_overLimit,setR_overLimit
											 			 			,setL_errorFlag,setR_errorFlag
											 			 			,setL_ActualHV,setR_ActualHV
											 			 			,setL_power,setR_power
											 			 			,setL_setPoint,setR_setPoint
											 			 			,setL_res,setR_res
											 			 			,setL_supplyLim,setR_supplyLim
											 			 			,setL_underLimit,setR_underLimit
											 			|}) |]
											 ((During)
											  [[ up__ <- x__ | x__ <- {| up__,setL_errorAck,setL_lim,setL_overLimit,setL_errorFlag,setL_ActualHV,setL_power,setL_setPoint,setL_res,setL_supplyLim,setL_underLimit |} ]]
											  [[set_errorAck <- setR_errorAck,set_lim <- setR_lim,set_overLimit <- setR_overLimit,set_errorFlag <- setR_errorFlag,set_ActualHV <- setR_ActualHV,set_power <- setR_power,set_setPoint <- setR_setPoint,set_res <- setR_res,set_supplyLim <- setR_supplyLim,set_underLimit <- setR_underLimit]]
											 )
											)[[setL_errorAck <- set_errorAck,setR_errorAck <- set_errorAck,setL_lim <- set_lim,setR_lim <- set_lim,setL_overLimit <- set_overLimit,setR_overLimit <- set_overLimit,setL_errorFlag <- set_errorFlag,setR_errorFlag <- set_errorFlag,setL_ActualHV <- set_ActualHV,setR_ActualHV <- set_ActualHV,setL_power <- set_power,setR_power <- set_power,setL_setPoint <- set_setPoint,setR_setPoint <- set_setPoint,setL_res <- set_res,setR_res <- set_res,setL_supplyLim <- set_supplyLim,setR_supplyLim <- set_supplyLim,setL_underLimit <- set_underLimit,setR_underLimit <- set_underLimit]]
											)\enteredCSet 
										[| {end__} |> SKIP
										) \ {end__}
									)
					
						Body = dbisim(((
						 (((ComposeNodes(id__)[[f0::exit <- x__ | x__ <- {|exit|}]]
						 [[s1::exit <- x__ | x__ <- {|exit,internal__.TID_State_machine_ErrorMode_t0|}]]
						 [[s2::exit <- x__ | x__ <- {|exit,internal__.TID_State_machine_ErrorMode_t4|}]]
						 [[i0::exit <- x__ | x__ <- {|internal__.TID_State_machine_ErrorMode_t2|}]]
						 [[j0::exit <- x__ | x__ <- {|internal__.TID_State_machine_ErrorMode_t5,internal__.TID_State_machine_ErrorMode_t1|}]]
						 [[  
						 f0::exited <- exited,
						 s1::exited <- exited,
						 s2::exited <- exited
						 ]]
						 ))
						  [[ up__ <- x__ | x__ <- {| up__ |} ]] 
						  [[set_ActualHV <- setL_ActualHV,set_setPoint <- setL_setPoint]]
						 )
						 [| union(union(union(enterCSet,TransitionSync),{| exit, exited |}),{|up__
						 			,setL_ActualHV
						 			,setL_setPoint
						|}) |]
						 ((i0::enter -> 
						 	((dbisim(Transitions(id__)) /\ exit -> SKIP) ; (MStop /\ exited -> end__ -> SKIP)))
						  [[ up__ <- x__ | x__ <- {| up__,setL_ActualHV,setL_setPoint |} ]]
						 )
						)[[setL_ActualHV <- set_ActualHV,setL_setPoint <- set_setPoint]]
						\ union(enterCSet,{| exited, internal__ |}))
						[[
							currentState__.x____ <- currentState,
							ext_setPoint__.x____ <- ext_setPoint,
							ext_pow24VStatus__.x____ <- ext_pow24VStatus,
							int_overLimit__.x____ <- int_overLimit,
							int_pwmSignal__.x____ <- int_pwmSignal,
							int_underLimit__.x____ <- int_underLimit,
							int_DisableHV__.x____ <- int_DisableHV,
							int_ActualHV__.x____ <- int_ActualHV
							| x____ <- TIDS
						]]
						[[
							OP_disableHV::int_pwmSignal__.x____ <- int_pwmSignal
							| x____ <- OP_disableHV::TIDS
						]]
						[[
							OP_supplyVoltCheck::ext_setPoint__.x____ <- ext_setPoint,
							OP_supplyVoltCheck::ext_pow24VStatus__.x____ <- ext_pow24VStatus
							| x____ <- OP_supplyVoltCheck::TIDS
						]]
						[[
							OP_checkLimits::ext_setPoint__.x____ <- ext_setPoint,
							OP_checkLimits::ext_pow24VStatus__.x____ <- ext_pow24VStatus
							| x____ <- OP_checkLimits::TIDS
						]]
						)
					
						During = (MStop /\ ([] e : enteredCSet @ e -> SKIP))
								 ; entered -> ((CRUN(enteredCSet) ||| SKIP ; MStop) /\ exit -> SKIP)
					within
						Inactive)
						
					VS_O__(id__) = 
						dbisim(let
							Inactive = (MStop /\ enter -> SKIP) ; true&(currentState.out!State_ErrorMode -> SKIP);true&CALL__disableHV(
										id__,
										false
									)
							 ; 
										Behaviour ; 
										SKIP ; 
										exited -> SKIP ; Inactive
					
					
						Behaviour = (
										(
											((
											 ((Body)
											  [[ up__ <- x__ | x__ <- {| up__,setR_errorAck,setR_lim,setR_overLimit,setR_errorFlag,setR_ActualHV,setR_power,setR_setPoint,setR_res,setR_supplyLim,setR_underLimit |} ]] 
											  [[set_errorAck <- setL_errorAck,set_lim <- setL_lim,set_overLimit <- setL_overLimit,set_errorFlag <- setL_errorFlag,set_ActualHV <- setL_ActualHV,set_power <- setL_power,set_setPoint <- setL_setPoint,set_res <- setL_res,set_supplyLim <- setL_supplyLim,set_underLimit <- setL_underLimit]]
											 )
											 [| union(union(enteredCSet,{| exit, exited |}),{|up__
											 			,setL_errorAck,setR_errorAck
											 			 			,setL_lim,setR_lim
											 			 			,setL_overLimit,setR_overLimit
											 			 			,setL_errorFlag,setR_errorFlag
											 			 			,setL_ActualHV,setR_ActualHV
											 			 			,setL_power,setR_power
											 			 			,setL_setPoint,setR_setPoint
											 			 			,setL_res,setR_res
											 			 			,setL_supplyLim,setR_supplyLim
											 			 			,setL_underLimit,setR_underLimit
											 			|}) |]
											 ((During)
											  [[ up__ <- x__ | x__ <- {| up__,setL_errorAck,setL_lim,setL_overLimit,setL_errorFlag,setL_ActualHV,setL_power,setL_setPoint,setL_res,setL_supplyLim,setL_underLimit |} ]]
											  [[set_errorAck <- setR_errorAck,set_lim <- setR_lim,set_overLimit <- setR_overLimit,set_errorFlag <- setR_errorFlag,set_ActualHV <- setR_ActualHV,set_power <- setR_power,set_setPoint <- setR_setPoint,set_res <- setR_res,set_supplyLim <- setR_supplyLim,set_underLimit <- setR_underLimit]]
											 )
											)[[setL_errorAck <- set_errorAck,setR_errorAck <- set_errorAck,setL_lim <- set_lim,setR_lim <- set_lim,setL_overLimit <- set_overLimit,setR_overLimit <- set_overLimit,setL_errorFlag <- set_errorFlag,setR_errorFlag <- set_errorFlag,setL_ActualHV <- set_ActualHV,setR_ActualHV <- set_ActualHV,setL_power <- set_power,setR_power <- set_power,setL_setPoint <- set_setPoint,setR_setPoint <- set_setPoint,setL_res <- set_res,setR_res <- set_res,setL_supplyLim <- set_supplyLim,setR_supplyLim <- set_supplyLim,setL_underLimit <- set_underLimit,setR_underLimit <- set_underLimit]]
											) 
										[| {end__} |> SKIP
										) \ {end__}
									)
					
						Body = dbisim(((
						 (((ComposeNodes_VS_O(id__)[[f0::exit <- x__ | x__ <- {|exit|}]]
						 [[s1::exit <- x__ | x__ <- {|exit,internal__.TID_State_machine_ErrorMode_t0|}]]
						 [[s2::exit <- x__ | x__ <- {|exit,internal__.TID_State_machine_ErrorMode_t4|}]]
						 [[i0::exit <- x__ | x__ <- {|internal__.TID_State_machine_ErrorMode_t2|}]]
						 [[j0::exit <- x__ | x__ <- {|internal__.TID_State_machine_ErrorMode_t5,internal__.TID_State_machine_ErrorMode_t1|}]]
						 [[  
						 f0::exited <- exited,
						 s1::exited <- exited,
						 s2::exited <- exited
						 ]]
						 ))
						  [[ up__ <- x__ | x__ <- {| up__ |} ]] 
						  [[set_ActualHV <- setL_ActualHV,set_setPoint <- setL_setPoint]]
						 )
						 [| union(union(union(enterCSet,TransitionSync),{| exit, exited |}),{|up__
						 			,setL_ActualHV
						 			,setL_setPoint
						|}) |]
						 ((i0::enter -> 
						 	((dbisim(Transitions(id__)) /\ exit -> SKIP) ; (MStop /\ exited -> end__ -> SKIP)))
						  [[ up__ <- x__ | x__ <- {| up__,setL_ActualHV,setL_setPoint |} ]]
						 )
						)[[setL_ActualHV <- set_ActualHV,setL_setPoint <- set_setPoint]]
						\ union(enterCSet,{| exited, internal__ |}))
						[[
							currentState__.x____ <- currentState,
							ext_setPoint__.x____ <- ext_setPoint,
							ext_pow24VStatus__.x____ <- ext_pow24VStatus,
							int_overLimit__.x____ <- int_overLimit,
							int_pwmSignal__.x____ <- int_pwmSignal,
							int_underLimit__.x____ <- int_underLimit,
							int_DisableHV__.x____ <- int_DisableHV,
							int_ActualHV__.x____ <- int_ActualHV
							| x____ <- TIDS
						]]
						[[
							OP_disableHV::int_pwmSignal__.x____ <- int_pwmSignal
							| x____ <- OP_disableHV::TIDS
						]]
						[[
							OP_supplyVoltCheck::ext_setPoint__.x____ <- ext_setPoint,
							OP_supplyVoltCheck::ext_pow24VStatus__.x____ <- ext_pow24VStatus
							| x____ <- OP_supplyVoltCheck::TIDS
						]]
						[[
							OP_checkLimits::ext_setPoint__.x____ <- ext_setPoint,
							OP_checkLimits::ext_pow24VStatus__.x____ <- ext_pow24VStatus
							| x____ <- OP_checkLimits::TIDS
						]]
						)
					
						During = (MStop /\ ([] e : enteredCSet @ e -> SKIP))
								 ; entered -> ((CRUN(enteredCSet) ||| SKIP ; MStop) /\ exit -> SKIP)
						within
							Inactive)
					
					Transitions(id__) = get_ActualHV?ActualHV -> get_setPoint?setPoint -> (up__ -> SKIP
					[] dbisim((true)&(internal__!TID_State_machine_ErrorMode_t0 -> SKIP ;  ((MStop /\ exited -> SKIP) ; get_setPoint?setPoint -> true&(ext_setPoint.out!setPoint -> SKIP)
					 ; s2::enter -> SKIP)))
					[] dbisim((true)&(internal__!TID_State_machine_ErrorMode_t2 -> SKIP ;  ((true & (set_errorAck!false -> SKIP)
					 ; s1::enter -> SKIP))))
					[] dbisim((true)&(internal__!TID_State_machine_ErrorMode_t4 -> SKIP ;  ((MStop /\ exited -> SKIP) ; get_ActualHV?ActualHV -> true&(int_ActualHV.out!ActualHV -> SKIP)
					 ; j0::enter -> SKIP)))
					[] dbisim((((setPoint==0) and (ActualHV==0)))&(internal__!TID_State_machine_ErrorMode_t5 -> SKIP ;  ((true & (set_errorAck!true -> SKIP)
					 ; f0::enter -> SKIP))))
					[] dbisim((((setPoint!=0) or (ActualHV!=0)))&(internal__!TID_State_machine_ErrorMode_t1 -> SKIP ;  ((SKIP
					 ; s1::enter -> SKIP))))
					)
					 ; Transitions(id__)
					
					ComposeNodes(id__) = [| { up__ } |] proc__ : {i0::D__(id__),f0::D__(id__),s1::D__(id__),s2::D__(id__),j0::D__(id__)} @ proc__
					
					ComposeNodes_VS_O(id__) = [| { up__ } |] proc__ : {i0::VS_O__(id__),f0::VS_O__(id__),s1::VS_O__(id__),s2::VS_O__(id__),j0::VS_O__(id__)} @ proc__
				
				endmodule
				----------------------------------------------------------------------
				
				
				----------------------------------------------------------------------
				-- Initial: i0
				module i0
				exports
				
					channel enter, exit
					
					D__(id__) = dbisim(let
								Inactive = (MStop /\ enter -> SKIP) ; (MStop /\ exit -> Inactive)
							within
								Inactive)
								
					VS_O__(id__) = D__(id__)
				
				endmodule
				----------------------------------------------------------------------
				
				
				----------------------------------------------------------------------
				-- Junction: j0
				module j0
				exports
				
					channel enter, exit
					
					D__(id__) = dbisim(let
						Inactive = (MStop /\ enter -> SKIP) ; (MStop /\ exit -> Inactive)
					within
						Inactive)
						
					VS_O__(id__) = D__(id__)
				
				endmodule
				----------------------------------------------------------------------
				
				
				TransitionSync = {|internal__.TID_State_machine_t0,
				internal__.TID_State_machine_t1,
				internal__.TID_State_machine_t2,
				internal__.TID_State_machine_t3,
				internal__.TID_State_machine_t4,
				internal__.TID_State_machine_t5,
				internal__.TID_State_machine_t6,
				int_DisableHV__.TID_State_machine_t8,
				int_DisableHV__.TID_State_machine_t11,
				internal__.TID_State_machine_t7|}
				
				-- The following is obviously not efficient for FDR to compile.
				-- For efficiency reasons a stepwise composition should be implemented instead.
				ComposeNodes(id__) = [| { up__ } |] proc__ : {Ramping::D__(id__),Init::D__(id__),Wait24Vpower::D__(id__),ClosedLoop::D__(id__),ErrorMode::D__(id__),i0::D__(id__),j0::D__(id__)} @ proc__
				
				ComposeNodes_VS_O(id__) = [| { up__ } |] proc__ : {Ramping::VS_O__(id__),Init::VS_O__(id__),Wait24Vpower::VS_O__(id__),ClosedLoop::VS_O__(id__),ErrorMode::VS_O__(id__),i0::VS_O__(id__),j0::VS_O__(id__)} @ proc__
				
				Transitions(id__) = (get_errorAck?errorAck -> get_lim?lim -> get_res?res -> get_setPoint?setPoint -> (up__ -> SKIP
				[] dbisim((true)&(internal__!TID_State_machine_t0 -> SKIP ;  ((MStop /\ exited -> SKIP) ; SKIP
				 ; Init::enter -> SKIP)))
				[] dbisim((true)&(internal__!TID_State_machine_t1 -> SKIP ;  ((MStop /\ exited -> SKIP) ; SKIP
				 ; Wait24Vpower::enter -> SKIP)))
				[] dbisim(((res==true))&(internal__!TID_State_machine_t2 -> SKIP ;  ((MStop /\ exited -> SKIP) ; true & (set_res!false -> SKIP)
				 ; ErrorMode::enter -> SKIP)))
				[] dbisim(((((setPoint==0) and (lim==false)) and (res==false)))&(internal__!TID_State_machine_t3 -> SKIP ;  ((MStop /\ exited -> SKIP) ; SKIP
				 ; ClosedLoop::enter -> SKIP)))
				[] dbisim(((res==true))&(internal__!TID_State_machine_t4 -> SKIP ;  ((MStop /\ exited -> SKIP) ; true & (set_res!false -> SKIP)
				 ; ErrorMode::enter -> SKIP)))
				[] dbisim((true)&(internal__!TID_State_machine_t5 -> SKIP ;  ((SKIP
				 ; Ramping::enter -> SKIP))))
				[] dbisim((errorAck)&(internal__!TID_State_machine_t6 -> SKIP ;  ((MStop /\ exited -> SKIP) ; SKIP
				 ; Wait24Vpower::enter -> SKIP)))
				[] dbisim((true)&(int_DisableHV__!TID_State_machine_t8.in -> SKIP ;  ((MStop /\ exited -> SKIP) ; SKIP
				 ; j0::enter -> SKIP)))
				[] dbisim((true)&(int_DisableHV__!TID_State_machine_t11.in -> SKIP ;  ((MStop /\ exited -> SKIP) ; SKIP
				 ; j0::enter -> SKIP)))
				[] dbisim((true)&(internal__!TID_State_machine_t7 -> SKIP ;  ((true&CALL__disableHV(
							id__,
							true
						);true & (set_res!false -> SKIP)
				 ; ErrorMode::enter -> SKIP))))
				)
				) ; Transitions(id__)
				
				Behaviours(id__) = ((
				 ((ComposeNodes(id__)[[Ramping::exit <- x__ | x__ <- {|exit,internal__.TID_State_machine_t0|}]]
				 [[Init::exit <- x__ | x__ <- {|exit,internal__.TID_State_machine_t1|}]]
				 [[Wait24Vpower::exit <- x__ | x__ <- {|exit,internal__.TID_State_machine_t2,internal__.TID_State_machine_t3,int_DisableHV__.TID_State_machine_t8.in|}]]
				 [[ClosedLoop::exit <- x__ | x__ <- {|exit,internal__.TID_State_machine_t4,int_DisableHV__.TID_State_machine_t11.in|}]]
				 [[ErrorMode::exit <- x__ | x__ <- {|exit,internal__.TID_State_machine_t6|}]]
				 [[i0::exit <- x__ | x__ <- {|internal__.TID_State_machine_t5|}]]
				 [[j0::exit <- x__ | x__ <- {|internal__.TID_State_machine_t7|}]]
				 [[  
				 Ramping::exited <- exited,
				 Init::exited <- exited,
				 Wait24Vpower::exited <- exited,
				 ClosedLoop::exited <- exited,
				 ErrorMode::exited <- exited
				 ]]
				 )
				  [[ up__ <- x__ | x__ <- {| up__ |} ]] 
				  [[set_errorAck <- setL_errorAck,set_lim <- setL_lim,set_res <- setL_res,set_setPoint <- setL_setPoint]]
				 )
				 [| union(union(union(enterCSet,TransitionSync),{| exited |}),{|up__
				 			,setL_errorAck
				 			,setL_lim
				 			,setL_res
				 			,setL_setPoint
				|}) |]
				 ((i0::enter -> Transitions(id__))
				  [[ up__ <- x__ | x__ <- {| up__,setL_errorAck,setL_lim,setL_res,setL_setPoint |} ]]
				 )
				)[[setL_errorAck <- set_errorAck,setL_lim <- set_lim,setL_res <- set_res,setL_setPoint <- set_setPoint]]
				\ union(enterCSet,{| exited, internal__ |})
				 [| {exit} |] STOP)
				
				Behaviours_VS_O(id__) = ((
				 ((ComposeNodes_VS_O(id__)[[Ramping::exit <- x__ | x__ <- {|exit,internal__.TID_State_machine_t0|}]]
				 [[Init::exit <- x__ | x__ <- {|exit,internal__.TID_State_machine_t1|}]]
				 [[Wait24Vpower::exit <- x__ | x__ <- {|exit,internal__.TID_State_machine_t2,internal__.TID_State_machine_t3,int_DisableHV__.TID_State_machine_t8.in|}]]
				 [[ClosedLoop::exit <- x__ | x__ <- {|exit,internal__.TID_State_machine_t4,int_DisableHV__.TID_State_machine_t11.in|}]]
				 [[ErrorMode::exit <- x__ | x__ <- {|exit,internal__.TID_State_machine_t6|}]]
				 [[i0::exit <- x__ | x__ <- {|internal__.TID_State_machine_t5|}]]
				 [[j0::exit <- x__ | x__ <- {|internal__.TID_State_machine_t7|}]]
				 [[  
				 Ramping::exited <- exited,
				 Init::exited <- exited,
				 Wait24Vpower::exited <- exited,
				 ClosedLoop::exited <- exited,
				 ErrorMode::exited <- exited
				 ]]
				 )
				  [[ up__ <- x__ | x__ <- {| up__ |} ]] 
				  [[set_errorAck <- setL_errorAck,set_lim <- setL_lim,set_res <- setL_res,set_setPoint <- setL_setPoint]]
				 )
				 [| union(union(union(enterCSet,TransitionSync),{| exited |}),{|up__
				 			,setL_errorAck
				 			,setL_lim
				 			,setL_res
				 			,setL_setPoint
				|}) |]
				 ((i0::enter -> Transitions(id__))
				  [[ up__ <- x__ | x__ <- {| up__,setL_errorAck,setL_lim,setL_res,setL_setPoint |} ]]
				 )
				)[[setL_errorAck <- set_errorAck,setL_lim <- set_lim,setL_res <- set_res,setL_setPoint <- set_setPoint]]
				\ union(enterCSet,{| exited, internal__ |})
				 [| {exit} |] STOP)
				
				
				-- memory process
				Memory_power(power) =
					get_power!power -> Memory_power(power)
					[]
					set_power?x__ -> Memory_power(x__)
				Memory_setPoint(setPoint) =
					get_setPoint!setPoint -> Memory_setPoint(setPoint)
					[]
					set_setPoint?x__ -> Memory_setPoint(x__)
				Memory_res(res) =
					get_res!res -> Memory_res(res)
					[]
					set_res?x__ -> Memory_res(x__)
				Memory_errorFlag(errorFlag) =
					get_errorFlag!errorFlag -> Memory_errorFlag(errorFlag)
					[]
					set_errorFlag?x__ -> Memory_errorFlag(x__)
				Memory_lim(lim) =
					get_lim!lim -> Memory_lim(lim)
					[]
					set_lim?x__ -> Memory_lim(x__)
				Memory_supplyLim(supplyLim) =
					get_supplyLim!supplyLim -> Memory_supplyLim(supplyLim)
					[]
					set_supplyLim?x__ -> Memory_supplyLim(x__)
				Memory_ActualHV(ActualHV) =
					get_ActualHV!ActualHV -> Memory_ActualHV(ActualHV)
					[]
					set_ActualHV?x__ -> Memory_ActualHV(x__)
				Memory_errorAck(errorAck) =
					get_errorAck!errorAck -> Memory_errorAck(errorAck)
					[]
					set_errorAck?x__ -> Memory_errorAck(x__)
				Memory_overLimit(overLimit) =
					get_overLimit!overLimit -> Memory_overLimit(overLimit)
					[]
					set_overLimit?x__ -> Memory_overLimit(x__)
				Memory_underLimit(underLimit) =
					get_underLimit!underLimit -> Memory_underLimit(underLimit)
					[]
					set_underLimit?x__ -> Memory_underLimit(x__)
				
				Memory(id__) =
					Memory_power(Power_On)
					|||
					Memory_setPoint(0)
					|||
					Memory_res(false)
					|||
					Memory_errorFlag(true)
					|||
					Memory_lim(false)
					|||
					Memory_supplyLim(false)
					|||
					Memory_ActualHV(0)
					|||
					Memory_errorAck(false)
					|||
					Memory_overLimit(0)
					|||
					Memory_underLimit(0)
				
				SharedVariableMemory(id__) =
					STOP
				
				SharedVariablesSyncSet = {||}
				
				SharedVariableHidingSet = {||}
				
				MachineMemorySyncSet = 
					{|get_power,set_power,
					get_setPoint,set_setPoint,
					get_res,set_res,
					get_errorFlag,set_errorFlag,
					get_lim,set_lim,
					get_supplyLim,set_supplyLim,
					get_ActualHV,set_ActualHV,
					get_errorAck,set_errorAck,
					get_overLimit,set_overLimit,
					get_underLimit,set_underLimit|}
					
				MachineMemoryHidingSet = {|get_power,set_power,
				get_setPoint,set_setPoint,
				get_res,set_res,
				get_errorFlag,set_errorFlag,
				get_lim,set_lim,
				get_supplyLim,set_supplyLim,
				get_ActualHV,set_ActualHV,
				get_errorAck,set_errorAck,
				get_overLimit,set_overLimit,
				get_underLimit,set_underLimit|}
				
				MachineInternalEvents = {|
					internal__
				|}
				
								
				-- main process
				
				STM(id__) = (
					(
						(AUX(id__)[[ up__ <- x__ | x__ <- {||} ]]
					 	[| { up__ } |]
					 	SKIP)
					 /+ SharedVariablesSyncSet +\
					 SharedVariableMemory(id__))
					 \SharedVariableHidingSet
				)
				
				AUX(id__) = (
					(
						(Behaviours(id__)
						 [|MachineMemorySyncSet|]
						 Memory(id__))
					)[[
						currentState__.x____ <- currentState,
						ext_setPoint__.x____ <- ext_setPoint,
						ext_pow24VStatus__.x____ <- ext_pow24VStatus,
						int_overLimit__.x____ <- int_overLimit,
						int_pwmSignal__.x____ <- int_pwmSignal,
						int_underLimit__.x____ <- int_underLimit,
						int_DisableHV__.x____ <- int_DisableHV,
						int_ActualHV__.x____ <- int_ActualHV
						| x____ <- TIDS
					]]
					[[
						OP_disableHV::int_pwmSignal__.x____ <- int_pwmSignal
						| x____ <- OP_disableHV::TIDS
					]]
					[[
						OP_supplyVoltCheck::ext_setPoint__.x____ <- ext_setPoint,
						OP_supplyVoltCheck::ext_pow24VStatus__.x____ <- ext_pow24VStatus
						| x____ <- OP_supplyVoltCheck::TIDS
					]]
					[[
						OP_checkLimits::ext_setPoint__.x____ <- ext_setPoint,
						OP_checkLimits::ext_pow24VStatus__.x____ <- ext_pow24VStatus
						| x____ <- OP_checkLimits::TIDS
					]]
					\MachineMemoryHidingSet
				)
				[|{|terminate|}|>SKIP\MachineInternalEvents
				
				
				
				STM_VS_O(id__) = (
					(
						(AUX_VS_O(id__)[[ up__ <- x__ | x__ <- {||} ]]
					 	[| { up__ } |]
					 	SKIP)
					 /+ SharedVariablesSyncSet +\
					 SharedVariableMemory(id__))
					 \SharedVariableHidingSet
				)
				
				AUX_VS_O(id__) = (
					(
						(Behaviours_VS_O(id__)
						 [|MachineMemorySyncSet|]
						 Memory(id__))
					)[[
						currentState__.x____ <- currentState,
						ext_setPoint__.x____ <- ext_setPoint,
						ext_pow24VStatus__.x____ <- ext_pow24VStatus,
						int_overLimit__.x____ <- int_overLimit,
						int_pwmSignal__.x____ <- int_pwmSignal,
						int_underLimit__.x____ <- int_underLimit,
						int_DisableHV__.x____ <- int_DisableHV,
						int_ActualHV__.x____ <- int_ActualHV
						| x____ <- TIDS
					]]
					[[
						OP_disableHV::int_pwmSignal__.x____ <- int_pwmSignal
						| x____ <- OP_disableHV::TIDS
					]]
					[[
						OP_supplyVoltCheck::ext_setPoint__.x____ <- ext_setPoint,
						OP_supplyVoltCheck::ext_pow24VStatus__.x____ <- ext_pow24VStatus
						| x____ <- OP_supplyVoltCheck::TIDS
					]]
					[[
						OP_checkLimits::ext_setPoint__.x____ <- ext_setPoint,
						OP_checkLimits::ext_pow24VStatus__.x____ <- ext_pow24VStatus
						| x____ <- OP_checkLimits::TIDS
					]]
					\MachineMemoryHidingSet
				)
				[|{|terminate|}|>SKIP\MachineInternalEvents
				
				
				
				-- definition of the behaviour of state machines (default, optimised, visible, visible and optimised)
				
				FVS__(id__) = STM_VS_O(id__)
				
				D__(id__) = STM(id__) \ internal_events
				O__(id__) = sbisim(diamond(D__(id__)))
				VS__(id__) = FVS__(id__)
				VS_O__(id__) = sbisim(diamond(FVS__(id__)))
				HEXT__(id__) = O__(id__) [|shared_variable_events|] SKIP
				HUP__(id__) = O__(id__) [|{up__}|] SKIP
			endmodule
			
				-- undefined operations
				
				-- declaring controller memory
				Memory(id__) = SKIP
				
				D__(id__) = 	((
						stm_ref0::D__(id__)[[
							stm_ref0::terminate <- terminate,
							stm_ref0::int_DisableHV <- int_DisableHV,
							stm_ref0::int_ActualHV <- int_ActualHV,
							stm_ref0::int_underLimit <- int_underLimit,
							stm_ref0::int_overLimit <- int_overLimit,
							stm_ref0::ext_setPoint <- ext_setPoint,
							stm_ref0::int_pwmSignal <- int_pwmSignal,
							stm_ref0::ext_pow24VStatus <- ext_pow24VStatus,
							stm_ref0::currentState <- currentState
						]]
					)
						[|
							union(
								{|
								|},
								{|
								|}
							)
						|]
					Memory(id__)
				)
				\ union(
					{|
					|},
					{|
					|}
				)
				[|{|terminate|}|>SKIP
				
				-- VS version
				VS__(id__) = 	((
						stm_ref0::VS__(id__)[[
							stm_ref0::terminate <- terminate,
							stm_ref0::int_DisableHV <- int_DisableHV,
							stm_ref0::int_ActualHV <- int_ActualHV,
							stm_ref0::int_underLimit <- int_underLimit,
							stm_ref0::int_overLimit <- int_overLimit,
							stm_ref0::ext_setPoint <- ext_setPoint,
							stm_ref0::int_pwmSignal <- int_pwmSignal,
							stm_ref0::ext_pow24VStatus <- ext_pow24VStatus,
							stm_ref0::currentState <- currentState
						]]
					)
						[|
							union(
								{|
								|},
								{|
								|}
							)
						|]
					Memory(id__)
				)
				\ union(
					{|
					|},
					{|
					|}
				)
				[|{|terminate|}|>SKIP
			
				-- O version (optimised) THESE TWO PROCESSES SHOULD BE KEPT IN SYNC WITH THE ABOVE TWO
				O__(id__) = sbisim(diamond(	((
						stm_ref0::O__(id__)[[
							stm_ref0::terminate <- terminate,
							stm_ref0::int_DisableHV <- int_DisableHV,
							stm_ref0::int_ActualHV <- int_ActualHV,
							stm_ref0::int_underLimit <- int_underLimit,
							stm_ref0::int_overLimit <- int_overLimit,
							stm_ref0::ext_setPoint <- ext_setPoint,
							stm_ref0::int_pwmSignal <- int_pwmSignal,
							stm_ref0::ext_pow24VStatus <- ext_pow24VStatus,
							stm_ref0::currentState <- currentState
						]]
					)
						[|
							union(
								{|
								|},
								{|
								|}
							)
						|]
					Memory(id__)
				)
				\ union(
					{|
					|},
					{|
					|}
				)
				[|{|terminate|}|>SKIP
				))
								
				-- VS_O version
				VS_O__(id__) = sbisim(diamond(	((
						stm_ref0::VS_O__(id__)[[
							stm_ref0::terminate <- terminate,
							stm_ref0::int_DisableHV <- int_DisableHV,
							stm_ref0::int_ActualHV <- int_ActualHV,
							stm_ref0::int_underLimit <- int_underLimit,
							stm_ref0::int_overLimit <- int_overLimit,
							stm_ref0::ext_setPoint <- ext_setPoint,
							stm_ref0::int_pwmSignal <- int_pwmSignal,
							stm_ref0::ext_pow24VStatus <- ext_pow24VStatus,
							stm_ref0::currentState <- currentState
						]]
					)
						[|
							union(
								{|
								|},
								{|
								|}
							)
						|]
					Memory(id__)
				)
				\ union(
					{|
					|},
					{|
					|}
				)
				[|{|terminate|}|>SKIP
				))
			
				HEXT(id__) = O__(id__) [|shared_variable_events|] SKIP			
	
		endmodule
		module ctrl_ref1
			shared_variable_events = {|
			|}
			
		exports
			transparent diamond
			transparent sbisim
			transparent dbisim
			transparent chase
	
			-- declaring controller events
			channel ext_pow24VStatus: InOut.Power
			channel int_overLimit: InOut.core_real
			channel int_underLimit: InOut.core_real
			channel int_DisableHV: InOut
			channel int_ActualHV: InOut.core_real
			
			
			
			-- declaring call and ret events for undefined operations
			
			-- declaring controller termination channel		
			channel terminate
	
			-- defined operations
		
			-- declaring machines
			module stm_ref0
			exports
				transparent diamond
				transparent sbisim
				transparent dbisim
				transparent chase
			
				-- flow channels
				channel internal__ : TIDS
				
				-- The following are now declared per state (using modules)
				--channel enter, entered: NIDS
				channel exit
				channel exited
				channel terminate
				
				-- variable channels
				channel get_overLimit, set_overLimit, setL_overLimit, setR_overLimit: core_real
				channel get_underLimit, set_underLimit, setL_underLimit, setR_underLimit: core_real
				channel get_ActualHV, set_ActualHV, setL_ActualHV, setR_ActualHV: core_real
				channel get_power, set_power, setL_power, setR_power: Power
				
				-- shared variable channels
				
				-- local variable channels for defined operations that are required by the state machine
				
				-- declaring state machine events
				channel int_overLimit__: TIDS.InOut.core_real
				channel int_overLimit: InOut.core_real
				channel int_underLimit__: TIDS.InOut.core_real
				channel int_underLimit: InOut.core_real
				channel int_DisableHV__: TIDS.InOut
				channel int_DisableHV: InOut
				channel int_ActualHV__: TIDS.InOut.core_real
				channel int_ActualHV: InOut.core_real
				channel ext_pow24VStatus__: TIDS.InOut.Power
				channel ext_pow24VStatus: InOut.Power
				
				-- declaring call and ret events for undefined operations
				
				enterCSet = {|
				i0::enter,
				s0::enter
				|}
				
				enteredCSet = 	{|
				s0::entered
				|}
				
				internal_events = union(enteredCSet,union(enterCSet,{|exit,exited|}))
				
				shared_variable_events = {|
				|}
			
				-- Only the undefined operations are declared here.
				-- If the state machine is in isolation, all required operations will be undefined.
				-- If it is in the context of a controller, the required operations not provided by the
				-- controller will be declared here, and the defined operations will be defined in the
				-- context of the Controller module, and therefore within scope of the state machien module.
				
				
				-- declaring identifiers of transitions
				datatype TIDS = NULLTRANSITION__
				              | TID_Watchdog_t0
				              | TID_Watchdog_t1
				
				-- declaring all nodes
				
				----------------------------------------------------------------------
				-- Initial: i0
				module i0
				exports
				
					channel enter, exit
					
					D__(id__) = dbisim(let
								Inactive = (MStop /\ enter -> SKIP) ; (MStop /\ exit -> Inactive)
							within
								Inactive)
								
					VS_O__(id__) = D__(id__)
				
				endmodule
				----------------------------------------------------------------------
				
				
				----------------------------------------------------------------------
				-- State: s0
				module s0
				
				enterCSet = 
						{|			i0::enter,
							f0::enter,
							Waiting::enter,
							PowerStatusRead::enter,
							ActualHVRead::enter,
							PowerAndActualHVRead::enter
						|}
				enteredCSet = 
						{|			f0::entered,
							Waiting::entered,
							PowerStatusRead::entered,
							ActualHVRead::entered,
							PowerAndActualHVRead::entered
						|}
				exports
				
					--  Declarations
					-- declaring identifiers of transitions
					datatype TIDS = NULLTRANSITION__
					              | TID_Watchdog_s0_t0
					              | TID_Watchdog_s0_t1
					              | TID_Watchdog_s0_t3
					              | TID_Watchdog_s0_t2
					              | TID_Watchdog_s0_t4
					              | TID_Watchdog_s0_t5
					              | TID_Watchdog_s0_t6
					              | TID_Watchdog_s0_t7
					              | TID_Watchdog_s0_t8
					              | TID_Watchdog_s0_t9
					              | TID_Watchdog_s0_t10
					
					channel internal__ : TIDS
					channel enter, entered, exit, exited
					channel enteredL, enteredR
					channel end__
					
									
					channel int_overLimit__: TIDS.InOut.core_real
					channel int_underLimit__: TIDS.InOut.core_real
					channel int_DisableHV__: TIDS.InOut
					channel int_ActualHV__: TIDS.InOut.core_real
					channel ext_pow24VStatus__: TIDS.InOut.Power
					
					--	Nodes
					-- declaring all nodes
					
					----------------------------------------------------------------------
					-- Initial: i0
					module i0
					exports
					
						channel enter, exit
						
						D__(id__) = dbisim(let
									Inactive = (MStop /\ enter -> SKIP) ; (MStop /\ exit -> Inactive)
								within
									Inactive)
									
						VS_O__(id__) = D__(id__)
					
					endmodule
					----------------------------------------------------------------------
					
					
					----------------------------------------------------------------------
					-- Final state: f0
					module f0
					
					exports
					
						channel enter, entered, exit, exited
						channel enteredL, enteredR
						
						--	Rule: behaviours(Node)
						D__(id__) = 
						dbisim(let
							Inactive = (MStop /\ enter -> SKIP) ; Behaviour ; exited -> Inactive
							Behaviour = entered -> (MStop /\ exit -> SKIP)
						within
							Inactive)
							
						VS_O__(id__) = D__(id__)
					
					endmodule
					----------------------------------------------------------------------
					
					
					----------------------------------------------------------------------
					-- State: Waiting
					module Waiting
					
					enterCSet = {}
					
					enteredCSet = {}
					
					exports
					
						--  Declarations
						-- declaring identifiers of transitions
						datatype TIDS = NULLTRANSITION__
						
						channel internal__ : TIDS
						channel enter, entered, exit, exited
						channel enteredL, enteredR
						channel end__
						
										
						
						--	Nodes
						-- declaring all nodes
						
						TransitionSync = {||}
						
						--	Rule: behaviours(Node)
						--  Note that FDR has problems with efficiently compiling the process below
						-- 	if using a different recursion pattern.
						D__(id__) = 
						dbisim(let
							Inactive = (MStop /\ enter -> SKIP) ; SKIP ; 
										Behaviour ; 
										SKIP ; 
										exited -> SKIP ; Inactive
						
							Behaviour = entered -> ((SKIP ; MStop) /\ exit -> SKIP)
						within
							Inactive)
							
						VS_O__(id__) = 
							dbisim(let
								Inactive = (MStop /\ enter -> SKIP) ; SKIP ; 
											Behaviour ; 
											SKIP ; 
											exited -> SKIP ; Inactive
						
								Behaviour = entered -> ((SKIP ; MStop) /\ exit -> SKIP)
							within
								Inactive)
						
					
					endmodule
					----------------------------------------------------------------------
					
					
					----------------------------------------------------------------------
					-- State: PowerStatusRead
					module PowerStatusRead
					
					enterCSet = {}
					
					enteredCSet = {}
					
					exports
					
						--  Declarations
						-- declaring identifiers of transitions
						datatype TIDS = NULLTRANSITION__
						
						channel internal__ : TIDS
						channel enter, entered, exit, exited
						channel enteredL, enteredR
						channel end__
						
										
						
						--	Nodes
						-- declaring all nodes
						
						TransitionSync = {||}
						
						--	Rule: behaviours(Node)
						--  Note that FDR has problems with efficiently compiling the process below
						-- 	if using a different recursion pattern.
						D__(id__) = 
						dbisim(let
							Inactive = (MStop /\ enter -> SKIP) ; SKIP ; 
										Behaviour ; 
										SKIP ; 
										exited -> SKIP ; Inactive
						
							Behaviour = entered -> ((SKIP ; MStop) /\ exit -> SKIP)
						within
							Inactive)
							
						VS_O__(id__) = 
							dbisim(let
								Inactive = (MStop /\ enter -> SKIP) ; SKIP ; 
											Behaviour ; 
											SKIP ; 
											exited -> SKIP ; Inactive
						
								Behaviour = entered -> ((SKIP ; MStop) /\ exit -> SKIP)
							within
								Inactive)
						
					
					endmodule
					----------------------------------------------------------------------
					
					
					----------------------------------------------------------------------
					-- State: ActualHVRead
					module ActualHVRead
					
					enterCSet = {}
					
					enteredCSet = {}
					
					exports
					
						--  Declarations
						-- declaring identifiers of transitions
						datatype TIDS = NULLTRANSITION__
						
						channel internal__ : TIDS
						channel enter, entered, exit, exited
						channel enteredL, enteredR
						channel end__
						
										
						
						--	Nodes
						-- declaring all nodes
						
						TransitionSync = {||}
						
						--	Rule: behaviours(Node)
						--  Note that FDR has problems with efficiently compiling the process below
						-- 	if using a different recursion pattern.
						D__(id__) = 
						dbisim(let
							Inactive = (MStop /\ enter -> SKIP) ; SKIP ; 
										Behaviour ; 
										SKIP ; 
										exited -> SKIP ; Inactive
						
							Behaviour = entered -> ((SKIP ; MStop) /\ exit -> SKIP)
						within
							Inactive)
							
						VS_O__(id__) = 
							dbisim(let
								Inactive = (MStop /\ enter -> SKIP) ; SKIP ; 
											Behaviour ; 
											SKIP ; 
											exited -> SKIP ; Inactive
						
								Behaviour = entered -> ((SKIP ; MStop) /\ exit -> SKIP)
							within
								Inactive)
						
					
					endmodule
					----------------------------------------------------------------------
					
					
					----------------------------------------------------------------------
					-- State: PowerAndActualHVRead
					module PowerAndActualHVRead
					
					enterCSet = {}
					
					enteredCSet = {}
					
					exports
					
						--  Declarations
						-- declaring identifiers of transitions
						datatype TIDS = NULLTRANSITION__
						
						channel internal__ : TIDS
						channel enter, entered, exit, exited
						channel enteredL, enteredR
						channel end__
						
										
						
						--	Nodes
						-- declaring all nodes
						
						TransitionSync = {||}
						
						--	Rule: behaviours(Node)
						--  Note that FDR has problems with efficiently compiling the process below
						-- 	if using a different recursion pattern.
						D__(id__) = 
						dbisim(let
							Inactive = (MStop /\ enter -> SKIP) ; SKIP ; 
										Behaviour ; 
										SKIP ; 
										exited -> SKIP ; Inactive
						
							Behaviour = entered -> ((SKIP ; MStop) /\ exit -> SKIP)
						within
							Inactive)
							
						VS_O__(id__) = 
							dbisim(let
								Inactive = (MStop /\ enter -> SKIP) ; SKIP ; 
											Behaviour ; 
											SKIP ; 
											exited -> SKIP ; Inactive
						
								Behaviour = entered -> ((SKIP ; MStop) /\ exit -> SKIP)
							within
								Inactive)
						
					
					endmodule
					----------------------------------------------------------------------
					
					
					TransitionSync = {|internal__.TID_Watchdog_s0_t0,
					internal__.TID_Watchdog_s0_t1,
					internal__.TID_Watchdog_s0_t3,
					internal__.TID_Watchdog_s0_t2,
					ext_pow24VStatus__.TID_Watchdog_s0_t4,
					int_ActualHV__.TID_Watchdog_s0_t5,
					int_ActualHV__.TID_Watchdog_s0_t6,
					ext_pow24VStatus__.TID_Watchdog_s0_t7,
					internal__.TID_Watchdog_s0_t8,
					internal__.TID_Watchdog_s0_t9,
					internal__.TID_Watchdog_s0_t10|}
					
					--	Rule: behaviours(Node)
					--  Note that FDR has problems with efficiently compiling the process below
					-- 	if using a different recursion pattern.
					D__(id__) = 
					dbisim(let
						Inactive = (MStop /\ enter -> SKIP) ; SKIP ; 
									Behaviour ; 
									SKIP ; 
									exited -> SKIP ; Inactive
					
					
						Behaviour = (
										(
											((
											 ((Body)
											  [[ up__ <- x__ | x__ <- {| up__,setR_underLimit,setR_power,setR_overLimit,setR_ActualHV |} ]] 
											  [[set_underLimit <- setL_underLimit,set_power <- setL_power,set_overLimit <- setL_overLimit,set_ActualHV <- setL_ActualHV]]
											 )
											 [| union(union(enteredCSet,{| exit, exited |}),{|up__
											 			,setL_underLimit,setR_underLimit
											 			 			,setL_power,setR_power
											 			 			,setL_overLimit,setR_overLimit
											 			 			,setL_ActualHV,setR_ActualHV
											 			|}) |]
											 ((During)
											  [[ up__ <- x__ | x__ <- {| up__,setL_underLimit,setL_power,setL_overLimit,setL_ActualHV |} ]]
											  [[set_underLimit <- setR_underLimit,set_power <- setR_power,set_overLimit <- setR_overLimit,set_ActualHV <- setR_ActualHV]]
											 )
											)[[setL_underLimit <- set_underLimit,setR_underLimit <- set_underLimit,setL_power <- set_power,setR_power <- set_power,setL_overLimit <- set_overLimit,setR_overLimit <- set_overLimit,setL_ActualHV <- set_ActualHV,setR_ActualHV <- set_ActualHV]]
											)\enteredCSet 
										[| {end__} |> SKIP
										) \ {end__}
									)
					
						Body = dbisim(((
						 (((ComposeNodes(id__)[[f0::exit <- x__ | x__ <- {|exit|}]]
						 [[Waiting::exit <- x__ | x__ <- {|exit,ext_pow24VStatus__.TID_Watchdog_s0_t4.in,int_ActualHV__.TID_Watchdog_s0_t5.in|}]]
						 [[PowerStatusRead::exit <- x__ | x__ <- {|exit,internal__.TID_Watchdog_s0_t2,int_ActualHV__.TID_Watchdog_s0_t6.in|}]]
						 [[ActualHVRead::exit <- x__ | x__ <- {|exit,internal__.TID_Watchdog_s0_t1,internal__.TID_Watchdog_s0_t3,ext_pow24VStatus__.TID_Watchdog_s0_t7.in|}]]
						 [[PowerAndActualHVRead::exit <- x__ | x__ <- {|exit,internal__.TID_Watchdog_s0_t8,internal__.TID_Watchdog_s0_t9,internal__.TID_Watchdog_s0_t10|}]]
						 [[i0::exit <- x__ | x__ <- {|internal__.TID_Watchdog_s0_t0|}]]
						 [[  
						 f0::exited <- exited,
						 Waiting::exited <- exited,
						 PowerStatusRead::exited <- exited,
						 ActualHVRead::exited <- exited,
						 PowerAndActualHVRead::exited <- exited
						 ]]
						 ))
						  [[ up__ <- x__ | x__ <- {| up__ |} ]] 
						  [[set_underLimit <- setL_underLimit,set_power <- setL_power,set_overLimit <- setL_overLimit,set_ActualHV <- setL_ActualHV]]
						 )
						 [| union(union(union(enterCSet,TransitionSync),{| exit, exited |}),{|up__
						 			,setL_underLimit
						 			,setL_power
						 			,setL_overLimit
						 			,setL_ActualHV
						|}) |]
						 ((i0::enter -> 
						 	((dbisim(Transitions(id__)) /\ exit -> SKIP) ; (MStop /\ exited -> end__ -> SKIP)))
						  [[ up__ <- x__ | x__ <- {| up__,setL_underLimit,setL_power,setL_overLimit,setL_ActualHV |} ]]
						 )
						)[[setL_underLimit <- set_underLimit,setL_power <- set_power,setL_overLimit <- set_overLimit,setL_ActualHV <- set_ActualHV]]
						\ union(enterCSet,{| exited, internal__ |}))
						[[
							int_overLimit__.x____ <- int_overLimit,
							int_underLimit__.x____ <- int_underLimit,
							int_DisableHV__.x____ <- int_DisableHV,
							int_ActualHV__.x____ <- int_ActualHV,
							ext_pow24VStatus__.x____ <- ext_pow24VStatus
							| x____ <- TIDS
						]]
						)
					
						During = (MStop /\ ([] e : enteredCSet @ e -> SKIP))
								 ; entered -> ((CRUN(enteredCSet) ||| SKIP ; MStop) /\ exit -> SKIP)
					within
						Inactive)
						
					VS_O__(id__) = 
						dbisim(let
							Inactive = (MStop /\ enter -> SKIP) ; SKIP ; 
										Behaviour ; 
										SKIP ; 
										exited -> SKIP ; Inactive
					
					
						Behaviour = (
										(
											((
											 ((Body)
											  [[ up__ <- x__ | x__ <- {| up__,setR_underLimit,setR_power,setR_overLimit,setR_ActualHV |} ]] 
											  [[set_underLimit <- setL_underLimit,set_power <- setL_power,set_overLimit <- setL_overLimit,set_ActualHV <- setL_ActualHV]]
											 )
											 [| union(union(enteredCSet,{| exit, exited |}),{|up__
											 			,setL_underLimit,setR_underLimit
											 			 			,setL_power,setR_power
											 			 			,setL_overLimit,setR_overLimit
											 			 			,setL_ActualHV,setR_ActualHV
											 			|}) |]
											 ((During)
											  [[ up__ <- x__ | x__ <- {| up__,setL_underLimit,setL_power,setL_overLimit,setL_ActualHV |} ]]
											  [[set_underLimit <- setR_underLimit,set_power <- setR_power,set_overLimit <- setR_overLimit,set_ActualHV <- setR_ActualHV]]
											 )
											)[[setL_underLimit <- set_underLimit,setR_underLimit <- set_underLimit,setL_power <- set_power,setR_power <- set_power,setL_overLimit <- set_overLimit,setR_overLimit <- set_overLimit,setL_ActualHV <- set_ActualHV,setR_ActualHV <- set_ActualHV]]
											) 
										[| {end__} |> SKIP
										) \ {end__}
									)
					
						Body = dbisim(((
						 (((ComposeNodes_VS_O(id__)[[f0::exit <- x__ | x__ <- {|exit|}]]
						 [[Waiting::exit <- x__ | x__ <- {|exit,ext_pow24VStatus__.TID_Watchdog_s0_t4.in,int_ActualHV__.TID_Watchdog_s0_t5.in|}]]
						 [[PowerStatusRead::exit <- x__ | x__ <- {|exit,internal__.TID_Watchdog_s0_t2,int_ActualHV__.TID_Watchdog_s0_t6.in|}]]
						 [[ActualHVRead::exit <- x__ | x__ <- {|exit,internal__.TID_Watchdog_s0_t1,internal__.TID_Watchdog_s0_t3,ext_pow24VStatus__.TID_Watchdog_s0_t7.in|}]]
						 [[PowerAndActualHVRead::exit <- x__ | x__ <- {|exit,internal__.TID_Watchdog_s0_t8,internal__.TID_Watchdog_s0_t9,internal__.TID_Watchdog_s0_t10|}]]
						 [[i0::exit <- x__ | x__ <- {|internal__.TID_Watchdog_s0_t0|}]]
						 [[  
						 f0::exited <- exited,
						 Waiting::exited <- exited,
						 PowerStatusRead::exited <- exited,
						 ActualHVRead::exited <- exited,
						 PowerAndActualHVRead::exited <- exited
						 ]]
						 ))
						  [[ up__ <- x__ | x__ <- {| up__ |} ]] 
						  [[set_underLimit <- setL_underLimit,set_power <- setL_power,set_overLimit <- setL_overLimit,set_ActualHV <- setL_ActualHV]]
						 )
						 [| union(union(union(enterCSet,TransitionSync),{| exit, exited |}),{|up__
						 			,setL_underLimit
						 			,setL_power
						 			,setL_overLimit
						 			,setL_ActualHV
						|}) |]
						 ((i0::enter -> 
						 	((dbisim(Transitions(id__)) /\ exit -> SKIP) ; (MStop /\ exited -> end__ -> SKIP)))
						  [[ up__ <- x__ | x__ <- {| up__,setL_underLimit,setL_power,setL_overLimit,setL_ActualHV |} ]]
						 )
						)[[setL_underLimit <- set_underLimit,setL_power <- set_power,setL_overLimit <- set_overLimit,setL_ActualHV <- set_ActualHV]]
						\ union(enterCSet,{| exited, internal__ |}))
						[[
							int_overLimit__.x____ <- int_overLimit,
							int_underLimit__.x____ <- int_underLimit,
							int_DisableHV__.x____ <- int_DisableHV,
							int_ActualHV__.x____ <- int_ActualHV,
							ext_pow24VStatus__.x____ <- ext_pow24VStatus
							| x____ <- TIDS
						]]
						)
					
						During = (MStop /\ ([] e : enteredCSet @ e -> SKIP))
								 ; entered -> ((CRUN(enteredCSet) ||| SKIP ; MStop) /\ exit -> SKIP)
						within
							Inactive)
					
					Transitions(id__) = get_underLimit?underLimit -> get_power?power -> get_overLimit?overLimit -> get_ActualHV?ActualHV -> (up__ -> SKIP
					[] dbisim((true)&(internal__!TID_Watchdog_s0_t0 -> SKIP ;  ((SKIP
					 ; Waiting::enter -> SKIP))))
					[] dbisim(((ActualHV>overLimit))&(internal__!TID_Watchdog_s0_t1 -> SKIP ;  ((MStop /\ exited -> SKIP) ; true&(int_DisableHV.out -> SKIP)
					 ; f0::enter -> SKIP)))
					[] dbisim(((ActualHV<underLimit))&(internal__!TID_Watchdog_s0_t3 -> SKIP ;  ((MStop /\ exited -> SKIP) ; true&(int_DisableHV.out -> SKIP)
					 ; f0::enter -> SKIP)))
					[] dbisim(((power==Power_Off))&(internal__!TID_Watchdog_s0_t2 -> SKIP ;  ((MStop /\ exited -> SKIP) ; true&(int_DisableHV.out -> SKIP)
					 ; f0::enter -> SKIP)))
					[] dbisim((true)&(ext_pow24VStatus__!TID_Watchdog_s0_t4.in?power:{power|power <- Power, true} -> set_power!power -> SKIP ;  ((MStop /\ exited -> SKIP) ; SKIP
					 ; PowerStatusRead::enter -> SKIP)))
					[] dbisim((true)&(int_ActualHV__!TID_Watchdog_s0_t5.in?ActualHV:{ActualHV|ActualHV <- core_real, true} -> set_ActualHV!ActualHV -> SKIP ;  ((MStop /\ exited -> SKIP) ; SKIP
					 ; ActualHVRead::enter -> SKIP)))
					[] dbisim((true)&(int_ActualHV__!TID_Watchdog_s0_t6.in?ActualHV:{ActualHV|ActualHV <- core_real, true} -> set_ActualHV!ActualHV -> SKIP ;  ((MStop /\ exited -> SKIP) ; SKIP
					 ; PowerAndActualHVRead::enter -> SKIP)))
					[] dbisim((true)&(ext_pow24VStatus__!TID_Watchdog_s0_t7.in?power:{power|power <- Power, true} -> set_power!power -> SKIP ;  ((MStop /\ exited -> SKIP) ; SKIP
					 ; PowerAndActualHVRead::enter -> SKIP)))
					[] dbisim(((ActualHV<underLimit))&(internal__!TID_Watchdog_s0_t8 -> SKIP ;  ((MStop /\ exited -> SKIP) ; true&(int_DisableHV.out -> SKIP)
					 ; f0::enter -> SKIP)))
					[] dbisim(((ActualHV>overLimit))&(internal__!TID_Watchdog_s0_t9 -> SKIP ;  ((MStop /\ exited -> SKIP) ; true&(int_DisableHV.out -> SKIP)
					 ; f0::enter -> SKIP)))
					[] dbisim(((power==Power_Off))&(internal__!TID_Watchdog_s0_t10 -> SKIP ;  ((MStop /\ exited -> SKIP) ; true&(int_DisableHV.out -> SKIP)
					 ; f0::enter -> SKIP)))
					)
					 ; Transitions(id__)
					
					ComposeNodes(id__) = [| { up__ } |] proc__ : {i0::D__(id__),f0::D__(id__),Waiting::D__(id__),PowerStatusRead::D__(id__),ActualHVRead::D__(id__),PowerAndActualHVRead::D__(id__)} @ proc__
					
					ComposeNodes_VS_O(id__) = [| { up__ } |] proc__ : {i0::VS_O__(id__),f0::VS_O__(id__),Waiting::VS_O__(id__),PowerStatusRead::VS_O__(id__),ActualHVRead::VS_O__(id__),PowerAndActualHVRead::VS_O__(id__)} @ proc__
				
				endmodule
				----------------------------------------------------------------------
				
				
				TransitionSync = {|internal__.TID_Watchdog_t0,
				internal__.TID_Watchdog_t1|}
				
				-- The following is obviously not efficient for FDR to compile.
				-- For efficiency reasons a stepwise composition should be implemented instead.
				ComposeNodes(id__) = [| { up__ } |] proc__ : {i0::D__(id__),s0::D__(id__)} @ proc__
				
				ComposeNodes_VS_O(id__) = [| { up__ } |] proc__ : {i0::VS_O__(id__),s0::VS_O__(id__)} @ proc__
				
				Transitions(id__) = ((up__ -> SKIP
				[] dbisim((true)&(internal__!TID_Watchdog_t0 -> SKIP ;  ((true&(int_overLimit.in?overLimit -> set_overLimit!overLimit -> SKIP);true&(int_underLimit.in?underLimit -> set_underLimit!underLimit -> SKIP)
				 ; s0::enter -> SKIP))))
				[] dbisim((true)&(internal__!TID_Watchdog_t1 -> SKIP ;  ((MStop /\ exited -> SKIP) ; SKIP
				 ; s0::enter -> SKIP)))
				)
				) ; Transitions(id__)
				
				Behaviours(id__) = ((
				 ((ComposeNodes(id__)[[s0::exit <- x__ | x__ <- {|exit,internal__.TID_Watchdog_t1|}]]
				 [[i0::exit <- x__ | x__ <- {|internal__.TID_Watchdog_t0|}]]
				 [[  
				 s0::exited <- exited
				 ]]
				 )
				  [[ up__ <- x__ | x__ <- {| up__ |} ]] 
				 )
				 [| union(union(union(enterCSet,TransitionSync),{| exited |}),{|up__
				|}) |]
				 ((i0::enter -> Transitions(id__))
				  [[ up__ <- x__ | x__ <- {| up__ |} ]]
				 )
				)
				\ union(enterCSet,{| exited, internal__ |})
				 [| {exit} |] STOP)
				
				Behaviours_VS_O(id__) = ((
				 ((ComposeNodes_VS_O(id__)[[s0::exit <- x__ | x__ <- {|exit,internal__.TID_Watchdog_t1|}]]
				 [[i0::exit <- x__ | x__ <- {|internal__.TID_Watchdog_t0|}]]
				 [[  
				 s0::exited <- exited
				 ]]
				 )
				  [[ up__ <- x__ | x__ <- {| up__ |} ]] 
				 )
				 [| union(union(union(enterCSet,TransitionSync),{| exited |}),{|up__
				|}) |]
				 ((i0::enter -> Transitions(id__))
				  [[ up__ <- x__ | x__ <- {| up__ |} ]]
				 )
				)
				\ union(enterCSet,{| exited, internal__ |})
				 [| {exit} |] STOP)
				
				
				-- memory process
				Memory_overLimit(overLimit) =
					get_overLimit!overLimit -> Memory_overLimit(overLimit)
					[]
					set_overLimit?x__ -> Memory_overLimit(x__)
				Memory_underLimit(underLimit) =
					get_underLimit!underLimit -> Memory_underLimit(underLimit)
					[]
					set_underLimit?x__ -> Memory_underLimit(x__)
				Memory_ActualHV(ActualHV) =
					get_ActualHV!ActualHV -> Memory_ActualHV(ActualHV)
					[]
					set_ActualHV?x__ -> Memory_ActualHV(x__)
				Memory_power(power) =
					get_power!power -> Memory_power(power)
					[]
					set_power?x__ -> Memory_power(x__)
				
				Memory(id__) =
					Memory_overLimit(0)
					|||
					Memory_underLimit(0)
					|||
					Memory_ActualHV(0)
					|||
					Memory_power(Power_On)
				
				SharedVariableMemory(id__) =
					STOP
				
				SharedVariablesSyncSet = {||}
				
				SharedVariableHidingSet = {||}
				
				MachineMemorySyncSet = 
					{|get_overLimit,set_overLimit,
					get_underLimit,set_underLimit,
					get_ActualHV,set_ActualHV,
					get_power,set_power|}
					
				MachineMemoryHidingSet = {|get_overLimit,set_overLimit,
				get_underLimit,set_underLimit,
				get_ActualHV,set_ActualHV,
				get_power,set_power|}
				
				MachineInternalEvents = {|
					internal__
				|}
				
								
				-- main process
				
				STM(id__) = (
					(
						(AUX(id__)[[ up__ <- x__ | x__ <- {||} ]]
					 	[| { up__ } |]
					 	SKIP)
					 /+ SharedVariablesSyncSet +\
					 SharedVariableMemory(id__))
					 \SharedVariableHidingSet
				)
				
				AUX(id__) = (
					(
						(Behaviours(id__)
						 [|MachineMemorySyncSet|]
						 Memory(id__))
					)[[
						int_overLimit__.x____ <- int_overLimit,
						int_underLimit__.x____ <- int_underLimit,
						int_DisableHV__.x____ <- int_DisableHV,
						int_ActualHV__.x____ <- int_ActualHV,
						ext_pow24VStatus__.x____ <- ext_pow24VStatus
						| x____ <- TIDS
					]]
					\MachineMemoryHidingSet
				)
				[|{|terminate|}|>SKIP\MachineInternalEvents
				
				
				
				STM_VS_O(id__) = (
					(
						(AUX_VS_O(id__)[[ up__ <- x__ | x__ <- {||} ]]
					 	[| { up__ } |]
					 	SKIP)
					 /+ SharedVariablesSyncSet +\
					 SharedVariableMemory(id__))
					 \SharedVariableHidingSet
				)
				
				AUX_VS_O(id__) = (
					(
						(Behaviours_VS_O(id__)
						 [|MachineMemorySyncSet|]
						 Memory(id__))
					)[[
						int_overLimit__.x____ <- int_overLimit,
						int_underLimit__.x____ <- int_underLimit,
						int_DisableHV__.x____ <- int_DisableHV,
						int_ActualHV__.x____ <- int_ActualHV,
						ext_pow24VStatus__.x____ <- ext_pow24VStatus
						| x____ <- TIDS
					]]
					\MachineMemoryHidingSet
				)
				[|{|terminate|}|>SKIP\MachineInternalEvents
				
				
				
				-- definition of the behaviour of state machines (default, optimised, visible, visible and optimised)
				
				FVS__(id__) = STM_VS_O(id__)
				
				D__(id__) = STM(id__) \ internal_events
				O__(id__) = sbisim(diamond(D__(id__)))
				VS__(id__) = FVS__(id__)
				VS_O__(id__) = sbisim(diamond(FVS__(id__)))
				HEXT__(id__) = O__(id__) [|shared_variable_events|] SKIP
				HUP__(id__) = O__(id__) [|{up__}|] SKIP
			endmodule
			
				-- undefined operations
				
				-- declaring controller memory
				Memory(id__) = SKIP
				
				D__(id__) = 	((
						stm_ref0::D__(id__)[[
							stm_ref0::terminate <- terminate,
							stm_ref0::int_ActualHV <- int_ActualHV,
							stm_ref0::int_DisableHV <- int_DisableHV,
							stm_ref0::int_underLimit <- int_underLimit,
							stm_ref0::int_overLimit <- int_overLimit,
							stm_ref0::ext_pow24VStatus <- ext_pow24VStatus
						]]
					)
						[|
							union(
								{|
								|},
								{|
								|}
							)
						|]
					Memory(id__)
				)
				\ union(
					{|
					|},
					{|
					|}
				)
				[|{|terminate|}|>SKIP
				
				-- VS version
				VS__(id__) = 	((
						stm_ref0::VS__(id__)[[
							stm_ref0::terminate <- terminate,
							stm_ref0::int_ActualHV <- int_ActualHV,
							stm_ref0::int_DisableHV <- int_DisableHV,
							stm_ref0::int_underLimit <- int_underLimit,
							stm_ref0::int_overLimit <- int_overLimit,
							stm_ref0::ext_pow24VStatus <- ext_pow24VStatus
						]]
					)
						[|
							union(
								{|
								|},
								{|
								|}
							)
						|]
					Memory(id__)
				)
				\ union(
					{|
					|},
					{|
					|}
				)
				[|{|terminate|}|>SKIP
			
				-- O version (optimised) THESE TWO PROCESSES SHOULD BE KEPT IN SYNC WITH THE ABOVE TWO
				O__(id__) = sbisim(diamond(	((
						stm_ref0::O__(id__)[[
							stm_ref0::terminate <- terminate,
							stm_ref0::int_ActualHV <- int_ActualHV,
							stm_ref0::int_DisableHV <- int_DisableHV,
							stm_ref0::int_underLimit <- int_underLimit,
							stm_ref0::int_overLimit <- int_overLimit,
							stm_ref0::ext_pow24VStatus <- ext_pow24VStatus
						]]
					)
						[|
							union(
								{|
								|},
								{|
								|}
							)
						|]
					Memory(id__)
				)
				\ union(
					{|
					|},
					{|
					|}
				)
				[|{|terminate|}|>SKIP
				))
								
				-- VS_O version
				VS_O__(id__) = sbisim(diamond(	((
						stm_ref0::VS_O__(id__)[[
							stm_ref0::terminate <- terminate,
							stm_ref0::int_ActualHV <- int_ActualHV,
							stm_ref0::int_DisableHV <- int_DisableHV,
							stm_ref0::int_underLimit <- int_underLimit,
							stm_ref0::int_overLimit <- int_overLimit,
							stm_ref0::ext_pow24VStatus <- ext_pow24VStatus
						]]
					)
						[|
							union(
								{|
								|},
								{|
								|}
							)
						|]
					Memory(id__)
				)
				\ union(
					{|
					|},
					{|
					|}
				)
				[|{|terminate|}|>SKIP
				))
			
				HEXT(id__) = O__(id__) [|shared_variable_events|] SKIP			
	
		endmodule
		module ctrl_ref2
			shared_variable_events = {|
			|}
			
		exports
			transparent diamond
			transparent sbisim
			transparent dbisim
			transparent chase
	
			-- declaring controller events
			channel ext_pow24VStatus: InOut.Power
			channel ext_pow24_1: InOut.Power
			channel ext_pow24_2: InOut.Power
			
			
			
			-- declaring call and ret events for undefined operations
			
			-- declaring controller termination channel		
			channel terminate
	
			-- defined operations
		
			-- declaring machines
			module stm0
			exports
				transparent diamond
				transparent sbisim
				transparent dbisim
				transparent chase
			
				-- flow channels
				channel internal__ : TIDS
				
				-- The following are now declared per state (using modules)
				--channel enter, entered: NIDS
				channel exit
				channel exited
				channel terminate
				
				-- variable channels
				channel get_power, set_power, setL_power, setR_power: Power
				
				-- shared variable channels
				
				-- local variable channels for defined operations that are required by the state machine
				
				-- declaring state machine events
				channel ext_pow24VStatus__: TIDS.InOut.Power
				channel ext_pow24VStatus: InOut.Power
				channel ext_pow24_1__: TIDS.InOut.Power
				channel ext_pow24_1: InOut.Power
				channel ext_pow24_2__: TIDS.InOut.Power
				channel ext_pow24_2: InOut.Power
				
				-- declaring call and ret events for undefined operations
				
				enterCSet = {|
				i0::enter,
				s0::enter
				|}
				
				enteredCSet = 	{|
				s0::entered
				|}
				
				internal_events = union(enteredCSet,union(enterCSet,{|exit,exited|}))
				
				shared_variable_events = {|
				|}
			
				-- Only the undefined operations are declared here.
				-- If the state machine is in isolation, all required operations will be undefined.
				-- If it is in the context of a controller, the required operations not provided by the
				-- controller will be declared here, and the defined operations will be defined in the
				-- context of the Controller module, and therefore within scope of the state machien module.
				
				
				-- declaring identifiers of transitions
				datatype TIDS = NULLTRANSITION__
				              | TID_stm0_t0
				              | TID_stm0_t1
				
				-- declaring all nodes
				
				----------------------------------------------------------------------
				-- Initial: i0
				module i0
				exports
				
					channel enter, exit
					
					D__(id__) = dbisim(let
								Inactive = (MStop /\ enter -> SKIP) ; (MStop /\ exit -> Inactive)
							within
								Inactive)
								
					VS_O__(id__) = D__(id__)
				
				endmodule
				----------------------------------------------------------------------
				
				
				----------------------------------------------------------------------
				-- State: s0
				module s0
				
				enterCSet = {}
				
				enteredCSet = {}
				
				exports
				
					--  Declarations
					-- declaring identifiers of transitions
					datatype TIDS = NULLTRANSITION__
					
					channel internal__ : TIDS
					channel enter, entered, exit, exited
					channel enteredL, enteredR
					channel end__
					
									
					
					--	Nodes
					-- declaring all nodes
					
					TransitionSync = {||}
					
					--	Rule: behaviours(Node)
					--  Note that FDR has problems with efficiently compiling the process below
					-- 	if using a different recursion pattern.
					D__(id__) = 
					dbisim(let
						Inactive = (MStop /\ enter -> SKIP) ; true&(ext_pow24VStatus.in?power -> set_power!power -> SKIP)
						 ; 
									Behaviour ; 
									SKIP ; 
									exited -> SKIP ; Inactive
					
						Behaviour = entered -> ((SKIP ; MStop) /\ exit -> SKIP)
					within
						Inactive)
						
					VS_O__(id__) = 
						dbisim(let
							Inactive = (MStop /\ enter -> SKIP) ; true&(ext_pow24VStatus.in?power -> set_power!power -> SKIP)
							 ; 
										Behaviour ; 
										SKIP ; 
										exited -> SKIP ; Inactive
					
							Behaviour = entered -> ((SKIP ; MStop) /\ exit -> SKIP)
						within
							Inactive)
					
				
				endmodule
				----------------------------------------------------------------------
				
				
				TransitionSync = {|internal__.TID_stm0_t0,
				internal__.TID_stm0_t1|}
				
				-- The following is obviously not efficient for FDR to compile.
				-- For efficiency reasons a stepwise composition should be implemented instead.
				ComposeNodes(id__) = [| { up__ } |] proc__ : {i0::D__(id__),s0::D__(id__)} @ proc__
				
				ComposeNodes_VS_O(id__) = [| { up__ } |] proc__ : {i0::VS_O__(id__),s0::VS_O__(id__)} @ proc__
				
				Transitions(id__) = ((up__ -> SKIP
				[] dbisim((true)&(internal__!TID_stm0_t0 -> SKIP ;  ((SKIP
				 ; s0::enter -> SKIP))))
				[] dbisim((true)&(internal__!TID_stm0_t1 -> SKIP ;  ((MStop /\ exited -> SKIP) ; get_power?power -> true&(ext_pow24_1.out!power -> SKIP);get_power?power -> true&(ext_pow24_2.out!power -> SKIP)
				 ; s0::enter -> SKIP)))
				)
				) ; Transitions(id__)
				
				Behaviours(id__) = ((
				 ((ComposeNodes(id__)[[s0::exit <- x__ | x__ <- {|exit,internal__.TID_stm0_t1|}]]
				 [[i0::exit <- x__ | x__ <- {|internal__.TID_stm0_t0|}]]
				 [[  
				 s0::exited <- exited
				 ]]
				 )
				  [[ up__ <- x__ | x__ <- {| up__ |} ]] 
				 )
				 [| union(union(union(enterCSet,TransitionSync),{| exited |}),{|up__
				|}) |]
				 ((i0::enter -> Transitions(id__))
				  [[ up__ <- x__ | x__ <- {| up__ |} ]]
				 )
				)
				\ union(enterCSet,{| exited, internal__ |})
				 [| {exit} |] STOP)
				
				Behaviours_VS_O(id__) = ((
				 ((ComposeNodes_VS_O(id__)[[s0::exit <- x__ | x__ <- {|exit,internal__.TID_stm0_t1|}]]
				 [[i0::exit <- x__ | x__ <- {|internal__.TID_stm0_t0|}]]
				 [[  
				 s0::exited <- exited
				 ]]
				 )
				  [[ up__ <- x__ | x__ <- {| up__ |} ]] 
				 )
				 [| union(union(union(enterCSet,TransitionSync),{| exited |}),{|up__
				|}) |]
				 ((i0::enter -> Transitions(id__))
				  [[ up__ <- x__ | x__ <- {| up__ |} ]]
				 )
				)
				\ union(enterCSet,{| exited, internal__ |})
				 [| {exit} |] STOP)
				
				
				-- memory process
				Memory_power(power) =
					get_power!power -> Memory_power(power)
					[]
					set_power?x__ -> Memory_power(x__)
				
				Memory(id__) =
					Memory_power(Power_On)
				
				SharedVariableMemory(id__) =
					STOP
				
				SharedVariablesSyncSet = {||}
				
				SharedVariableHidingSet = {||}
				
				MachineMemorySyncSet = 
					{|get_power,set_power|}
					
				MachineMemoryHidingSet = {|get_power,set_power|}
				
				MachineInternalEvents = {|
					internal__
				|}
				
								
				-- main process
				
				STM(id__) = (
					(
						(AUX(id__)[[ up__ <- x__ | x__ <- {||} ]]
					 	[| { up__ } |]
					 	SKIP)
					 /+ SharedVariablesSyncSet +\
					 SharedVariableMemory(id__))
					 \SharedVariableHidingSet
				)
				
				AUX(id__) = (
					(
						(Behaviours(id__)
						 [|MachineMemorySyncSet|]
						 Memory(id__))
					)[[
						ext_pow24VStatus__.x____ <- ext_pow24VStatus,
						ext_pow24_1__.x____ <- ext_pow24_1,
						ext_pow24_2__.x____ <- ext_pow24_2
						| x____ <- TIDS
					]]
					\MachineMemoryHidingSet
				)
				[|{|terminate|}|>SKIP\MachineInternalEvents
				
				
				
				STM_VS_O(id__) = (
					(
						(AUX_VS_O(id__)[[ up__ <- x__ | x__ <- {||} ]]
					 	[| { up__ } |]
					 	SKIP)
					 /+ SharedVariablesSyncSet +\
					 SharedVariableMemory(id__))
					 \SharedVariableHidingSet
				)
				
				AUX_VS_O(id__) = (
					(
						(Behaviours_VS_O(id__)
						 [|MachineMemorySyncSet|]
						 Memory(id__))
					)[[
						ext_pow24VStatus__.x____ <- ext_pow24VStatus,
						ext_pow24_1__.x____ <- ext_pow24_1,
						ext_pow24_2__.x____ <- ext_pow24_2
						| x____ <- TIDS
					]]
					\MachineMemoryHidingSet
				)
				[|{|terminate|}|>SKIP\MachineInternalEvents
				
				
				
				-- definition of the behaviour of state machines (default, optimised, visible, visible and optimised)
				
				FVS__(id__) = STM_VS_O(id__)
				
				D__(id__) = STM(id__) \ internal_events
				O__(id__) = sbisim(diamond(D__(id__)))
				VS__(id__) = FVS__(id__)
				VS_O__(id__) = sbisim(diamond(FVS__(id__)))
				HEXT__(id__) = O__(id__) [|shared_variable_events|] SKIP
				HUP__(id__) = O__(id__) [|{up__}|] SKIP
			endmodule
			
				-- undefined operations
				
				-- declaring controller memory
				Memory(id__) = SKIP
				
				D__(id__) = 	((
						stm0::D__(id__)[[
							stm0::terminate <- terminate,
							stm0::ext_pow24VStatus <- ext_pow24VStatus,
							stm0::ext_pow24_1 <- ext_pow24_1,
							stm0::ext_pow24_2 <- ext_pow24_2
						]]
					)
						[|
							union(
								{|
								|},
								{|
								|}
							)
						|]
					Memory(id__)
				)
				\ union(
					{|
					|},
					{|
					|}
				)
				[|{|terminate|}|>SKIP
				
				-- VS version
				VS__(id__) = 	((
						stm0::VS__(id__)[[
							stm0::terminate <- terminate,
							stm0::ext_pow24VStatus <- ext_pow24VStatus,
							stm0::ext_pow24_1 <- ext_pow24_1,
							stm0::ext_pow24_2 <- ext_pow24_2
						]]
					)
						[|
							union(
								{|
								|},
								{|
								|}
							)
						|]
					Memory(id__)
				)
				\ union(
					{|
					|},
					{|
					|}
				)
				[|{|terminate|}|>SKIP
			
				-- O version (optimised) THESE TWO PROCESSES SHOULD BE KEPT IN SYNC WITH THE ABOVE TWO
				O__(id__) = sbisim(diamond(	((
						stm0::O__(id__)[[
							stm0::terminate <- terminate,
							stm0::ext_pow24VStatus <- ext_pow24VStatus,
							stm0::ext_pow24_1 <- ext_pow24_1,
							stm0::ext_pow24_2 <- ext_pow24_2
						]]
					)
						[|
							union(
								{|
								|},
								{|
								|}
							)
						|]
					Memory(id__)
				)
				\ union(
					{|
					|},
					{|
					|}
				)
				[|{|terminate|}|>SKIP
				))
								
				-- VS_O version
				VS_O__(id__) = sbisim(diamond(	((
						stm0::VS_O__(id__)[[
							stm0::terminate <- terminate,
							stm0::ext_pow24VStatus <- ext_pow24VStatus,
							stm0::ext_pow24_1 <- ext_pow24_1,
							stm0::ext_pow24_2 <- ext_pow24_2
						]]
					)
						[|
							union(
								{|
								|},
								{|
								|}
							)
						|]
					Memory(id__)
				)
				\ union(
					{|
					|},
					{|
					|}
				)
				[|{|terminate|}|>SKIP
				))
			
				HEXT(id__) = O__(id__) [|shared_variable_events|] SKIP			
	
		endmodule
		module ctrl_ref3
			shared_variable_events = {|
			|}
			
		exports
			transparent diamond
			transparent sbisim
			transparent dbisim
			transparent chase
	
			-- declaring controller events
			channel int_ActualHV: InOut.core_real
			channel ActualHV_1: InOut.core_real
			channel ActualHV_2: InOut.core_real
			
			
			
			-- declaring call and ret events for undefined operations
			
			-- declaring controller termination channel		
			channel terminate
	
			-- defined operations
		
			-- declaring machines
			module stm0
			exports
				transparent diamond
				transparent sbisim
				transparent dbisim
				transparent chase
			
				-- flow channels
				channel internal__ : TIDS
				
				-- The following are now declared per state (using modules)
				--channel enter, entered: NIDS
				channel exit
				channel exited
				channel terminate
				
				-- variable channels
				channel get_ActualHV, set_ActualHV, setL_ActualHV, setR_ActualHV: core_real
				
				-- shared variable channels
				
				-- local variable channels for defined operations that are required by the state machine
				
				-- declaring state machine events
				channel int_ActualHV__: TIDS.InOut.core_real
				channel int_ActualHV: InOut.core_real
				channel ActualHV_1__: TIDS.InOut.core_real
				channel ActualHV_1: InOut.core_real
				channel ActualHV_2__: TIDS.InOut.core_real
				channel ActualHV_2: InOut.core_real
				
				-- declaring call and ret events for undefined operations
				
				enterCSet = {|
				i0::enter,
				s0::enter
				|}
				
				enteredCSet = 	{|
				s0::entered
				|}
				
				internal_events = union(enteredCSet,union(enterCSet,{|exit,exited|}))
				
				shared_variable_events = {|
				|}
			
				-- Only the undefined operations are declared here.
				-- If the state machine is in isolation, all required operations will be undefined.
				-- If it is in the context of a controller, the required operations not provided by the
				-- controller will be declared here, and the defined operations will be defined in the
				-- context of the Controller module, and therefore within scope of the state machien module.
				
				
				-- declaring identifiers of transitions
				datatype TIDS = NULLTRANSITION__
				              | TID_stm0_t0
				              | TID_stm0_t1
				
				-- declaring all nodes
				
				----------------------------------------------------------------------
				-- Initial: i0
				module i0
				exports
				
					channel enter, exit
					
					D__(id__) = dbisim(let
								Inactive = (MStop /\ enter -> SKIP) ; (MStop /\ exit -> Inactive)
							within
								Inactive)
								
					VS_O__(id__) = D__(id__)
				
				endmodule
				----------------------------------------------------------------------
				
				
				----------------------------------------------------------------------
				-- State: s0
				module s0
				
				enterCSet = {}
				
				enteredCSet = {}
				
				exports
				
					--  Declarations
					-- declaring identifiers of transitions
					datatype TIDS = NULLTRANSITION__
					
					channel internal__ : TIDS
					channel enter, entered, exit, exited
					channel enteredL, enteredR
					channel end__
					
									
					
					--	Nodes
					-- declaring all nodes
					
					TransitionSync = {||}
					
					--	Rule: behaviours(Node)
					--  Note that FDR has problems with efficiently compiling the process below
					-- 	if using a different recursion pattern.
					D__(id__) = 
					dbisim(let
						Inactive = (MStop /\ enter -> SKIP) ; true&(int_ActualHV.in?ActualHV -> set_ActualHV!ActualHV -> SKIP)
						 ; 
									Behaviour ; 
									SKIP ; 
									exited -> SKIP ; Inactive
					
						Behaviour = entered -> ((SKIP ; MStop) /\ exit -> SKIP)
					within
						Inactive)
						
					VS_O__(id__) = 
						dbisim(let
							Inactive = (MStop /\ enter -> SKIP) ; true&(int_ActualHV.in?ActualHV -> set_ActualHV!ActualHV -> SKIP)
							 ; 
										Behaviour ; 
										SKIP ; 
										exited -> SKIP ; Inactive
					
							Behaviour = entered -> ((SKIP ; MStop) /\ exit -> SKIP)
						within
							Inactive)
					
				
				endmodule
				----------------------------------------------------------------------
				
				
				TransitionSync = {|internal__.TID_stm0_t0,
				internal__.TID_stm0_t1|}
				
				-- The following is obviously not efficient for FDR to compile.
				-- For efficiency reasons a stepwise composition should be implemented instead.
				ComposeNodes(id__) = [| { up__ } |] proc__ : {i0::D__(id__),s0::D__(id__)} @ proc__
				
				ComposeNodes_VS_O(id__) = [| { up__ } |] proc__ : {i0::VS_O__(id__),s0::VS_O__(id__)} @ proc__
				
				Transitions(id__) = ((up__ -> SKIP
				[] dbisim((true)&(internal__!TID_stm0_t0 -> SKIP ;  ((SKIP
				 ; s0::enter -> SKIP))))
				[] dbisim((true)&(internal__!TID_stm0_t1 -> SKIP ;  ((MStop /\ exited -> SKIP) ; get_ActualHV?ActualHV -> true&(ActualHV_1.out!ActualHV -> SKIP);get_ActualHV?ActualHV -> true&(ActualHV_2.out!ActualHV -> SKIP)
				 ; s0::enter -> SKIP)))
				)
				) ; Transitions(id__)
				
				Behaviours(id__) = ((
				 ((ComposeNodes(id__)[[s0::exit <- x__ | x__ <- {|exit,internal__.TID_stm0_t1|}]]
				 [[i0::exit <- x__ | x__ <- {|internal__.TID_stm0_t0|}]]
				 [[  
				 s0::exited <- exited
				 ]]
				 )
				  [[ up__ <- x__ | x__ <- {| up__ |} ]] 
				 )
				 [| union(union(union(enterCSet,TransitionSync),{| exited |}),{|up__
				|}) |]
				 ((i0::enter -> Transitions(id__))
				  [[ up__ <- x__ | x__ <- {| up__ |} ]]
				 )
				)
				\ union(enterCSet,{| exited, internal__ |})
				 [| {exit} |] STOP)
				
				Behaviours_VS_O(id__) = ((
				 ((ComposeNodes_VS_O(id__)[[s0::exit <- x__ | x__ <- {|exit,internal__.TID_stm0_t1|}]]
				 [[i0::exit <- x__ | x__ <- {|internal__.TID_stm0_t0|}]]
				 [[  
				 s0::exited <- exited
				 ]]
				 )
				  [[ up__ <- x__ | x__ <- {| up__ |} ]] 
				 )
				 [| union(union(union(enterCSet,TransitionSync),{| exited |}),{|up__
				|}) |]
				 ((i0::enter -> Transitions(id__))
				  [[ up__ <- x__ | x__ <- {| up__ |} ]]
				 )
				)
				\ union(enterCSet,{| exited, internal__ |})
				 [| {exit} |] STOP)
				
				
				-- memory process
				Memory_ActualHV(ActualHV) =
					get_ActualHV!ActualHV -> Memory_ActualHV(ActualHV)
					[]
					set_ActualHV?x__ -> Memory_ActualHV(x__)
				
				Memory(id__) =
					Memory_ActualHV(0)
				
				SharedVariableMemory(id__) =
					STOP
				
				SharedVariablesSyncSet = {||}
				
				SharedVariableHidingSet = {||}
				
				MachineMemorySyncSet = 
					{|get_ActualHV,set_ActualHV|}
					
				MachineMemoryHidingSet = {|get_ActualHV,set_ActualHV|}
				
				MachineInternalEvents = {|
					internal__
				|}
				
								
				-- main process
				
				STM(id__) = (
					(
						(AUX(id__)[[ up__ <- x__ | x__ <- {||} ]]
					 	[| { up__ } |]
					 	SKIP)
					 /+ SharedVariablesSyncSet +\
					 SharedVariableMemory(id__))
					 \SharedVariableHidingSet
				)
				
				AUX(id__) = (
					(
						(Behaviours(id__)
						 [|MachineMemorySyncSet|]
						 Memory(id__))
					)[[
						int_ActualHV__.x____ <- int_ActualHV,
						ActualHV_1__.x____ <- ActualHV_1,
						ActualHV_2__.x____ <- ActualHV_2
						| x____ <- TIDS
					]]
					\MachineMemoryHidingSet
				)
				[|{|terminate|}|>SKIP\MachineInternalEvents
				
				
				
				STM_VS_O(id__) = (
					(
						(AUX_VS_O(id__)[[ up__ <- x__ | x__ <- {||} ]]
					 	[| { up__ } |]
					 	SKIP)
					 /+ SharedVariablesSyncSet +\
					 SharedVariableMemory(id__))
					 \SharedVariableHidingSet
				)
				
				AUX_VS_O(id__) = (
					(
						(Behaviours_VS_O(id__)
						 [|MachineMemorySyncSet|]
						 Memory(id__))
					)[[
						int_ActualHV__.x____ <- int_ActualHV,
						ActualHV_1__.x____ <- ActualHV_1,
						ActualHV_2__.x____ <- ActualHV_2
						| x____ <- TIDS
					]]
					\MachineMemoryHidingSet
				)
				[|{|terminate|}|>SKIP\MachineInternalEvents
				
				
				
				-- definition of the behaviour of state machines (default, optimised, visible, visible and optimised)
				
				FVS__(id__) = STM_VS_O(id__)
				
				D__(id__) = STM(id__) \ internal_events
				O__(id__) = sbisim(diamond(D__(id__)))
				VS__(id__) = FVS__(id__)
				VS_O__(id__) = sbisim(diamond(FVS__(id__)))
				HEXT__(id__) = O__(id__) [|shared_variable_events|] SKIP
				HUP__(id__) = O__(id__) [|{up__}|] SKIP
			endmodule
			
				-- undefined operations
				
				-- declaring controller memory
				Memory(id__) = SKIP
				
				D__(id__) = 	((
						stm0::D__(id__)[[
							stm0::terminate <- terminate,
							stm0::int_ActualHV <- int_ActualHV,
							stm0::ActualHV_1 <- ActualHV_1,
							stm0::ActualHV_2 <- ActualHV_2
						]]
					)
						[|
							union(
								{|
								|},
								{|
								|}
							)
						|]
					Memory(id__)
				)
				\ union(
					{|
					|},
					{|
					|}
				)
				[|{|terminate|}|>SKIP
				
				-- VS version
				VS__(id__) = 	((
						stm0::VS__(id__)[[
							stm0::terminate <- terminate,
							stm0::int_ActualHV <- int_ActualHV,
							stm0::ActualHV_1 <- ActualHV_1,
							stm0::ActualHV_2 <- ActualHV_2
						]]
					)
						[|
							union(
								{|
								|},
								{|
								|}
							)
						|]
					Memory(id__)
				)
				\ union(
					{|
					|},
					{|
					|}
				)
				[|{|terminate|}|>SKIP
			
				-- O version (optimised) THESE TWO PROCESSES SHOULD BE KEPT IN SYNC WITH THE ABOVE TWO
				O__(id__) = sbisim(diamond(	((
						stm0::O__(id__)[[
							stm0::terminate <- terminate,
							stm0::int_ActualHV <- int_ActualHV,
							stm0::ActualHV_1 <- ActualHV_1,
							stm0::ActualHV_2 <- ActualHV_2
						]]
					)
						[|
							union(
								{|
								|},
								{|
								|}
							)
						|]
					Memory(id__)
				)
				\ union(
					{|
					|},
					{|
					|}
				)
				[|{|terminate|}|>SKIP
				))
								
				-- VS_O version
				VS_O__(id__) = sbisim(diamond(	((
						stm0::VS_O__(id__)[[
							stm0::terminate <- terminate,
							stm0::int_ActualHV <- int_ActualHV,
							stm0::ActualHV_1 <- ActualHV_1,
							stm0::ActualHV_2 <- ActualHV_2
						]]
					)
						[|
							union(
								{|
								|},
								{|
								|}
							)
						|]
					Memory(id__)
				)
				\ union(
					{|
					|},
					{|
					|}
				)
				[|{|terminate|}|>SKIP
				))
			
				HEXT(id__) = O__(id__) [|shared_variable_events|] SKIP			
	
		endmodule
	
	-- declaring module memory
	Memory(id__) = SKIP
	
	D__(id__) = let
		Buffer0(<v>) = 
			ctrl_ref1::int_DisableHV.out -> Buffer0(<1>) 
			[]
			ctrl_ref0::int_DisableHV.in -> Buffer0(<>)
		Buffer0(<>) = ctrl_ref1::int_DisableHV.out -> Buffer0(<1>)
		Buffer1(<v>) = 
			ctrl_ref0::int_underLimit.out?x -> Buffer1(<x>)
			[]
			ctrl_ref1::int_underLimit.in!v -> Buffer1(<>)
		Buffer1(<>) = ctrl_ref0::int_underLimit.out?x -> Buffer1(<x>)
		Buffer2(<v>) = 
			ctrl_ref0::int_overLimit.out?x -> Buffer2(<x>)
			[]
			ctrl_ref1::int_overLimit.in!v -> Buffer2(<>)
		Buffer2(<>) = ctrl_ref0::int_overLimit.out?x -> Buffer2(<x>)
		Buffer3(<v>) = 
			ctrl_ref0::int_ActualHV.out?x -> Buffer3(<x>)
			[]
			ctrl_ref3::int_ActualHV.in!v -> Buffer3(<>)
		Buffer3(<>) = ctrl_ref0::int_ActualHV.out?x -> Buffer3(<x>)
		Buffer4(<v>) = 
			ctrl_ref3::ActualHV_1.out?x -> Buffer4(<x>)
			[]
			ctrl_ref1::int_ActualHV.in!v -> Buffer4(<>)
		Buffer4(<>) = ctrl_ref3::ActualHV_1.out?x -> Buffer4(<x>)
		Buffer5(<v>) = 
			ctrl_ref2::ext_pow24_2.out?x -> Buffer5(<x>)
			[]
			ctrl_ref1::ext_pow24VStatus.in!v -> Buffer5(<>)
		Buffer5(<>) = ctrl_ref2::ext_pow24_2.out?x -> Buffer5(<x>)
		Buffer6(<v>) = 
			ctrl_ref2::ext_pow24_1.out?x -> Buffer6(<x>)
			[]
			ctrl_ref0::ext_pow24VStatus.in!v -> Buffer6(<>)
		Buffer6(<>) = ctrl_ref2::ext_pow24_1.out?x -> Buffer6(<x>)
		
	within
		(
			(
				(Buffer0(<>)|||
				Buffer1(<>)|||
				Buffer2(<>)|||
				Buffer3(<>)|||
				Buffer4(<>)|||
				Buffer5(<>)|||
				Buffer6(<>)
				)
					[|{|ctrl_ref0::int_DisableHV,ctrl_ref1::int_DisableHV,ctrl_ref1::int_underLimit,ctrl_ref0::int_underLimit,ctrl_ref1::int_overLimit,ctrl_ref0::int_overLimit,ctrl_ref3::int_ActualHV,ctrl_ref0::int_ActualHV,ctrl_ref1::int_ActualHV,ctrl_ref3::ActualHV_1,ctrl_ref1::ext_pow24VStatus,ctrl_ref2::ext_pow24_2,ctrl_ref0::ext_pow24VStatus,ctrl_ref2::ext_pow24_1|}|]
				(
					(
						(
							ctrl_ref0::D__(id__)[[
								ctrl_ref0::terminate <- terminate,
								ctrl_ref0::ext_setPoint <- ext_setPoint,
								ctrl_ref0::int_pwmSignal <- int_pwmSignal,
								ctrl_ref0::currentState <- currentState
							]]
						)
							[|{|terminate|}|]
						(
							(
								ctrl_ref1::D__(id__)[[
									ctrl_ref1::terminate <- terminate
								]]
							)
								[|{|terminate|}|]
							(
								(
									ctrl_ref2::D__(id__)[[
										ctrl_ref2::terminate <- terminate,
										ctrl_ref2::ext_pow24VStatus <- ext_pow24VStatus
									]]
								)
									[|{|terminate|}|]
								(
									ctrl_ref3::D__(id__)[[
										ctrl_ref3::terminate <- terminate,
										ctrl_ref3::ActualHV_2 <- int_ActualHV
									]]
								)
							)
							\
							diff(
								{|terminate|},
								{|terminate|}
							)
						)
						\
						diff(
							{|terminate|},
							{|terminate|}
						)
					)
					\
					diff(
						{|terminate|},
						{|terminate|}
					)
						[|
							union(
								{|
								|},
								{|
								|}
							)
						|]
					Memory(id__)
				)
			)
			\ Union({
				{|
					ctrl_ref0::int_DisableHV,
					ctrl_ref1::int_DisableHV,
					ctrl_ref1::int_underLimit,
					ctrl_ref0::int_underLimit,
					ctrl_ref1::int_overLimit,
					ctrl_ref0::int_overLimit,
					ctrl_ref3::int_ActualHV,
					ctrl_ref0::int_ActualHV,
					ctrl_ref1::int_ActualHV,
					ctrl_ref3::ActualHV_1,
					ctrl_ref1::ext_pow24VStatus,
					ctrl_ref2::ext_pow24_2,
					ctrl_ref0::ext_pow24VStatus,
					ctrl_ref2::ext_pow24_1
				|},
				{|
				|},
				{|
				|}
			})
			[|{|terminate|}|>SKIP
		)
		\{|terminate|}
	
	-- visible state equivalent
	
	VS__(id__) = let
		Buffer0(<v>) = 
			ctrl_ref1::int_DisableHV.out -> Buffer0(<1>) 
			[]
			ctrl_ref0::int_DisableHV.in -> Buffer0(<>)
		Buffer0(<>) = ctrl_ref1::int_DisableHV.out -> Buffer0(<1>)
		Buffer1(<v>) = 
			ctrl_ref0::int_underLimit.out?x -> Buffer1(<x>)
			[]
			ctrl_ref1::int_underLimit.in!v -> Buffer1(<>)
		Buffer1(<>) = ctrl_ref0::int_underLimit.out?x -> Buffer1(<x>)
		Buffer2(<v>) = 
			ctrl_ref0::int_overLimit.out?x -> Buffer2(<x>)
			[]
			ctrl_ref1::int_overLimit.in!v -> Buffer2(<>)
		Buffer2(<>) = ctrl_ref0::int_overLimit.out?x -> Buffer2(<x>)
		Buffer3(<v>) = 
			ctrl_ref0::int_ActualHV.out?x -> Buffer3(<x>)
			[]
			ctrl_ref3::int_ActualHV.in!v -> Buffer3(<>)
		Buffer3(<>) = ctrl_ref0::int_ActualHV.out?x -> Buffer3(<x>)
		Buffer4(<v>) = 
			ctrl_ref3::ActualHV_1.out?x -> Buffer4(<x>)
			[]
			ctrl_ref1::int_ActualHV.in!v -> Buffer4(<>)
		Buffer4(<>) = ctrl_ref3::ActualHV_1.out?x -> Buffer4(<x>)
		Buffer5(<v>) = 
			ctrl_ref2::ext_pow24_2.out?x -> Buffer5(<x>)
			[]
			ctrl_ref1::ext_pow24VStatus.in!v -> Buffer5(<>)
		Buffer5(<>) = ctrl_ref2::ext_pow24_2.out?x -> Buffer5(<x>)
		Buffer6(<v>) = 
			ctrl_ref2::ext_pow24_1.out?x -> Buffer6(<x>)
			[]
			ctrl_ref0::ext_pow24VStatus.in!v -> Buffer6(<>)
		Buffer6(<>) = ctrl_ref2::ext_pow24_1.out?x -> Buffer6(<x>)
		
	within
		(
			(
				(Buffer0(<>)|||
				Buffer1(<>)|||
				Buffer2(<>)|||
				Buffer3(<>)|||
				Buffer4(<>)|||
				Buffer5(<>)|||
				Buffer6(<>)
				)
					[|{|ctrl_ref0::int_DisableHV,ctrl_ref1::int_DisableHV,ctrl_ref1::int_underLimit,ctrl_ref0::int_underLimit,ctrl_ref1::int_overLimit,ctrl_ref0::int_overLimit,ctrl_ref3::int_ActualHV,ctrl_ref0::int_ActualHV,ctrl_ref1::int_ActualHV,ctrl_ref3::ActualHV_1,ctrl_ref1::ext_pow24VStatus,ctrl_ref2::ext_pow24_2,ctrl_ref0::ext_pow24VStatus,ctrl_ref2::ext_pow24_1|}|]
				(
					(
						(
							ctrl_ref0::VS__(id__)[[
								ctrl_ref0::terminate <- terminate,
								ctrl_ref0::ext_setPoint <- ext_setPoint,
								ctrl_ref0::int_pwmSignal <- int_pwmSignal,
								ctrl_ref0::currentState <- currentState
							]]
						)
							[|{|terminate|}|]
						(
							(
								ctrl_ref1::VS__(id__)[[
									ctrl_ref1::terminate <- terminate
								]]
							)
								[|{|terminate|}|]
							(
								(
									ctrl_ref2::VS__(id__)[[
										ctrl_ref2::terminate <- terminate,
										ctrl_ref2::ext_pow24VStatus <- ext_pow24VStatus
									]]
								)
									[|{|terminate|}|]
								(
									ctrl_ref3::VS__(id__)[[
										ctrl_ref3::terminate <- terminate,
										ctrl_ref3::ActualHV_2 <- int_ActualHV
									]]
								)
							)
							\
							diff(
								{|terminate|},
								{|terminate|}
							)
						)
						\
						diff(
							{|terminate|},
							{|terminate|}
						)
					)
					\
					diff(
						{|terminate|},
						{|terminate|}
					)
						[|
							union(
								{|
								|},
								{|
								|}
							)
						|]
					Memory(id__)
				)
			)
			\ Union({
				{|
					ctrl_ref0::int_DisableHV,
					ctrl_ref1::int_DisableHV,
					ctrl_ref1::int_underLimit,
					ctrl_ref0::int_underLimit,
					ctrl_ref1::int_overLimit,
					ctrl_ref0::int_overLimit,
					ctrl_ref3::int_ActualHV,
					ctrl_ref0::int_ActualHV,
					ctrl_ref1::int_ActualHV,
					ctrl_ref3::ActualHV_1,
					ctrl_ref1::ext_pow24VStatus,
					ctrl_ref2::ext_pow24_2,
					ctrl_ref0::ext_pow24VStatus,
					ctrl_ref2::ext_pow24_1
				|},
				{|
				|},
				{|
				|}
			})
			[|{|terminate|}|>SKIP
		)
		\{|terminate|}
	
	-- O version (optimised)
	
	O__(id__) = sbisim(diamond(let
		Buffer0(<v>) = 
			ctrl_ref1::int_DisableHV.out -> Buffer0(<1>) 
			[]
			ctrl_ref0::int_DisableHV.in -> Buffer0(<>)
		Buffer0(<>) = ctrl_ref1::int_DisableHV.out -> Buffer0(<1>)
		Buffer1(<v>) = 
			ctrl_ref0::int_underLimit.out?x -> Buffer1(<x>)
			[]
			ctrl_ref1::int_underLimit.in!v -> Buffer1(<>)
		Buffer1(<>) = ctrl_ref0::int_underLimit.out?x -> Buffer1(<x>)
		Buffer2(<v>) = 
			ctrl_ref0::int_overLimit.out?x -> Buffer2(<x>)
			[]
			ctrl_ref1::int_overLimit.in!v -> Buffer2(<>)
		Buffer2(<>) = ctrl_ref0::int_overLimit.out?x -> Buffer2(<x>)
		Buffer3(<v>) = 
			ctrl_ref0::int_ActualHV.out?x -> Buffer3(<x>)
			[]
			ctrl_ref3::int_ActualHV.in!v -> Buffer3(<>)
		Buffer3(<>) = ctrl_ref0::int_ActualHV.out?x -> Buffer3(<x>)
		Buffer4(<v>) = 
			ctrl_ref3::ActualHV_1.out?x -> Buffer4(<x>)
			[]
			ctrl_ref1::int_ActualHV.in!v -> Buffer4(<>)
		Buffer4(<>) = ctrl_ref3::ActualHV_1.out?x -> Buffer4(<x>)
		Buffer5(<v>) = 
			ctrl_ref2::ext_pow24_2.out?x -> Buffer5(<x>)
			[]
			ctrl_ref1::ext_pow24VStatus.in!v -> Buffer5(<>)
		Buffer5(<>) = ctrl_ref2::ext_pow24_2.out?x -> Buffer5(<x>)
		Buffer6(<v>) = 
			ctrl_ref2::ext_pow24_1.out?x -> Buffer6(<x>)
			[]
			ctrl_ref0::ext_pow24VStatus.in!v -> Buffer6(<>)
		Buffer6(<>) = ctrl_ref2::ext_pow24_1.out?x -> Buffer6(<x>)
		
	within
		(
			(
				(Buffer0(<>)|||
				Buffer1(<>)|||
				Buffer2(<>)|||
				Buffer3(<>)|||
				Buffer4(<>)|||
				Buffer5(<>)|||
				Buffer6(<>)
				)
					[|{|ctrl_ref0::int_DisableHV,ctrl_ref1::int_DisableHV,ctrl_ref1::int_underLimit,ctrl_ref0::int_underLimit,ctrl_ref1::int_overLimit,ctrl_ref0::int_overLimit,ctrl_ref3::int_ActualHV,ctrl_ref0::int_ActualHV,ctrl_ref1::int_ActualHV,ctrl_ref3::ActualHV_1,ctrl_ref1::ext_pow24VStatus,ctrl_ref2::ext_pow24_2,ctrl_ref0::ext_pow24VStatus,ctrl_ref2::ext_pow24_1|}|]
				(
					(
						(
							ctrl_ref0::O__(id__)[[
								ctrl_ref0::terminate <- terminate,
								ctrl_ref0::ext_setPoint <- ext_setPoint,
								ctrl_ref0::int_pwmSignal <- int_pwmSignal,
								ctrl_ref0::currentState <- currentState
							]]
						)
							[|{|terminate|}|]
						(
							(
								ctrl_ref1::O__(id__)[[
									ctrl_ref1::terminate <- terminate
								]]
							)
								[|{|terminate|}|]
							(
								(
									ctrl_ref2::O__(id__)[[
										ctrl_ref2::terminate <- terminate,
										ctrl_ref2::ext_pow24VStatus <- ext_pow24VStatus
									]]
								)
									[|{|terminate|}|]
								(
									ctrl_ref3::O__(id__)[[
										ctrl_ref3::terminate <- terminate,
										ctrl_ref3::ActualHV_2 <- int_ActualHV
									]]
								)
							)
							\
							diff(
								{|terminate|},
								{|terminate|}
							)
						)
						\
						diff(
							{|terminate|},
							{|terminate|}
						)
					)
					\
					diff(
						{|terminate|},
						{|terminate|}
					)
						[|
							union(
								{|
								|},
								{|
								|}
							)
						|]
					Memory(id__)
				)
			)
			\ Union({
				{|
					ctrl_ref0::int_DisableHV,
					ctrl_ref1::int_DisableHV,
					ctrl_ref1::int_underLimit,
					ctrl_ref0::int_underLimit,
					ctrl_ref1::int_overLimit,
					ctrl_ref0::int_overLimit,
					ctrl_ref3::int_ActualHV,
					ctrl_ref0::int_ActualHV,
					ctrl_ref1::int_ActualHV,
					ctrl_ref3::ActualHV_1,
					ctrl_ref1::ext_pow24VStatus,
					ctrl_ref2::ext_pow24_2,
					ctrl_ref0::ext_pow24VStatus,
					ctrl_ref2::ext_pow24_1
				|},
				{|
				|},
				{|
				|}
			})
			[|{|terminate|}|>SKIP
		)
		\{|terminate|}
	))
	
	-- visible state optimised equivalent
	
	VS_O__(id__) = sbisim(diamond(let
		Buffer0(<v>) = 
			ctrl_ref1::int_DisableHV.out -> Buffer0(<1>) 
			[]
			ctrl_ref0::int_DisableHV.in -> Buffer0(<>)
		Buffer0(<>) = ctrl_ref1::int_DisableHV.out -> Buffer0(<1>)
		Buffer1(<v>) = 
			ctrl_ref0::int_underLimit.out?x -> Buffer1(<x>)
			[]
			ctrl_ref1::int_underLimit.in!v -> Buffer1(<>)
		Buffer1(<>) = ctrl_ref0::int_underLimit.out?x -> Buffer1(<x>)
		Buffer2(<v>) = 
			ctrl_ref0::int_overLimit.out?x -> Buffer2(<x>)
			[]
			ctrl_ref1::int_overLimit.in!v -> Buffer2(<>)
		Buffer2(<>) = ctrl_ref0::int_overLimit.out?x -> Buffer2(<x>)
		Buffer3(<v>) = 
			ctrl_ref0::int_ActualHV.out?x -> Buffer3(<x>)
			[]
			ctrl_ref3::int_ActualHV.in!v -> Buffer3(<>)
		Buffer3(<>) = ctrl_ref0::int_ActualHV.out?x -> Buffer3(<x>)
		Buffer4(<v>) = 
			ctrl_ref3::ActualHV_1.out?x -> Buffer4(<x>)
			[]
			ctrl_ref1::int_ActualHV.in!v -> Buffer4(<>)
		Buffer4(<>) = ctrl_ref3::ActualHV_1.out?x -> Buffer4(<x>)
		Buffer5(<v>) = 
			ctrl_ref2::ext_pow24_2.out?x -> Buffer5(<x>)
			[]
			ctrl_ref1::ext_pow24VStatus.in!v -> Buffer5(<>)
		Buffer5(<>) = ctrl_ref2::ext_pow24_2.out?x -> Buffer5(<x>)
		Buffer6(<v>) = 
			ctrl_ref2::ext_pow24_1.out?x -> Buffer6(<x>)
			[]
			ctrl_ref0::ext_pow24VStatus.in!v -> Buffer6(<>)
		Buffer6(<>) = ctrl_ref2::ext_pow24_1.out?x -> Buffer6(<x>)
		
	within
		(
			(
				(Buffer0(<>)|||
				Buffer1(<>)|||
				Buffer2(<>)|||
				Buffer3(<>)|||
				Buffer4(<>)|||
				Buffer5(<>)|||
				Buffer6(<>)
				)
					[|{|ctrl_ref0::int_DisableHV,ctrl_ref1::int_DisableHV,ctrl_ref1::int_underLimit,ctrl_ref0::int_underLimit,ctrl_ref1::int_overLimit,ctrl_ref0::int_overLimit,ctrl_ref3::int_ActualHV,ctrl_ref0::int_ActualHV,ctrl_ref1::int_ActualHV,ctrl_ref3::ActualHV_1,ctrl_ref1::ext_pow24VStatus,ctrl_ref2::ext_pow24_2,ctrl_ref0::ext_pow24VStatus,ctrl_ref2::ext_pow24_1|}|]
				(
					(
						(
							ctrl_ref0::VS_O__(id__)[[
								ctrl_ref0::terminate <- terminate,
								ctrl_ref0::ext_setPoint <- ext_setPoint,
								ctrl_ref0::int_pwmSignal <- int_pwmSignal,
								ctrl_ref0::currentState <- currentState
							]]
						)
							[|{|terminate|}|]
						(
							(
								ctrl_ref1::VS_O__(id__)[[
									ctrl_ref1::terminate <- terminate
								]]
							)
								[|{|terminate|}|]
							(
								(
									ctrl_ref2::VS_O__(id__)[[
										ctrl_ref2::terminate <- terminate,
										ctrl_ref2::ext_pow24VStatus <- ext_pow24VStatus
									]]
								)
									[|{|terminate|}|]
								(
									ctrl_ref3::VS_O__(id__)[[
										ctrl_ref3::terminate <- terminate,
										ctrl_ref3::ActualHV_2 <- int_ActualHV
									]]
								)
							)
							\
							diff(
								{|terminate|},
								{|terminate|}
							)
						)
						\
						diff(
							{|terminate|},
							{|terminate|}
						)
					)
					\
					diff(
						{|terminate|},
						{|terminate|}
					)
						[|
							union(
								{|
								|},
								{|
								|}
							)
						|]
					Memory(id__)
				)
			)
			\ Union({
				{|
					ctrl_ref0::int_DisableHV,
					ctrl_ref1::int_DisableHV,
					ctrl_ref1::int_underLimit,
					ctrl_ref0::int_underLimit,
					ctrl_ref1::int_overLimit,
					ctrl_ref0::int_overLimit,
					ctrl_ref3::int_ActualHV,
					ctrl_ref0::int_ActualHV,
					ctrl_ref1::int_ActualHV,
					ctrl_ref3::ActualHV_1,
					ctrl_ref1::ext_pow24VStatus,
					ctrl_ref2::ext_pow24_2,
					ctrl_ref0::ext_pow24VStatus,
					ctrl_ref2::ext_pow24_1
				|},
				{|
				|},
				{|
				|}
			})
			[|{|terminate|}|>SKIP
		)
		\{|terminate|}
	))
	
endmodule
