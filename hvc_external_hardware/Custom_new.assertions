
//instantiations
csp Instantiations csp-begin
-- generate nat
nametype core_nat = {0..3}

-- generate string
nametype core_string = LSeq({'a'},1)

-- generate real
nametype core_real = { -2..3}

-- BASIC FUNCTIONS

-- generate int
nametype core_int = { 0..3}

-- generate -- OPERATION BOUNDS

-- MODULE CONSTANTS

-- CONTROLLER CONSTANTS

-- STATEMACHINE CONSTANTS

-- OPERATION CONSTANTS

-- BASIC TYPES

-- generate Div
Div(e1,e2,T) = if member(e1/e2,T) then e1/e2 else e1

-- generate Neg
Neg(e1,T) = if member(-e1,T) then -e1 else e1

-- generate boolean
nametype core_boolean = Bool

-- generate Mult
Mult(e1,e2,T) = if member(e1*e2,T) then e1*e2 else e1

-- generate Modulus
Modulus(e1,e2,T) = if member(e1%e2,T) then e1%e2 else e1

-- generate Plus
Plus(e1,e2,T) = if member(e1+e2,T) then e1+e2 else e1

-- generate Minus
Minus(e1,e2,T) = if member(e1-e2,T) then e1-e2 else e1
csp-end

//Built in assertions



//Custom specs

//Spec P1
//untimed

untimed csp mod_sys_analysis csp-begin
mod_sys_analysis = mod_sys::O__(0) \ {|mod_sys::ext_setPoint.out|} 
csp-end

/***************************************************
 * Sate_machine assertions  
 ***************************************************/

//untimed csp setPointSpec_SM csp-begin
//
//csp-end
//
//untimed csp ErrorSpec3_SM csp-begin
//
//ErrorSpec3_SM = Behaviour3_SM
//
//Behaviour3_SM = CHAOS(diff(Events,x)) 
//			    [| {|State_Machine::ext_pow24VStatus.in.Power_Off|} |> 
//			    (State_Machine::ext_pwmSignal.out.Power_Off -> ErrorSpec3 |~| State_Machine::ext_pow24VStatus.in?x__ -> ErrorSpec3)
//csp-end
//
//untimed csp ctrl0_pow_pwm csp-begin
//
//ctrl0_pow_pwm = ctrl0::O__(0) |\ {|ctrl0::ext_pow24VStatus.in,ctrl0::ext_pwmSignal.out|}
//
//csp-end
//
////Assertion P2 
//assertion A2_SM : ctrl0_pow_pwm refines ErrorSpec3_SM in the traces model

/***************************************************
 * Module assertions  
 ***************************************************/

// This is an attempt at fully characterising P1 at the module level. Without information about whether
// the State_Machine is in the ClosedLoop state, it is difficult to know whether the ActualHV should
// follow the setPoint at all times (it shouldn't). Therefore the construction below is an attempt to
// capture the essence of the control flow in State_Machine, without information about which state
// the system is in.

// The following is mod_sys constrained, so that we only consider its behaviour when the power is stable,
// the values communicated via ext_setPoint are in the set {0,1}, and the other outputs (ext_setPoint.out
// and mod_sys::ext_pwmSignal.out) are ignored.
untimed csp mod_sys_cons csp-begin
mod_sys_cons = (mod_sys::O__(0) [| {| mod_sys::ext_pow24VStatus.in.Power_Off,mod_sys::ext_setPoint.in|} |] RUN({mod_sys::ext_setPoint.in.x__ | x__ <- {0,1}})) \ {|mod_sys::int_pwmSignal.out,mod_sys::ext_setPoint.out|} 
csp-end

untimed csp ErrorSpec12 csp-begin

channel int_ActualHV : core_real
channel read : core_real

-- The Power can be read as being on all the time, and the ouput for int_ActualHV is buffered.
-- We use an internal channel 'int_ActualHV' for this.

ErrorSpec12 = ((RUN({| mod_sys::ext_pow24VStatus.in.Power_On |}) ||| Init) 
				[| {| int_ActualHV |} |] BufferedOutput
				) \{|int_ActualHV|} 

-- The actual Buffered output is modelled as a composition of a Buffer
-- and a process Output that produces the event mod_sys::int_ActualHV.
-- The channel 'read' is used by Output internally to read from this buffer.
BufferedOutput = (Buffer [| {|read|} |] Output) \{|read|}

-- Output simply outputs what it reads.
Output = read?x__ -> mod_sys::int_ActualHV.out!x__ -> Output

-- A buffer, whose current 'value' can be overwritten.
Buffer = int_ActualHV?x__ -> (read!x__ -> Buffer [] Buffer)

-- Initialisation, the first setPoint can be anything.
Init = mod_sys::ext_setPoint.in?x:{0,1} -> Wait24V
 
-- This corresponds to waiting for the 24V power. At this point,
-- the setPoint value must be 0, otherwise there is an error, and int_ActualHV should be zero.
Wait24V = (mod_sys::ext_setPoint.in.0 -> ON [] mod_sys::ext_setPoint.in?x:{x|x<-{0,1},not x==0} -> int_ActualHV.0 -> Wait24V)

-- If it's stable, and ON, then the value communicated via ext_setPoint 
-- is used to set the ActualHV.
ON = mod_sys::ext_setPoint.in?x__:{0,1} -> int_ActualHV.x__ -> ON
	
csp-end

// The above is a little unwise

//untimed csp ErrorSpec1 csp-begin
//
//ErrorSpec1 = setPointSpec(0)
//	
//csp-end
//
//untimed csp ErrorSpec2 csp-begin
//
//ErrorSpec2 = setPointSpec(1)
//	
//csp-end


untimed csp mod_sys_power_on csp-begin
mod_sys_power_on = (mod_sys::O__(0) 
	[| {| mod_sys::ext_setPoint.in,mod_sys::ext_pow24VStatus.in |} |] 
	RUN(union({mod_sys::ext_setPoint.in.x__ | x__ <- {0,1}},{|mod_sys::ext_pow24VStatus.in.Power_On|})))\{|mod_sys::int_pwmSignal.out|}
csp-end

untimed csp mod_sys_can_loop csp-begin
mod_sys_can_loop = mod_sys_power_on |\ {| mod_sys::currentState.out.State_ClosedLoop |}
csp-end

untimed csp Spec12 csp-begin

Spec12 = (Behaviour [| {|int_ActualHV|} |] BufferedOutput)\{|int_ActualHV|}

Behaviour = CHAOS(Events) 
		 	[| {| mod_sys::currentState.out.State_ClosedLoop |} |> 
		 	((RUN({|mod_sys::ext_pow24VStatus.in.Power_On|}) ||| ClosedLoop) /\ mod_sys::currentState.out.State_ErrorMode -> Behaviour)

ClosedLoop = mod_sys::ext_setPoint.in?x__:{0,1} -> int_ActualHV.x__ -> ClosedLoop

csp-end

untimed csp Stop csp-begin
Stop = STOP
csp-end

untimed csp mod_sys_extSetPointOut csp-begin

mod_sys_extSetPointOut = mod_sys::O__(0) |\ {|mod_sys::ext_setPoint.in |}

csp-end
untimed assertion C0: mod_sys_extSetPointOut does not refine Stop


untimed csp mod_sys_extpow24VStatus csp-begin

mod_sys_extpow24VStatus = mod_sys::O__(0) |\ {|mod_sys::ext_pow24VStatus.in |}

csp-end
untimed assertion C1: mod_sys_extpow24VStatus does not refine Stop

//Spec P2: PWMoutput set to 0 when 24V power switched off

//untimed
//untimed csp ErrorSpec3 csp-begin

//ErrorSpec3 = CHAOS(Events) [| {|State_machine::set_pow24VStatus.Power_Off|} |> State_machine::set_pwmSignal.Power_Off -> ErrorSpec3
	
//csp-end

//timed

//Spec P2
//untimed csp ErrorSpec3 csp-begin
//
//ErrorSpec3 = Behaviour3({})
//
//Behaviour3(x) = CHAOS(diff(Events,x)) 
//			    [| {|mod_sys::ext_pow24VStatus.in.Power_Off|} |> 
//			    (mod_sys::ext_pwmSignal.out.Power_Off -> ErrorSpec3 |~| mod_sys::ext_pow24VStatus.in?x__ -> ErrorSpec3) --Behaviour3({|mod_sys::ext_pwmSignal.out|}))
//csp-end

untimed csp Spec3 csp-begin
Spec3 = CHAOS(Events) [| {| mod_sys::ext_pow24VStatus.in.Power_Off |} |> mod_sys::int_pwmSignal.out.Power_Off -> Spec3
csp-end

//Spec p3
//untimed csp ErrorSpec4 csp-begin
//
//ErrorSpec4 = CHAOS(Events) [| {|mod_sys::ext_pow24VStatus.in.Power_Off|} |> (mod_sys::ext_setPoint.out.0 -> ErrorSpec4 |~| mod_sys::ext_pow24VStatus.in.Power_Off -> ErrorSpec3)
//	
//csp-end

untimed csp Spec4 csp-begin
Spec4 = CHAOS(Events) [| {|mod_sys::ext_pow24VStatus.in.Power_Off|} |> mod_sys::ext_setPoint.out.0 -> Spec4
csp-end

untimed csp mod_sys_power csp-begin
mod_sys_power = (mod_sys::O__(0) [| {|mod_sys::ext_pow24VStatus.in.Power_Off|} |] SKIP)
csp-end

untimed csp mod_sys_pow_pwm csp-begin

mod_sys_pow_pwm = mod_sys::O__(0) |\ {|mod_sys::ext_pow24VStatus.in,mod_sys::int_pwmSignal.out|}

csp-end

//untimed csp ErrorSpec4 csp-begin

//ErrorSpec4 = CHAOS(Events) [| {|State_machine::set_pow24VStatus.Power_Off|} |> State_machine::set_pwmSignal.Power_Off -> ErrorSpec4
	
//csp-end


//Spec P3: PWMOutput set to 0 when setPoint is set to 0
//untimed csp ErrorSpec4 csp-begin

//ErrorSpec4 = CHAOS(Events) [| {|State_machine::set_pow24VStatus.Power_Off|} |> State_machine::set_setPoint.0-> ErrorSpec4
	
//csp-end

//Custom assertions
//Assertion P1
//assertion A0 : mod_sys_cons refines ErrorSpec12 in the traces model
//assertion A0fd : mod_sys_cons refines ErrorSpec12
//assertion A1 : mod_sys_cons refines ErrorSpec2


// New Assertion P1
assertion A1 : mod_sys_power_on refines Spec12 in the traces model
assertion A1witness : mod_sys_can_loop does not refine Stop in the traces model

//Assertion P2 
assertion A2 : mod_sys_power  refines Spec3

//Assertion P3
assertion A3 : mod_sys_power  refines Spec4

//Built in assertions
//Assertion P4
assertion A4 : mod_sys is deadlock-free


assertion A6 : State_machine::Init is reachable in State_machine

assertion A8 : State_machine::ClosedLoop is reachable in State_machine


//timed

timed csp TsetPointSpec csp-begin
Timed(OneStep){
TsetPointSpec(n) = CHAOS(Events) [| {|State_machine::set_setPoint.n |} |> State_machine::set_ActualHV.n -> TsetPointSpec(n)
	}
csp-end

timed csp TErrorSpec1 csp-begin

TErrorSpec1 = TsetPointSpec(0)
	
csp-end

timed csp TErrorSpec2 csp-begin

TErrorSpec2 = TsetPointSpec(1)
	
csp-end

//timed
timed csp TErrorSpec3 csp-begin
Timed(OneStep){
TErrorSpec3 = CHAOS(Events) [| {|State_machine::set_pow24VStatus.Power_Off|} |> State_machine::set_pwmSignal.Power_Off -> State_machine::set_setPoint.0 -> TErrorSpec3
	}
csp-end