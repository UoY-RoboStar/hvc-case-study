package P1_Spec1A

import basics::*

// P1A: That the actual system voltage always follows the set-point
pmodules M1A:
	pmodule P1A {
		// -1 - failure
		// 0 - idle
		// 1 - enter ClosedLoop (setpoint is -1)
		// 2 - get a ext_setPoint and setpoint is not set
		// 3 - output int_ActualHV after an ext_setPoint, and setpoint is set to the value on ext_setPoint. 
		// 4 - get the second ext_setPoint
		// 5 - a delay identified or check the value on int_ActualHV
		// 6 - no delay or ready to accept ext_setPoint
		P1A_scpc : [-1 to 6] init 0;
		P1A_updating: bool init false;
		// buffered set point, -1 means an initial state (no valid data buffered), 
		// 0..2 denotes the range of real numbers as defined in rc2prism.prefs 
		setpoint : [-1 to 2] init -1;
		
		//////////////////////////////////// Idle state 0 (free events) ////////////////////////////////////////////
		//[mod_sys::rp_ref0::ext_setPoint.in]  (P1A_updating==false)/\(P1A_scpc==0)	-> (0.5:P1A_updating=false) & (0.5:P1A_updating=true); 
		[mod_sys::rp_ref0::ext_setPoint.out]  (@P1A_updating==false)/\(@P1A_scpc==0)	-> skip; 
		[mod_sys::rp_ref0::int_ActualHV.in] (@P1A_updating==false)/\(@P1A_scpc==0) -> skip;

	    [mod_sys::rp_ref0::currentState.in] (@P1A_updating==false) /\ 
	    	((@P1A_scpc == 0) \/ (@P1A_scpc == 1) \/ (@P1A_scpc == 3) \/ (@P1A_scpc == 6))            
	    	-> (@P1A_scpc=0)&(@P1A_updating=true);		
	    // if current state is ClosedLoop, then scpc stays the same as 1
	    // (0, busy) --> (1, idle)
	    [] (@P1A_scpc==0)/\(@P1A_updating==true)/\(mod_sys::rp_ref0::currentState.in.val==State::ClosedLoop) 
	    	-> (@P1A_scpc=1)&(@P1A_updating=false)&(@setpoint=-1);
	    // otherwise, return to idle by setting scpc to 0
	    [] (@P1A_scpc==0)/\(@P1A_updating==true)/\(mod_sys::rp_ref0::currentState.in.val!=State::ClosedLoop) 
	    	-> (@P1A_scpc=0)&(@P1A_updating=false);
	    
	    /////////////////////////////////////////////// State 1  //////////////////////////////////////////////////
	    // (1, idle) --> (1, busy)
	    [mod_sys::rp_ref0::ext_setPoint.out]   (@P1A_updating==false)/\(@P1A_scpc==1)                      
	    	-> (@P1A_scpc=1)&(@P1A_updating=true);
	    // (1, busy) --> (2, idle)
	    [] (@P1A_scpc==1)/\(@P1A_updating==true)             
	    	-> (@P1A_scpc=2)&(@P1A_updating=false);
	    
	    /////////////////////////////////////////////// State 2  //////////////////////////////////////////////////
	    [mod_sys::rp_ref0::int_ActualHV.in]  (@P1A_updating==false)/\(@P1A_scpc==2)                    
	    	-> (@P1A_scpc=3)&(@P1A_updating=false)&(@setpoint=mod_sys::rp_ref0::ext_setPoint.out.val);
	    
	    /////////////////////////////////////////////// State 3  //////////////////////////////////////////////////
	    [mod_sys::rp_ref0::ext_setPoint.out]   (@P1A_updating==false)/\(@P1A_scpc==3)                      
	    	-> (@P1A_scpc=4)&(@P1A_updating=false);
	    
	    /////////////////////////////////////////////// State 4  //////////////////////////////////////////////////
	    [mod_sys::rp_ref0::int_ActualHV.in]  (@P1A_updating==false)/\(@P1A_scpc==4)                    
	    	-> (@P1A_scpc=4)&(@P1A_updating=true);
	    
	    // The actualHV is equal to current setPoint or buffered setPoint
	    [] (@P1A_scpc==4)/\(@P1A_updating==true) /\
	    	(mod_sys::rp_ref0::int_ActualHV.in.val != mod_sys::rp_ref0::ext_setPoint.out.val) /\
	    	(mod_sys::rp_ref0::int_ActualHV.in.val != @setpoint)
	    	-> (@P1A_scpc=-1)&(@P1A_updating=false); 
	    // The actualHV is not equal to current setPoint or buffered setPoint
	    [] (@P1A_scpc==4)/\(@P1A_updating==true) /\ 
	    	(	(mod_sys::rp_ref0::int_ActualHV.in.val == mod_sys::rp_ref0::ext_setPoint.out.val) \/
	    		(mod_sys::rp_ref0::int_ActualHV.in.val == @setpoint)
	    	) /\
	    	(mod_sys::rp_ref0::ext_setPoint.out.val == @setpoint)       
	    	-> (@P1A_scpc=3)&(@P1A_updating=false)/* &(@setpoint=mod_sys::rp_ref0::ext_setPoint.out.val)*/;
	    	
	    [] (@P1A_scpc==4)/\(@P1A_updating==true) /\ 
	    	(	(mod_sys::rp_ref0::int_ActualHV.in.val == mod_sys::rp_ref0::ext_setPoint.out.val) \/
	    		(mod_sys::rp_ref0::int_ActualHV.in.val == @setpoint)
	    	) /\
	    	(mod_sys::rp_ref0::ext_setPoint.out.val != @setpoint) /\
	    	(mod_sys::rp_ref0::int_ActualHV.in.val == mod_sys::rp_ref0::ext_setPoint.out.val)      
	    	-> (@P1A_scpc=6)&(@P1A_updating=false)/* &(@setpoint=mod_sys::rp_ref0::ext_setPoint.out.val)*/; 
	    	
	    [] (@P1A_scpc==4)/\(@P1A_updating==true) /\ 
	    	(	(mod_sys::rp_ref0::int_ActualHV.in.val == mod_sys::rp_ref0::ext_setPoint.out.val) \/
	    		(mod_sys::rp_ref0::int_ActualHV.in.val == @setpoint)
	    	) /\
	    	(mod_sys::rp_ref0::ext_setPoint.out.val != @setpoint) /\
	    	(mod_sys::rp_ref0::int_ActualHV.in.val == @setpoint)      
	    	-> (@P1A_scpc=5)&(@P1A_updating=false)/* &(@setpoint=mod_sys::rp_ref0::ext_setPoint.out.val)*/; 
	    
	    /////////////////////////////////////////////// State 5  //////////////////////////////////////////////////
	    [mod_sys::rp_ref0::int_ActualHV.in]  (@P1A_updating==false)/\(@P1A_scpc==5)                    
	    	-> (@P1A_scpc=5)&(@P1A_updating=true);
	    
	    [] (@P1A_scpc==5)/\(@P1A_updating==true) /\
	    	(mod_sys::rp_ref0::int_ActualHV.in.val == mod_sys::rp_ref0::ext_setPoint.out.val) 
	    	-> (@P1A_scpc=6)&(@P1A_updating=false);
	    	
	    [] (@P1A_scpc==5)/\(@P1A_updating==true) /\
	    	(mod_sys::rp_ref0::int_ActualHV.in.val != mod_sys::rp_ref0::ext_setPoint.out.val) 
	    	-> (@P1A_scpc=-1)&(@P1A_updating=false); 
	    
	    /////////////////////////////////////////////// State 6  //////////////////////////////////////////////////
	    [mod_sys::rp_ref0::ext_setPoint.out]   (@P1A_updating==false)/\(@P1A_scpc==6)                      
	    	-> (@P1A_scpc=5)&(@P1A_updating=false);
	}
	
//prob property P1_sim:
//	Prob>=1.0 of [Globally @M1A::P1A::P1A_scpc != -1]
//	using sim with CI at alpha=0.01, n=1000, and pathlen=10000000
//	with definitions D1
//	with modules M1A
//	with cmdoptions "-hybrid -cuddmaxmem 256g -javamaxmem 8g"

label l1 = @M1A::P1A::P1A_scpc != -1

prob property P1A:
	Forall [Globally #l1]
	with definitions D1
	with modules M1A
	with cmdoptions "-hybrid -cuddmaxmem 400g -javamaxmem 8g"

prob property P1A_deadlock_free:
	not Exists [Finally deadlock]
	with definitions D1
	with modules M1A
	with cmdoptions "-hybrid -cuddmaxmem 400g -javamaxmem 8g"